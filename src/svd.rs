use core::ops::Deref;
use bare_metal::Peripheral;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[cfg(feature = "rt")]
    extern "C" {
        fn DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    #[allow(non_snake_case)]
    #[no_mangle]
    pub unsafe extern "C" fn DH_TRAMPOLINE() {
        DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    global_asm!(
        "\n.weak PM\nPM = DH_TRAMPOLINE\n.weak SYSCTRL\nSYSCTRL = DH_TRAMPOLINE\n.weak WDT\nWDT = DH_TRAMPOLINE\n.weak RTC\nRTC = DH_TRAMPOLINE\n.weak EIC\nEIC = DH_TRAMPOLINE\n.weak NVMCTRL\nNVMCTRL = DH_TRAMPOLINE\n.weak EVSYS\nEVSYS = DH_TRAMPOLINE\n.weak SERCOM0\nSERCOM0 = DH_TRAMPOLINE\n.weak SERCOM1\nSERCOM1 = DH_TRAMPOLINE\n.weak SERCOM2\nSERCOM2 = DH_TRAMPOLINE\n.weak SERCOM3\nSERCOM3 = DH_TRAMPOLINE\n.weak TC0\nTC0 = DH_TRAMPOLINE\n.weak TC1\nTC1 = DH_TRAMPOLINE\n.weak TC2\nTC2 = DH_TRAMPOLINE\n.weak TC3\nTC3 = DH_TRAMPOLINE\n.weak TC4\nTC4 = DH_TRAMPOLINE\n.weak TC5\nTC5 = DH_TRAMPOLINE\n.weak ADC\nADC = DH_TRAMPOLINE\n.weak AC\nAC = DH_TRAMPOLINE\n.weak DAC\nDAC = DH_TRAMPOLINE"
    );
    #[cfg(feature = "rt")]
    extern "C" {
        fn PM();
        fn SYSCTRL();
        fn WDT();
        fn RTC();
        fn EIC();
        fn NVMCTRL();
        fn EVSYS();
        fn SERCOM0();
        fn SERCOM1();
        fn SERCOM2();
        fn SERCOM3();
        fn TC0();
        fn TC1();
        fn TC2();
        fn TC3();
        fn TC4();
        fn TC5();
        fn ADC();
        fn AC();
        fn DAC();
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS: [Option<unsafe extern "C" fn()>; 24] = [
        Some(PM),
        Some(SYSCTRL),
        Some(WDT),
        Some(RTC),
        Some(EIC),
        Some(NVMCTRL),
        Some(EVSYS),
        Some(SERCOM0),
        Some(SERCOM1),
        Some(SERCOM2),
        Some(SERCOM3),
        None,
        None,
        Some(TC0),
        Some(TC1),
        Some(TC2),
        Some(TC3),
        Some(TC4),
        Some(TC5),
        None,
        None,
        Some(ADC),
        Some(AC),
        Some(DAC),
    ];
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - PM"]
        PM,
        #[doc = "1 - SYSCTRL"]
        SYSCTRL,
        #[doc = "2 - WDT"]
        WDT,
        #[doc = "3 - RTC"]
        RTC,
        #[doc = "4 - EIC"]
        EIC,
        #[doc = "5 - NVMCTRL"]
        NVMCTRL,
        #[doc = "6 - EVSYS"]
        EVSYS,
        #[doc = "7 - SERCOM0"]
        SERCOM0,
        #[doc = "8 - SERCOM1"]
        SERCOM1,
        #[doc = "9 - SERCOM2"]
        SERCOM2,
        #[doc = "10 - SERCOM3"]
        SERCOM3,
        #[doc = "13 - TC0"]
        TC0,
        #[doc = "14 - TC1"]
        TC1,
        #[doc = "15 - TC2"]
        TC2,
        #[doc = "16 - TC3"]
        TC3,
        #[doc = "17 - TC4"]
        TC4,
        #[doc = "18 - TC5"]
        TC5,
        #[doc = "21 - ADC"]
        ADC,
        #[doc = "22 - AC"]
        AC,
        #[doc = "23 - DAC"]
        DAC,
    }
    unsafe impl Nr for Interrupt {
        #[inline]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::PM => 0,
                Interrupt::SYSCTRL => 1,
                Interrupt::WDT => 2,
                Interrupt::RTC => 3,
                Interrupt::EIC => 4,
                Interrupt::NVMCTRL => 5,
                Interrupt::EVSYS => 6,
                Interrupt::SERCOM0 => 7,
                Interrupt::SERCOM1 => 8,
                Interrupt::SERCOM2 => 9,
                Interrupt::SERCOM3 => 10,
                Interrupt::TC0 => 13,
                Interrupt::TC1 => 14,
                Interrupt::TC2 => 15,
                Interrupt::TC3 => 16,
                Interrupt::TC4 => 17,
                Interrupt::TC5 => 18,
                Interrupt::ADC => 21,
                Interrupt::AC => 22,
                Interrupt::DAC => 23,
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::FPB;
pub use cortex_m::peripheral::FPU;
pub use cortex_m::peripheral::ITM;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::SYST;
pub use cortex_m::peripheral::TPIU;
#[doc = "Analog Comparators"]
pub const AC: Peripheral<AC> = unsafe { Peripheral::new(0x4200_4400) };
#[doc = "Analog Comparators"]
pub mod ac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x02 - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved0: [u8; 1usize],
        #[doc = "0x08 - Status A"]
        pub statusa: STATUSA,
        #[doc = "0x09 - Status B"]
        pub statusb: STATUSB,
        #[doc = "0x0a - Status C"]
        pub statusc: STATUSC,
        _reserved1: [u8; 1usize],
        #[doc = "0x0c - Window Control"]
        pub winctrl: WINCTRL,
        _reserved2: [u8; 3usize],
        #[doc = "0x10 - Comparator Control n"]
        pub compctrl: [COMPCTRL; 2],
        _reserved3: [u8; 8usize],
        #[doc = "0x20 - Scaler n"]
        pub scaler: [SCALER; 2],
    }
    #[doc = "Comparator Control n"]
    pub struct COMPCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Comparator Control n"]
    pub mod compctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SINGLER {
            bits: bool,
        }
        impl SINGLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SPEED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPEEDR {
            #[doc = "Low speed"]
            LOW,
            #[doc = "High speed"]
            HIGH,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SPEEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SPEEDR::LOW => 0,
                    SPEEDR::HIGH => 0x01,
                    SPEEDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SPEEDR {
                match value {
                    0 => SPEEDR::LOW,
                    1 => SPEEDR::HIGH,
                    i => SPEEDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SPEEDR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SPEEDR::HIGH
            }
        }
        #[doc = "Possible values of the field `INTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTSELR {
            #[doc = "Interrupt on comparator output toggle"]
            TOGGLE,
            #[doc = "Interrupt on comparator output rising"]
            RISING,
            #[doc = "Interrupt on comparator output falling"]
            FALLING,
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            EOC,
        }
        impl INTSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INTSELR::TOGGLE => 0,
                    INTSELR::RISING => 0x01,
                    INTSELR::FALLING => 0x02,
                    INTSELR::EOC => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INTSELR {
                match value {
                    0 => INTSELR::TOGGLE,
                    1 => INTSELR::RISING,
                    2 => INTSELR::FALLING,
                    3 => INTSELR::EOC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline]
            pub fn is_toggle(&self) -> bool {
                *self == INTSELR::TOGGLE
            }
            #[doc = "Checks if the value of the field is `RISING`"]
            #[inline]
            pub fn is_rising(&self) -> bool {
                *self == INTSELR::RISING
            }
            #[doc = "Checks if the value of the field is `FALLING`"]
            #[inline]
            pub fn is_falling(&self) -> bool {
                *self == INTSELR::FALLING
            }
            #[doc = "Checks if the value of the field is `EOC`"]
            #[inline]
            pub fn is_eoc(&self) -> bool {
                *self == INTSELR::EOC
            }
        }
        #[doc = "Possible values of the field `MUXNEG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXNEGR {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
            #[doc = "Ground"]
            GND,
            #[doc = "VDD scaler"]
            VSCALE,
            #[doc = "Internal bandgap voltage"]
            BANDGAP,
            #[doc = "DAC output"]
            DAC,
        }
        impl MUXNEGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXNEGR::PIN0 => 0,
                    MUXNEGR::PIN1 => 0x01,
                    MUXNEGR::PIN2 => 0x02,
                    MUXNEGR::PIN3 => 0x03,
                    MUXNEGR::GND => 0x04,
                    MUXNEGR::VSCALE => 0x05,
                    MUXNEGR::BANDGAP => 0x06,
                    MUXNEGR::DAC => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MUXNEGR {
                match value {
                    0 => MUXNEGR::PIN0,
                    1 => MUXNEGR::PIN1,
                    2 => MUXNEGR::PIN2,
                    3 => MUXNEGR::PIN3,
                    4 => MUXNEGR::GND,
                    5 => MUXNEGR::VSCALE,
                    6 => MUXNEGR::BANDGAP,
                    7 => MUXNEGR::DAC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline]
            pub fn is_pin0(&self) -> bool {
                *self == MUXNEGR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline]
            pub fn is_pin1(&self) -> bool {
                *self == MUXNEGR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline]
            pub fn is_pin2(&self) -> bool {
                *self == MUXNEGR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline]
            pub fn is_pin3(&self) -> bool {
                *self == MUXNEGR::PIN3
            }
            #[doc = "Checks if the value of the field is `GND`"]
            #[inline]
            pub fn is_gnd(&self) -> bool {
                *self == MUXNEGR::GND
            }
            #[doc = "Checks if the value of the field is `VSCALE`"]
            #[inline]
            pub fn is_vscale(&self) -> bool {
                *self == MUXNEGR::VSCALE
            }
            #[doc = "Checks if the value of the field is `BANDGAP`"]
            #[inline]
            pub fn is_bandgap(&self) -> bool {
                *self == MUXNEGR::BANDGAP
            }
            #[doc = "Checks if the value of the field is `DAC`"]
            #[inline]
            pub fn is_dac(&self) -> bool {
                *self == MUXNEGR::DAC
            }
        }
        #[doc = "Possible values of the field `MUXPOS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXPOSR {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
        }
        impl MUXPOSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXPOSR::PIN0 => 0,
                    MUXPOSR::PIN1 => 0x01,
                    MUXPOSR::PIN2 => 0x02,
                    MUXPOSR::PIN3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MUXPOSR {
                match value {
                    0 => MUXPOSR::PIN0,
                    1 => MUXPOSR::PIN1,
                    2 => MUXPOSR::PIN2,
                    3 => MUXPOSR::PIN3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline]
            pub fn is_pin0(&self) -> bool {
                *self == MUXPOSR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline]
            pub fn is_pin1(&self) -> bool {
                *self == MUXPOSR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline]
            pub fn is_pin2(&self) -> bool {
                *self == MUXPOSR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline]
            pub fn is_pin3(&self) -> bool {
                *self == MUXPOSR::PIN3
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWAPR {
            bits: bool,
        }
        impl SWAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `OUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTR {
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            OFF,
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            ASYNC,
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            SYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    OUTR::OFF => 0,
                    OUTR::ASYNC => 0x01,
                    OUTR::SYNC => 0x02,
                    OUTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> OUTR {
                match value {
                    0 => OUTR::OFF,
                    1 => OUTR::ASYNC,
                    2 => OUTR::SYNC,
                    i => OUTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == OUTR::OFF
            }
            #[doc = "Checks if the value of the field is `ASYNC`"]
            #[inline]
            pub fn is_async(&self) -> bool {
                *self == OUTR::ASYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline]
            pub fn is_sync(&self) -> bool {
                *self == OUTR::SYNC
            }
        }
        #[doc = r" Value of the field"]
        pub struct HYSTR {
            bits: bool,
        }
        impl HYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `FLEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLENR {
            #[doc = "No filtering"]
            OFF,
            #[doc = "3-bit majority function (2 of 3)"]
            MAJ3,
            #[doc = "5-bit majority function (3 of 5)"]
            MAJ5,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FLENR::OFF => 0,
                    FLENR::MAJ3 => 0x01,
                    FLENR::MAJ5 => 0x02,
                    FLENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FLENR {
                match value {
                    0 => FLENR::OFF,
                    1 => FLENR::MAJ3,
                    2 => FLENR::MAJ5,
                    i => FLENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == FLENR::OFF
            }
            #[doc = "Checks if the value of the field is `MAJ3`"]
            #[inline]
            pub fn is_maj3(&self) -> bool {
                *self == FLENR::MAJ3
            }
            #[doc = "Checks if the value of the field is `MAJ5`"]
            #[inline]
            pub fn is_maj5(&self) -> bool {
                *self == FLENR::MAJ5
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SINGLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SINGLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPEED`"]
        pub enum SPEEDW {
            #[doc = "Low speed"]
            LOW,
            #[doc = "High speed"]
            HIGH,
        }
        impl SPEEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SPEEDW::LOW => 0,
                    SPEEDW::HIGH => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPEEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPEEDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Low speed"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SPEEDW::LOW)
            }
            #[doc = "High speed"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SPEEDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INTSEL`"]
        pub enum INTSELW {
            #[doc = "Interrupt on comparator output toggle"]
            TOGGLE,
            #[doc = "Interrupt on comparator output rising"]
            RISING,
            #[doc = "Interrupt on comparator output falling"]
            FALLING,
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            EOC,
        }
        impl INTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INTSELW::TOGGLE => 0,
                    INTSELW::RISING => 1,
                    INTSELW::FALLING => 2,
                    INTSELW::EOC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INTSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Interrupt on comparator output toggle"]
            #[inline]
            pub fn toggle(self) -> &'a mut W {
                self.variant(INTSELW::TOGGLE)
            }
            #[doc = "Interrupt on comparator output rising"]
            #[inline]
            pub fn rising(self) -> &'a mut W {
                self.variant(INTSELW::RISING)
            }
            #[doc = "Interrupt on comparator output falling"]
            #[inline]
            pub fn falling(self) -> &'a mut W {
                self.variant(INTSELW::FALLING)
            }
            #[doc = "Interrupt on end of comparison (single-shot mode only)"]
            #[inline]
            pub fn eoc(self) -> &'a mut W {
                self.variant(INTSELW::EOC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXNEG`"]
        pub enum MUXNEGW {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
            #[doc = "Ground"]
            GND,
            #[doc = "VDD scaler"]
            VSCALE,
            #[doc = "Internal bandgap voltage"]
            BANDGAP,
            #[doc = "DAC output"]
            DAC,
        }
        impl MUXNEGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXNEGW::PIN0 => 0,
                    MUXNEGW::PIN1 => 1,
                    MUXNEGW::PIN2 => 2,
                    MUXNEGW::PIN3 => 3,
                    MUXNEGW::GND => 4,
                    MUXNEGW::VSCALE => 5,
                    MUXNEGW::BANDGAP => 6,
                    MUXNEGW::DAC => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXNEGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXNEGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MUXNEGW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "I/O pin 0"]
            #[inline]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN0)
            }
            #[doc = "I/O pin 1"]
            #[inline]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN1)
            }
            #[doc = "I/O pin 2"]
            #[inline]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN2)
            }
            #[doc = "I/O pin 3"]
            #[inline]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN3)
            }
            #[doc = "Ground"]
            #[inline]
            pub fn gnd(self) -> &'a mut W {
                self.variant(MUXNEGW::GND)
            }
            #[doc = "VDD scaler"]
            #[inline]
            pub fn vscale(self) -> &'a mut W {
                self.variant(MUXNEGW::VSCALE)
            }
            #[doc = "Internal bandgap voltage"]
            #[inline]
            pub fn bandgap(self) -> &'a mut W {
                self.variant(MUXNEGW::BANDGAP)
            }
            #[doc = "DAC output"]
            #[inline]
            pub fn dac(self) -> &'a mut W {
                self.variant(MUXNEGW::DAC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXPOS`"]
        pub enum MUXPOSW {
            #[doc = "I/O pin 0"]
            PIN0,
            #[doc = "I/O pin 1"]
            PIN1,
            #[doc = "I/O pin 2"]
            PIN2,
            #[doc = "I/O pin 3"]
            PIN3,
        }
        impl MUXPOSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXPOSW::PIN0 => 0,
                    MUXPOSW::PIN1 => 1,
                    MUXPOSW::PIN2 => 2,
                    MUXPOSW::PIN3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXPOSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXPOSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MUXPOSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "I/O pin 0"]
            #[inline]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN0)
            }
            #[doc = "I/O pin 1"]
            #[inline]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN1)
            }
            #[doc = "I/O pin 2"]
            #[inline]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN2)
            }
            #[doc = "I/O pin 3"]
            #[inline]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUT`"]
        pub enum OUTW {
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            OFF,
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            ASYNC,
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            SYNC,
        }
        impl OUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OUTW::OFF => 0,
                    OUTW::ASYNC => 1,
                    OUTW::SYNC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OUTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The output of COMPn is not routed to the COMPn I/O port"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(OUTW::OFF)
            }
            #[doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
            #[inline]
            pub fn async(self) -> &'a mut W {
                self.variant(OUTW::ASYNC)
            }
            #[doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
            #[inline]
            pub fn sync(self) -> &'a mut W {
                self.variant(OUTW::SYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLEN`"]
        pub enum FLENW {
            #[doc = "No filtering"]
            OFF,
            #[doc = "3-bit majority function (2 of 3)"]
            MAJ3,
            #[doc = "5-bit majority function (3 of 5)"]
            MAJ5,
        }
        impl FLENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FLENW::OFF => 0,
                    FLENW::MAJ3 => 1,
                    FLENW::MAJ5 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No filtering"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(FLENW::OFF)
            }
            #[doc = "3-bit majority function (2 of 3)"]
            #[inline]
            pub fn maj3(self) -> &'a mut W {
                self.variant(FLENW::MAJ3)
            }
            #[doc = "5-bit majority function (3 of 5)"]
            #[inline]
            pub fn maj5(self) -> &'a mut W {
                self.variant(FLENW::MAJ5)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 1 - Single-Shot Mode"]
            #[inline]
            pub fn single(&self) -> SINGLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SINGLER { bits }
            }
            #[doc = "Bits 2:3 - Speed Selection"]
            #[inline]
            pub fn speed(&self) -> SPEEDR {
                SPEEDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 5:6 - Interrupt Selection"]
            #[inline]
            pub fn intsel(&self) -> INTSELR {
                INTSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - Negative Input Mux Selection"]
            #[inline]
            pub fn muxneg(&self) -> MUXNEGR {
                MUXNEGR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Positive Input Mux Selection"]
            #[inline]
            pub fn muxpos(&self) -> MUXPOSR {
                MUXPOSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - Swap Inputs and Invert"]
            #[inline]
            pub fn swap(&self) -> SWAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWAPR { bits }
            }
            #[doc = "Bits 16:17 - Output"]
            #[inline]
            pub fn out(&self) -> OUTR {
                OUTR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 19 - Hysteresis Enable"]
            #[inline]
            pub fn hyst(&self) -> HYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HYSTR { bits }
            }
            #[doc = "Bits 24:26 - Filter Length"]
            #[inline]
            pub fn flen(&self) -> FLENR {
                FLENR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 1 - Single-Shot Mode"]
            #[inline]
            pub fn single(&mut self) -> _SINGLEW {
                _SINGLEW { w: self }
            }
            #[doc = "Bits 2:3 - Speed Selection"]
            #[inline]
            pub fn speed(&mut self) -> _SPEEDW {
                _SPEEDW { w: self }
            }
            #[doc = "Bits 5:6 - Interrupt Selection"]
            #[inline]
            pub fn intsel(&mut self) -> _INTSELW {
                _INTSELW { w: self }
            }
            #[doc = "Bits 8:10 - Negative Input Mux Selection"]
            #[inline]
            pub fn muxneg(&mut self) -> _MUXNEGW {
                _MUXNEGW { w: self }
            }
            #[doc = "Bits 12:13 - Positive Input Mux Selection"]
            #[inline]
            pub fn muxpos(&mut self) -> _MUXPOSW {
                _MUXPOSW { w: self }
            }
            #[doc = "Bit 15 - Swap Inputs and Invert"]
            #[inline]
            pub fn swap(&mut self) -> _SWAPW {
                _SWAPW { w: self }
            }
            #[doc = "Bits 16:17 - Output"]
            #[inline]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
            #[doc = "Bit 19 - Hysteresis Enable"]
            #[inline]
            pub fn hyst(&mut self) -> _HYSTW {
                _HYSTW { w: self }
            }
            #[doc = "Bits 24:26 - Filter Length"]
            #[inline]
            pub fn flen(&mut self) -> _FLENW {
                _FLENW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LPMUXR {
            bits: bool,
        }
        impl LPMUXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPMUXW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Low-Power Mux"]
            #[inline]
            pub fn lpmux(&self) -> LPMUXR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LPMUXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Low-Power Mux"]
            #[inline]
            pub fn lpmux(&mut self) -> _LPMUXW {
                _LPMUXW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLB {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _START0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _START0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _START1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _START1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Start Comparison"]
            #[inline]
            pub fn start0(&mut self) -> _START0W {
                _START0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Start Comparison"]
            #[inline]
            pub fn start1(&mut self) -> _START1W {
                _START1W { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEO0R {
            bits: bool,
        }
        impl COMPEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEO1R {
            bits: bool,
        }
        impl COMPEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINEO0R {
            bits: bool,
        }
        impl WINEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEI0R {
            bits: bool,
        }
        impl COMPEI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEI1R {
            bits: bool,
        }
        impl COMPEI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEI0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEI1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Event Output Enable"]
            #[inline]
            pub fn compeo0(&self) -> COMPEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEO0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Event Output Enable"]
            #[inline]
            pub fn compeo1(&self) -> COMPEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEO1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Event Output Enable"]
            #[inline]
            pub fn wineo0(&self) -> WINEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WINEO0R { bits }
            }
            #[doc = "Bit 8 - Comparator 0 Event Input"]
            #[inline]
            pub fn compei0(&self) -> COMPEI0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEI0R { bits }
            }
            #[doc = "Bit 9 - Comparator 1 Event Input"]
            #[inline]
            pub fn compei1(&self) -> COMPEI1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                COMPEI1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Event Output Enable"]
            #[inline]
            pub fn compeo0(&mut self) -> _COMPEO0W {
                _COMPEO0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Event Output Enable"]
            #[inline]
            pub fn compeo1(&mut self) -> _COMPEO1W {
                _COMPEO1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Event Output Enable"]
            #[inline]
            pub fn wineo0(&mut self) -> _WINEO0W {
                _WINEO0W { w: self }
            }
            #[doc = "Bit 8 - Comparator 0 Event Input"]
            #[inline]
            pub fn compei0(&mut self) -> _COMPEI0W {
                _COMPEI0W { w: self }
            }
            #[doc = "Bit 9 - Comparator 1 Event Input"]
            #[inline]
            pub fn compei1(&mut self) -> _COMPEI1W {
                _COMPEI1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0 Interrupt Enable"]
            #[inline]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Enable"]
            #[inline]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0 Interrupt Enable"]
            #[inline]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP0R {
            bits: bool,
        }
        impl COMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMP1R {
            bits: bool,
        }
        impl COMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WIN0R {
            bits: bool,
        }
        impl WIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0"]
            #[inline]
            pub fn comp0(&self) -> COMP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1"]
            #[inline]
            pub fn comp1(&self) -> COMP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                COMP1R { bits }
            }
            #[doc = "Bit 4 - Window 0"]
            #[inline]
            pub fn win0(&self) -> WIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WIN0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 0"]
            #[inline]
            pub fn comp0(&mut self) -> _COMP0W {
                _COMP0W { w: self }
            }
            #[doc = "Bit 1 - Comparator 1"]
            #[inline]
            pub fn comp1(&mut self) -> _COMP1W {
                _COMP1W { w: self }
            }
            #[doc = "Bit 4 - Window 0"]
            #[inline]
            pub fn win0(&mut self) -> _WIN0W {
                _WIN0W { w: self }
            }
        }
    }
    #[doc = "Scaler n"]
    pub struct SCALER {
        register: VolatileCell<u8>,
    }
    #[doc = "Scaler n"]
    pub mod scaler {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SCALER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:5 - Scaler Value"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Scaler Value"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Status A"]
    pub struct STATUSA {
        register: VolatileCell<u8>,
    }
    #[doc = "Status A"]
    pub mod statusa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSA {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE0R {
            bits: bool,
        }
        impl STATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE1R {
            bits: bool,
        }
        impl STATE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WSTATE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WSTATE0R {
            #[doc = "Signal is above window"]
            ABOVE,
            #[doc = "Signal is inside window"]
            INSIDE,
            #[doc = "Signal is below window"]
            BELOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WSTATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WSTATE0R::ABOVE => 0,
                    WSTATE0R::INSIDE => 0x01,
                    WSTATE0R::BELOW => 0x02,
                    WSTATE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WSTATE0R {
                match value {
                    0 => WSTATE0R::ABOVE,
                    1 => WSTATE0R::INSIDE,
                    2 => WSTATE0R::BELOW,
                    i => WSTATE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline]
            pub fn is_above(&self) -> bool {
                *self == WSTATE0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline]
            pub fn is_inside(&self) -> bool {
                *self == WSTATE0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline]
            pub fn is_below(&self) -> bool {
                *self == WSTATE0R::BELOW
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Current State"]
            #[inline]
            pub fn state0(&self) -> STATE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Current State"]
            #[inline]
            pub fn state1(&self) -> STATE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE1R { bits }
            }
            #[doc = "Bits 4:5 - Window 0 Current State"]
            #[inline]
            pub fn wstate0(&self) -> WSTATE0R {
                WSTATE0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
    }
    #[doc = "Status B"]
    pub struct STATUSB {
        register: VolatileCell<u8>,
    }
    #[doc = "Status B"]
    pub mod statusb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSB {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct READY0R {
            bits: bool,
        }
        impl READY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct READY1R {
            bits: bool,
        }
        impl READY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Ready"]
            #[inline]
            pub fn ready0(&self) -> READY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READY0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Ready"]
            #[inline]
            pub fn ready1(&self) -> READY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READY1R { bits }
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Status C"]
    pub struct STATUSC {
        register: VolatileCell<u8>,
    }
    #[doc = "Status C"]
    pub mod statusc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSC {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE0R {
            bits: bool,
        }
        impl STATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE1R {
            bits: bool,
        }
        impl STATE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WSTATE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WSTATE0R {
            #[doc = "Signal is above window"]
            ABOVE,
            #[doc = "Signal is inside window"]
            INSIDE,
            #[doc = "Signal is below window"]
            BELOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WSTATE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WSTATE0R::ABOVE => 0,
                    WSTATE0R::INSIDE => 0x01,
                    WSTATE0R::BELOW => 0x02,
                    WSTATE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WSTATE0R {
                match value {
                    0 => WSTATE0R::ABOVE,
                    1 => WSTATE0R::INSIDE,
                    2 => WSTATE0R::BELOW,
                    i => WSTATE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline]
            pub fn is_above(&self) -> bool {
                *self == WSTATE0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline]
            pub fn is_inside(&self) -> bool {
                *self == WSTATE0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline]
            pub fn is_below(&self) -> bool {
                *self == WSTATE0R::BELOW
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 0 Current State"]
            #[inline]
            pub fn state0(&self) -> STATE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE0R { bits }
            }
            #[doc = "Bit 1 - Comparator 1 Current State"]
            #[inline]
            pub fn state1(&self) -> STATE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STATE1R { bits }
            }
            #[doc = "Bits 4:5 - Window 0 Current State"]
            #[inline]
            pub fn wstate0(&self) -> WSTATE0R {
                WSTATE0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
    }
    #[doc = "Window Control"]
    pub struct WINCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Window Control"]
    pub mod winctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::WINCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WEN0R {
            bits: bool,
        }
        impl WEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WINTSEL0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINTSEL0R {
            #[doc = "Interrupt on signal above window"]
            ABOVE,
            #[doc = "Interrupt on signal inside window"]
            INSIDE,
            #[doc = "Interrupt on signal below window"]
            BELOW,
            #[doc = "Interrupt on signal outside window"]
            OUTSIDE,
        }
        impl WINTSEL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINTSEL0R::ABOVE => 0,
                    WINTSEL0R::INSIDE => 0x01,
                    WINTSEL0R::BELOW => 0x02,
                    WINTSEL0R::OUTSIDE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WINTSEL0R {
                match value {
                    0 => WINTSEL0R::ABOVE,
                    1 => WINTSEL0R::INSIDE,
                    2 => WINTSEL0R::BELOW,
                    3 => WINTSEL0R::OUTSIDE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline]
            pub fn is_above(&self) -> bool {
                *self == WINTSEL0R::ABOVE
            }
            #[doc = "Checks if the value of the field is `INSIDE`"]
            #[inline]
            pub fn is_inside(&self) -> bool {
                *self == WINTSEL0R::INSIDE
            }
            #[doc = "Checks if the value of the field is `BELOW`"]
            #[inline]
            pub fn is_below(&self) -> bool {
                *self == WINTSEL0R::BELOW
            }
            #[doc = "Checks if the value of the field is `OUTSIDE`"]
            #[inline]
            pub fn is_outside(&self) -> bool {
                *self == WINTSEL0R::OUTSIDE
            }
        }
        #[doc = r" Proxy"]
        pub struct _WEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WINTSEL0`"]
        pub enum WINTSEL0W {
            #[doc = "Interrupt on signal above window"]
            ABOVE,
            #[doc = "Interrupt on signal inside window"]
            INSIDE,
            #[doc = "Interrupt on signal below window"]
            BELOW,
            #[doc = "Interrupt on signal outside window"]
            OUTSIDE,
        }
        impl WINTSEL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINTSEL0W::ABOVE => 0,
                    WINTSEL0W::INSIDE => 1,
                    WINTSEL0W::BELOW => 2,
                    WINTSEL0W::OUTSIDE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINTSEL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINTSEL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WINTSEL0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Interrupt on signal above window"]
            #[inline]
            pub fn above(self) -> &'a mut W {
                self.variant(WINTSEL0W::ABOVE)
            }
            #[doc = "Interrupt on signal inside window"]
            #[inline]
            pub fn inside(self) -> &'a mut W {
                self.variant(WINTSEL0W::INSIDE)
            }
            #[doc = "Interrupt on signal below window"]
            #[inline]
            pub fn below(self) -> &'a mut W {
                self.variant(WINTSEL0W::BELOW)
            }
            #[doc = "Interrupt on signal outside window"]
            #[inline]
            pub fn outside(self) -> &'a mut W {
                self.variant(WINTSEL0W::OUTSIDE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Window 0 Mode Enable"]
            #[inline]
            pub fn wen0(&self) -> WEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WEN0R { bits }
            }
            #[doc = "Bits 1:2 - Window 0 Interrupt Selection"]
            #[inline]
            pub fn wintsel0(&self) -> WINTSEL0R {
                WINTSEL0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Window 0 Mode Enable"]
            #[inline]
            pub fn wen0(&mut self) -> _WEN0W {
                _WEN0W { w: self }
            }
            #[doc = "Bits 1:2 - Window 0 Interrupt Selection"]
            #[inline]
            pub fn wintsel0(&mut self) -> _WINTSEL0W {
                _WINTSEL0W { w: self }
            }
        }
    }
}
#[doc = "Analog Comparators"]
pub struct AC {
    register_block: ac::RegisterBlock,
}
impl Deref for AC {
    type Target = ac::RegisterBlock;
    fn deref(&self) -> &ac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Analog Digital Converter"]
pub const ADC: Peripheral<ADC> = unsafe { Peripheral::new(0x4200_4000) };
#[doc = "Analog Digital Converter"]
pub mod adc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Reference Control"]
        pub refctrl: REFCTRL,
        #[doc = "0x02 - Average Control"]
        pub avgctrl: AVGCTRL,
        #[doc = "0x03 - Sampling Time Control"]
        pub sampctrl: SAMPCTRL,
        #[doc = "0x04 - Control B"]
        pub ctrlb: CTRLB,
        _reserved0: [u8; 2usize],
        #[doc = "0x08 - Window Monitor Control"]
        pub winctrl: WINCTRL,
        _reserved1: [u8; 3usize],
        #[doc = "0x0c - Software Trigger"]
        pub swtrig: SWTRIG,
        _reserved2: [u8; 3usize],
        #[doc = "0x10 - Inputs Control"]
        pub inputctrl: INPUTCTRL,
        #[doc = "0x14 - Event Control"]
        pub evctrl: EVCTRL,
        _reserved3: [u8; 1usize],
        #[doc = "0x16 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x17 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x18 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x19 - Status"]
        pub status: STATUS,
        #[doc = "0x1a - Result"]
        pub result: RESULT,
        #[doc = "0x1c - Window Monitor Lower Threshold"]
        pub winlt: WINLT,
        _reserved4: [u8; 2usize],
        #[doc = "0x20 - Window Monitor Upper Threshold"]
        pub winut: WINUT,
        _reserved5: [u8; 2usize],
        #[doc = "0x24 - Gain Correction"]
        pub gaincorr: GAINCORR,
        #[doc = "0x26 - Offset Correction"]
        pub offsetcorr: OFFSETCORR,
        #[doc = "0x28 - Calibration"]
        pub calib: CALIB,
        #[doc = "0x2a - Debug Control"]
        pub dbgctrl: DBGCTRL,
    }
    #[doc = "Average Control"]
    pub struct AVGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Average Control"]
    pub mod avgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::AVGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SAMPLENUM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLENUMR {
            #[doc = "1 sample"]
            _1,
            #[doc = "2 samples"]
            _2,
            #[doc = "4 samples"]
            _4,
            #[doc = "8 samples"]
            _8,
            #[doc = "16 samples"]
            _16,
            #[doc = "32 samples"]
            _32,
            #[doc = "64 samples"]
            _64,
            #[doc = "128 samples"]
            _128,
            #[doc = "256 samples"]
            _256,
            #[doc = "512 samples"]
            _512,
            #[doc = "1024 samples"]
            _1024,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SAMPLENUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SAMPLENUMR::_1 => 0,
                    SAMPLENUMR::_2 => 0x01,
                    SAMPLENUMR::_4 => 0x02,
                    SAMPLENUMR::_8 => 0x03,
                    SAMPLENUMR::_16 => 0x04,
                    SAMPLENUMR::_32 => 0x05,
                    SAMPLENUMR::_64 => 0x06,
                    SAMPLENUMR::_128 => 0x07,
                    SAMPLENUMR::_256 => 0x08,
                    SAMPLENUMR::_512 => 0x09,
                    SAMPLENUMR::_1024 => 0x0a,
                    SAMPLENUMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SAMPLENUMR {
                match value {
                    0 => SAMPLENUMR::_1,
                    1 => SAMPLENUMR::_2,
                    2 => SAMPLENUMR::_4,
                    3 => SAMPLENUMR::_8,
                    4 => SAMPLENUMR::_16,
                    5 => SAMPLENUMR::_32,
                    6 => SAMPLENUMR::_64,
                    7 => SAMPLENUMR::_128,
                    8 => SAMPLENUMR::_256,
                    9 => SAMPLENUMR::_512,
                    10 => SAMPLENUMR::_1024,
                    i => SAMPLENUMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline]
            pub fn is_1(&self) -> bool {
                *self == SAMPLENUMR::_1
            }
            #[doc = "Checks if the value of the field is `_2`"]
            #[inline]
            pub fn is_2(&self) -> bool {
                *self == SAMPLENUMR::_2
            }
            #[doc = "Checks if the value of the field is `_4`"]
            #[inline]
            pub fn is_4(&self) -> bool {
                *self == SAMPLENUMR::_4
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline]
            pub fn is_8(&self) -> bool {
                *self == SAMPLENUMR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline]
            pub fn is_16(&self) -> bool {
                *self == SAMPLENUMR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline]
            pub fn is_32(&self) -> bool {
                *self == SAMPLENUMR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline]
            pub fn is_64(&self) -> bool {
                *self == SAMPLENUMR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline]
            pub fn is_128(&self) -> bool {
                *self == SAMPLENUMR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline]
            pub fn is_256(&self) -> bool {
                *self == SAMPLENUMR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline]
            pub fn is_512(&self) -> bool {
                *self == SAMPLENUMR::_512
            }
            #[doc = "Checks if the value of the field is `_1024`"]
            #[inline]
            pub fn is_1024(&self) -> bool {
                *self == SAMPLENUMR::_1024
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADJRESR {
            bits: u8,
        }
        impl ADJRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SAMPLENUM`"]
        pub enum SAMPLENUMW {
            #[doc = "1 sample"]
            _1,
            #[doc = "2 samples"]
            _2,
            #[doc = "4 samples"]
            _4,
            #[doc = "8 samples"]
            _8,
            #[doc = "16 samples"]
            _16,
            #[doc = "32 samples"]
            _32,
            #[doc = "64 samples"]
            _64,
            #[doc = "128 samples"]
            _128,
            #[doc = "256 samples"]
            _256,
            #[doc = "512 samples"]
            _512,
            #[doc = "1024 samples"]
            _1024,
        }
        impl SAMPLENUMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SAMPLENUMW::_1 => 0,
                    SAMPLENUMW::_2 => 1,
                    SAMPLENUMW::_4 => 2,
                    SAMPLENUMW::_8 => 3,
                    SAMPLENUMW::_16 => 4,
                    SAMPLENUMW::_32 => 5,
                    SAMPLENUMW::_64 => 6,
                    SAMPLENUMW::_128 => 7,
                    SAMPLENUMW::_256 => 8,
                    SAMPLENUMW::_512 => 9,
                    SAMPLENUMW::_1024 => 10,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLENUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLENUMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SAMPLENUMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1 sample"]
            #[inline]
            pub fn _1(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_1)
            }
            #[doc = "2 samples"]
            #[inline]
            pub fn _2(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_2)
            }
            #[doc = "4 samples"]
            #[inline]
            pub fn _4(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_4)
            }
            #[doc = "8 samples"]
            #[inline]
            pub fn _8(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_8)
            }
            #[doc = "16 samples"]
            #[inline]
            pub fn _16(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_16)
            }
            #[doc = "32 samples"]
            #[inline]
            pub fn _32(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_32)
            }
            #[doc = "64 samples"]
            #[inline]
            pub fn _64(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_64)
            }
            #[doc = "128 samples"]
            #[inline]
            pub fn _128(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_128)
            }
            #[doc = "256 samples"]
            #[inline]
            pub fn _256(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_256)
            }
            #[doc = "512 samples"]
            #[inline]
            pub fn _512(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_512)
            }
            #[doc = "1024 samples"]
            #[inline]
            pub fn _1024(self) -> &'a mut W {
                self.variant(SAMPLENUMW::_1024)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADJRESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADJRESW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Number of Samples to be Collected"]
            #[inline]
            pub fn samplenum(&self) -> SAMPLENUMR {
                SAMPLENUMR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
            #[inline]
            pub fn adjres(&self) -> ADJRESR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                ADJRESR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Number of Samples to be Collected"]
            #[inline]
            pub fn samplenum(&mut self) -> _SAMPLENUMW {
                _SAMPLENUMW { w: self }
            }
            #[doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
            #[inline]
            pub fn adjres(&mut self) -> _ADJRESW {
                _ADJRESW { w: self }
            }
        }
    }
    #[doc = "Calibration"]
    pub struct CALIB {
        register: VolatileCell<u16>,
    }
    #[doc = "Calibration"]
    pub mod calib {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CALIB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINEARITY_CALR {
            bits: u8,
        }
        impl LINEARITY_CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIAS_CALR {
            bits: u8,
        }
        impl BIAS_CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINEARITY_CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINEARITY_CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIAS_CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIAS_CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:7 - Linearity Calibration Value"]
            #[inline]
            pub fn linearity_cal(&self) -> LINEARITY_CALR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LINEARITY_CALR { bits }
            }
            #[doc = "Bits 8:10 - Bias Calibration Value"]
            #[inline]
            pub fn bias_cal(&self) -> BIAS_CALR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                BIAS_CALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Linearity Calibration Value"]
            #[inline]
            pub fn linearity_cal(&mut self) -> _LINEARITY_CALW {
                _LINEARITY_CALW { w: self }
            }
            #[doc = "Bits 8:10 - Bias Calibration Value"]
            #[inline]
            pub fn bias_cal(&mut self) -> _BIAS_CALW {
                _BIAS_CALW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u16>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIFFMODER {
            bits: bool,
        }
        impl DIFFMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEFTADJR {
            bits: bool,
        }
        impl LEFTADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FREERUNR {
            bits: bool,
        }
        impl FREERUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CORRENR {
            bits: bool,
        }
        impl CORRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `RESSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESSELR {
            #[doc = "12-bit result"]
            _12BIT,
            #[doc = "For averaging mode output"]
            _16BIT,
            #[doc = "10-bit result"]
            _10BIT,
            #[doc = "8-bit result"]
            _8BIT,
        }
        impl RESSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RESSELR::_12BIT => 0,
                    RESSELR::_16BIT => 0x01,
                    RESSELR::_10BIT => 0x02,
                    RESSELR::_8BIT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RESSELR {
                match value {
                    0 => RESSELR::_12BIT,
                    1 => RESSELR::_16BIT,
                    2 => RESSELR::_10BIT,
                    3 => RESSELR::_8BIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_12BIT`"]
            #[inline]
            pub fn is_12bit(&self) -> bool {
                *self == RESSELR::_12BIT
            }
            #[doc = "Checks if the value of the field is `_16BIT`"]
            #[inline]
            pub fn is_16bit(&self) -> bool {
                *self == RESSELR::_16BIT
            }
            #[doc = "Checks if the value of the field is `_10BIT`"]
            #[inline]
            pub fn is_10bit(&self) -> bool {
                *self == RESSELR::_10BIT
            }
            #[doc = "Checks if the value of the field is `_8BIT`"]
            #[inline]
            pub fn is_8bit(&self) -> bool {
                *self == RESSELR::_8BIT
            }
        }
        #[doc = "Possible values of the field `PRESCALER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCALERR {
            #[doc = "Peripheral clock divided by 4"]
            DIV4,
            #[doc = "Peripheral clock divided by 8"]
            DIV8,
            #[doc = "Peripheral clock divided by 16"]
            DIV16,
            #[doc = "Peripheral clock divided by 32"]
            DIV32,
            #[doc = "Peripheral clock divided by 64"]
            DIV64,
            #[doc = "Peripheral clock divided by 128"]
            DIV128,
            #[doc = "Peripheral clock divided by 256"]
            DIV256,
            #[doc = "Peripheral clock divided by 512"]
            DIV512,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCALERR::DIV4 => 0,
                    PRESCALERR::DIV8 => 0x01,
                    PRESCALERR::DIV16 => 0x02,
                    PRESCALERR::DIV32 => 0x03,
                    PRESCALERR::DIV64 => 0x04,
                    PRESCALERR::DIV128 => 0x05,
                    PRESCALERR::DIV256 => 0x06,
                    PRESCALERR::DIV512 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PRESCALERR {
                match value {
                    0 => PRESCALERR::DIV4,
                    1 => PRESCALERR::DIV8,
                    2 => PRESCALERR::DIV16,
                    3 => PRESCALERR::DIV32,
                    4 => PRESCALERR::DIV64,
                    5 => PRESCALERR::DIV128,
                    6 => PRESCALERR::DIV256,
                    7 => PRESCALERR::DIV512,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == PRESCALERR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == PRESCALERR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == PRESCALERR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline]
            pub fn is_div32(&self) -> bool {
                *self == PRESCALERR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == PRESCALERR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == PRESCALERR::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline]
            pub fn is_div256(&self) -> bool {
                *self == PRESCALERR::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline]
            pub fn is_div512(&self) -> bool {
                *self == PRESCALERR::DIV512
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIFFMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIFFMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEFTADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEFTADJW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREERUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREERUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CORRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CORRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESSEL`"]
        pub enum RESSELW {
            #[doc = "12-bit result"]
            _12BIT,
            #[doc = "For averaging mode output"]
            _16BIT,
            #[doc = "10-bit result"]
            _10BIT,
            #[doc = "8-bit result"]
            _8BIT,
        }
        impl RESSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RESSELW::_12BIT => 0,
                    RESSELW::_16BIT => 1,
                    RESSELW::_10BIT => 2,
                    RESSELW::_8BIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "12-bit result"]
            #[inline]
            pub fn _12bit(self) -> &'a mut W {
                self.variant(RESSELW::_12BIT)
            }
            #[doc = "For averaging mode output"]
            #[inline]
            pub fn _16bit(self) -> &'a mut W {
                self.variant(RESSELW::_16BIT)
            }
            #[doc = "10-bit result"]
            #[inline]
            pub fn _10bit(self) -> &'a mut W {
                self.variant(RESSELW::_10BIT)
            }
            #[doc = "8-bit result"]
            #[inline]
            pub fn _8bit(self) -> &'a mut W {
                self.variant(RESSELW::_8BIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCALER`"]
        pub enum PRESCALERW {
            #[doc = "Peripheral clock divided by 4"]
            DIV4,
            #[doc = "Peripheral clock divided by 8"]
            DIV8,
            #[doc = "Peripheral clock divided by 16"]
            DIV16,
            #[doc = "Peripheral clock divided by 32"]
            DIV32,
            #[doc = "Peripheral clock divided by 64"]
            DIV64,
            #[doc = "Peripheral clock divided by 128"]
            DIV128,
            #[doc = "Peripheral clock divided by 256"]
            DIV256,
            #[doc = "Peripheral clock divided by 512"]
            DIV512,
        }
        impl PRESCALERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCALERW::DIV4 => 0,
                    PRESCALERW::DIV8 => 1,
                    PRESCALERW::DIV16 => 2,
                    PRESCALERW::DIV32 => 3,
                    PRESCALERW::DIV64 => 4,
                    PRESCALERW::DIV128 => 5,
                    PRESCALERW::DIV256 => 6,
                    PRESCALERW::DIV512 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PRESCALERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Peripheral clock divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV4)
            }
            #[doc = "Peripheral clock divided by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV8)
            }
            #[doc = "Peripheral clock divided by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV16)
            }
            #[doc = "Peripheral clock divided by 32"]
            #[inline]
            pub fn div32(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV32)
            }
            #[doc = "Peripheral clock divided by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV64)
            }
            #[doc = "Peripheral clock divided by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV128)
            }
            #[doc = "Peripheral clock divided by 256"]
            #[inline]
            pub fn div256(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV256)
            }
            #[doc = "Peripheral clock divided by 512"]
            #[inline]
            pub fn div512(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV512)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Differential Mode"]
            #[inline]
            pub fn diffmode(&self) -> DIFFMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                DIFFMODER { bits }
            }
            #[doc = "Bit 1 - Left Adjusted Result"]
            #[inline]
            pub fn leftadj(&self) -> LEFTADJR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LEFTADJR { bits }
            }
            #[doc = "Bit 2 - Free Running Mode"]
            #[inline]
            pub fn freerun(&self) -> FREERUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                FREERUNR { bits }
            }
            #[doc = "Bit 3 - Digital Correction Logic Enabled"]
            #[inline]
            pub fn corren(&self) -> CORRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CORRENR { bits }
            }
            #[doc = "Bits 4:5 - Conversion Result Resolution"]
            #[inline]
            pub fn ressel(&self) -> RESSELR {
                RESSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:10 - Prescaler Configuration"]
            #[inline]
            pub fn prescaler(&self) -> PRESCALERR {
                PRESCALERR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Differential Mode"]
            #[inline]
            pub fn diffmode(&mut self) -> _DIFFMODEW {
                _DIFFMODEW { w: self }
            }
            #[doc = "Bit 1 - Left Adjusted Result"]
            #[inline]
            pub fn leftadj(&mut self) -> _LEFTADJW {
                _LEFTADJW { w: self }
            }
            #[doc = "Bit 2 - Free Running Mode"]
            #[inline]
            pub fn freerun(&mut self) -> _FREERUNW {
                _FREERUNW { w: self }
            }
            #[doc = "Bit 3 - Digital Correction Logic Enabled"]
            #[inline]
            pub fn corren(&mut self) -> _CORRENW {
                _CORRENW { w: self }
            }
            #[doc = "Bits 4:5 - Conversion Result Resolution"]
            #[inline]
            pub fn ressel(&mut self) -> _RESSELW {
                _RESSELW { w: self }
            }
            #[doc = "Bits 8:10 - Prescaler Configuration"]
            #[inline]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
        }
    }
    #[doc = "Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGRUNR {
            bits: bool,
        }
        impl DBGRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline]
            pub fn dbgrun(&self) -> DBGRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGRUNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Run"]
            #[inline]
            pub fn dbgrun(&mut self) -> _DBGRUNW {
                _DBGRUNW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTEIR {
            bits: bool,
        }
        impl STARTEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCEIR {
            bits: bool,
        }
        impl SYNCEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYEOR {
            bits: bool,
        }
        impl RESRDYEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONEOR {
            bits: bool,
        }
        impl WINMONEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Start Conversion Event In"]
            #[inline]
            pub fn startei(&self) -> STARTEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTEIR { bits }
            }
            #[doc = "Bit 1 - Synchronization Event In"]
            #[inline]
            pub fn syncei(&self) -> SYNCEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCEIR { bits }
            }
            #[doc = "Bit 4 - Result Ready Event Out"]
            #[inline]
            pub fn resrdyeo(&self) -> RESRDYEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYEOR { bits }
            }
            #[doc = "Bit 5 - Window Monitor Event Out"]
            #[inline]
            pub fn winmoneo(&self) -> WINMONEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONEOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start Conversion Event In"]
            #[inline]
            pub fn startei(&mut self) -> _STARTEIW {
                _STARTEIW { w: self }
            }
            #[doc = "Bit 1 - Synchronization Event In"]
            #[inline]
            pub fn syncei(&mut self) -> _SYNCEIW {
                _SYNCEIW { w: self }
            }
            #[doc = "Bit 4 - Result Ready Event Out"]
            #[inline]
            pub fn resrdyeo(&mut self) -> _RESRDYEOW {
                _RESRDYEOW { w: self }
            }
            #[doc = "Bit 5 - Window Monitor Event Out"]
            #[inline]
            pub fn winmoneo(&mut self) -> _WINMONEOW {
                _WINMONEOW { w: self }
            }
        }
    }
    #[doc = "Gain Correction"]
    pub struct GAINCORR {
        register: VolatileCell<u16>,
    }
    #[doc = "Gain Correction"]
    pub mod gaincorr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::GAINCORR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GAINCORRR {
            bits: u16,
        }
        impl GAINCORRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINCORRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINCORRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:11 - Gain Correction Value"]
            #[inline]
            pub fn gaincorr(&self) -> GAINCORRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                GAINCORRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Gain Correction Value"]
            #[inline]
            pub fn gaincorr(&mut self) -> _GAINCORRW {
                _GAINCORRW { w: self }
            }
        }
    }
    #[doc = "Inputs Control"]
    pub struct INPUTCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Inputs Control"]
    pub mod inputctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INPUTCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MUXPOS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXPOSR {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "ADC AIN8 Pin"]
            PIN8,
            #[doc = "ADC AIN9 Pin"]
            PIN9,
            #[doc = "ADC AIN10 Pin"]
            PIN10,
            #[doc = "ADC AIN11 Pin"]
            PIN11,
            #[doc = "ADC AIN12 Pin"]
            PIN12,
            #[doc = "ADC AIN13 Pin"]
            PIN13,
            #[doc = "ADC AIN14 Pin"]
            PIN14,
            #[doc = "ADC AIN15 Pin"]
            PIN15,
            #[doc = "ADC AIN16 Pin"]
            PIN16,
            #[doc = "ADC AIN17 Pin"]
            PIN17,
            #[doc = "ADC AIN18 Pin"]
            PIN18,
            #[doc = "ADC AIN19 Pin"]
            PIN19,
            #[doc = "Temperature Reference"]
            TEMP,
            #[doc = "Bandgap Voltage"]
            BANDGAP,
            #[doc = "1/4  Scaled Core Supply"]
            SCALEDCOREVCC,
            #[doc = "1/4  Scaled I/O Supply"]
            SCALEDIOVCC,
            #[doc = "DAC Output"]
            DAC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MUXPOSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXPOSR::PIN0 => 0,
                    MUXPOSR::PIN1 => 0x01,
                    MUXPOSR::PIN2 => 0x02,
                    MUXPOSR::PIN3 => 0x03,
                    MUXPOSR::PIN4 => 0x04,
                    MUXPOSR::PIN5 => 0x05,
                    MUXPOSR::PIN6 => 0x06,
                    MUXPOSR::PIN7 => 0x07,
                    MUXPOSR::PIN8 => 0x08,
                    MUXPOSR::PIN9 => 0x09,
                    MUXPOSR::PIN10 => 0x0a,
                    MUXPOSR::PIN11 => 0x0b,
                    MUXPOSR::PIN12 => 0x0c,
                    MUXPOSR::PIN13 => 0x0d,
                    MUXPOSR::PIN14 => 0x0e,
                    MUXPOSR::PIN15 => 0x0f,
                    MUXPOSR::PIN16 => 0x10,
                    MUXPOSR::PIN17 => 0x11,
                    MUXPOSR::PIN18 => 0x12,
                    MUXPOSR::PIN19 => 0x13,
                    MUXPOSR::TEMP => 0x18,
                    MUXPOSR::BANDGAP => 0x19,
                    MUXPOSR::SCALEDCOREVCC => 0x1a,
                    MUXPOSR::SCALEDIOVCC => 0x1b,
                    MUXPOSR::DAC => 0x1c,
                    MUXPOSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MUXPOSR {
                match value {
                    0 => MUXPOSR::PIN0,
                    1 => MUXPOSR::PIN1,
                    2 => MUXPOSR::PIN2,
                    3 => MUXPOSR::PIN3,
                    4 => MUXPOSR::PIN4,
                    5 => MUXPOSR::PIN5,
                    6 => MUXPOSR::PIN6,
                    7 => MUXPOSR::PIN7,
                    8 => MUXPOSR::PIN8,
                    9 => MUXPOSR::PIN9,
                    10 => MUXPOSR::PIN10,
                    11 => MUXPOSR::PIN11,
                    12 => MUXPOSR::PIN12,
                    13 => MUXPOSR::PIN13,
                    14 => MUXPOSR::PIN14,
                    15 => MUXPOSR::PIN15,
                    16 => MUXPOSR::PIN16,
                    17 => MUXPOSR::PIN17,
                    18 => MUXPOSR::PIN18,
                    19 => MUXPOSR::PIN19,
                    24 => MUXPOSR::TEMP,
                    25 => MUXPOSR::BANDGAP,
                    26 => MUXPOSR::SCALEDCOREVCC,
                    27 => MUXPOSR::SCALEDIOVCC,
                    28 => MUXPOSR::DAC,
                    i => MUXPOSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline]
            pub fn is_pin0(&self) -> bool {
                *self == MUXPOSR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline]
            pub fn is_pin1(&self) -> bool {
                *self == MUXPOSR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline]
            pub fn is_pin2(&self) -> bool {
                *self == MUXPOSR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline]
            pub fn is_pin3(&self) -> bool {
                *self == MUXPOSR::PIN3
            }
            #[doc = "Checks if the value of the field is `PIN4`"]
            #[inline]
            pub fn is_pin4(&self) -> bool {
                *self == MUXPOSR::PIN4
            }
            #[doc = "Checks if the value of the field is `PIN5`"]
            #[inline]
            pub fn is_pin5(&self) -> bool {
                *self == MUXPOSR::PIN5
            }
            #[doc = "Checks if the value of the field is `PIN6`"]
            #[inline]
            pub fn is_pin6(&self) -> bool {
                *self == MUXPOSR::PIN6
            }
            #[doc = "Checks if the value of the field is `PIN7`"]
            #[inline]
            pub fn is_pin7(&self) -> bool {
                *self == MUXPOSR::PIN7
            }
            #[doc = "Checks if the value of the field is `PIN8`"]
            #[inline]
            pub fn is_pin8(&self) -> bool {
                *self == MUXPOSR::PIN8
            }
            #[doc = "Checks if the value of the field is `PIN9`"]
            #[inline]
            pub fn is_pin9(&self) -> bool {
                *self == MUXPOSR::PIN9
            }
            #[doc = "Checks if the value of the field is `PIN10`"]
            #[inline]
            pub fn is_pin10(&self) -> bool {
                *self == MUXPOSR::PIN10
            }
            #[doc = "Checks if the value of the field is `PIN11`"]
            #[inline]
            pub fn is_pin11(&self) -> bool {
                *self == MUXPOSR::PIN11
            }
            #[doc = "Checks if the value of the field is `PIN12`"]
            #[inline]
            pub fn is_pin12(&self) -> bool {
                *self == MUXPOSR::PIN12
            }
            #[doc = "Checks if the value of the field is `PIN13`"]
            #[inline]
            pub fn is_pin13(&self) -> bool {
                *self == MUXPOSR::PIN13
            }
            #[doc = "Checks if the value of the field is `PIN14`"]
            #[inline]
            pub fn is_pin14(&self) -> bool {
                *self == MUXPOSR::PIN14
            }
            #[doc = "Checks if the value of the field is `PIN15`"]
            #[inline]
            pub fn is_pin15(&self) -> bool {
                *self == MUXPOSR::PIN15
            }
            #[doc = "Checks if the value of the field is `PIN16`"]
            #[inline]
            pub fn is_pin16(&self) -> bool {
                *self == MUXPOSR::PIN16
            }
            #[doc = "Checks if the value of the field is `PIN17`"]
            #[inline]
            pub fn is_pin17(&self) -> bool {
                *self == MUXPOSR::PIN17
            }
            #[doc = "Checks if the value of the field is `PIN18`"]
            #[inline]
            pub fn is_pin18(&self) -> bool {
                *self == MUXPOSR::PIN18
            }
            #[doc = "Checks if the value of the field is `PIN19`"]
            #[inline]
            pub fn is_pin19(&self) -> bool {
                *self == MUXPOSR::PIN19
            }
            #[doc = "Checks if the value of the field is `TEMP`"]
            #[inline]
            pub fn is_temp(&self) -> bool {
                *self == MUXPOSR::TEMP
            }
            #[doc = "Checks if the value of the field is `BANDGAP`"]
            #[inline]
            pub fn is_bandgap(&self) -> bool {
                *self == MUXPOSR::BANDGAP
            }
            #[doc = "Checks if the value of the field is `SCALEDCOREVCC`"]
            #[inline]
            pub fn is_scaledcorevcc(&self) -> bool {
                *self == MUXPOSR::SCALEDCOREVCC
            }
            #[doc = "Checks if the value of the field is `SCALEDIOVCC`"]
            #[inline]
            pub fn is_scalediovcc(&self) -> bool {
                *self == MUXPOSR::SCALEDIOVCC
            }
            #[doc = "Checks if the value of the field is `DAC`"]
            #[inline]
            pub fn is_dac(&self) -> bool {
                *self == MUXPOSR::DAC
            }
        }
        #[doc = "Possible values of the field `MUXNEG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXNEGR {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "Internal ground"]
            GND,
            #[doc = "IO ground"]
            IOGND,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MUXNEGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MUXNEGR::PIN0 => 0,
                    MUXNEGR::PIN1 => 0x01,
                    MUXNEGR::PIN2 => 0x02,
                    MUXNEGR::PIN3 => 0x03,
                    MUXNEGR::PIN4 => 0x04,
                    MUXNEGR::PIN5 => 0x05,
                    MUXNEGR::PIN6 => 0x06,
                    MUXNEGR::PIN7 => 0x07,
                    MUXNEGR::GND => 0x18,
                    MUXNEGR::IOGND => 0x19,
                    MUXNEGR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MUXNEGR {
                match value {
                    0 => MUXNEGR::PIN0,
                    1 => MUXNEGR::PIN1,
                    2 => MUXNEGR::PIN2,
                    3 => MUXNEGR::PIN3,
                    4 => MUXNEGR::PIN4,
                    5 => MUXNEGR::PIN5,
                    6 => MUXNEGR::PIN6,
                    7 => MUXNEGR::PIN7,
                    24 => MUXNEGR::GND,
                    25 => MUXNEGR::IOGND,
                    i => MUXNEGR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIN0`"]
            #[inline]
            pub fn is_pin0(&self) -> bool {
                *self == MUXNEGR::PIN0
            }
            #[doc = "Checks if the value of the field is `PIN1`"]
            #[inline]
            pub fn is_pin1(&self) -> bool {
                *self == MUXNEGR::PIN1
            }
            #[doc = "Checks if the value of the field is `PIN2`"]
            #[inline]
            pub fn is_pin2(&self) -> bool {
                *self == MUXNEGR::PIN2
            }
            #[doc = "Checks if the value of the field is `PIN3`"]
            #[inline]
            pub fn is_pin3(&self) -> bool {
                *self == MUXNEGR::PIN3
            }
            #[doc = "Checks if the value of the field is `PIN4`"]
            #[inline]
            pub fn is_pin4(&self) -> bool {
                *self == MUXNEGR::PIN4
            }
            #[doc = "Checks if the value of the field is `PIN5`"]
            #[inline]
            pub fn is_pin5(&self) -> bool {
                *self == MUXNEGR::PIN5
            }
            #[doc = "Checks if the value of the field is `PIN6`"]
            #[inline]
            pub fn is_pin6(&self) -> bool {
                *self == MUXNEGR::PIN6
            }
            #[doc = "Checks if the value of the field is `PIN7`"]
            #[inline]
            pub fn is_pin7(&self) -> bool {
                *self == MUXNEGR::PIN7
            }
            #[doc = "Checks if the value of the field is `GND`"]
            #[inline]
            pub fn is_gnd(&self) -> bool {
                *self == MUXNEGR::GND
            }
            #[doc = "Checks if the value of the field is `IOGND`"]
            #[inline]
            pub fn is_iognd(&self) -> bool {
                *self == MUXNEGR::IOGND
            }
        }
        #[doc = r" Value of the field"]
        pub struct INPUTSCANR {
            bits: u8,
        }
        impl INPUTSCANR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct INPUTOFFSETR {
            bits: u8,
        }
        impl INPUTOFFSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `GAIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GAINR {
            #[doc = "1x"]
            _1X,
            #[doc = "2x"]
            _2X,
            #[doc = "4x"]
            _4X,
            #[doc = "8x"]
            _8X,
            #[doc = "16x"]
            _16X,
            #[doc = "1/2x"]
            DIV2,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    GAINR::_1X => 0,
                    GAINR::_2X => 0x01,
                    GAINR::_4X => 0x02,
                    GAINR::_8X => 0x03,
                    GAINR::_16X => 0x04,
                    GAINR::DIV2 => 0x0f,
                    GAINR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> GAINR {
                match value {
                    0 => GAINR::_1X,
                    1 => GAINR::_2X,
                    2 => GAINR::_4X,
                    3 => GAINR::_8X,
                    4 => GAINR::_16X,
                    15 => GAINR::DIV2,
                    i => GAINR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_1X`"]
            #[inline]
            pub fn is_1x(&self) -> bool {
                *self == GAINR::_1X
            }
            #[doc = "Checks if the value of the field is `_2X`"]
            #[inline]
            pub fn is_2x(&self) -> bool {
                *self == GAINR::_2X
            }
            #[doc = "Checks if the value of the field is `_4X`"]
            #[inline]
            pub fn is_4x(&self) -> bool {
                *self == GAINR::_4X
            }
            #[doc = "Checks if the value of the field is `_8X`"]
            #[inline]
            pub fn is_8x(&self) -> bool {
                *self == GAINR::_8X
            }
            #[doc = "Checks if the value of the field is `_16X`"]
            #[inline]
            pub fn is_16x(&self) -> bool {
                *self == GAINR::_16X
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == GAINR::DIV2
            }
        }
        #[doc = "Values that can be written to the field `MUXPOS`"]
        pub enum MUXPOSW {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "ADC AIN8 Pin"]
            PIN8,
            #[doc = "ADC AIN9 Pin"]
            PIN9,
            #[doc = "ADC AIN10 Pin"]
            PIN10,
            #[doc = "ADC AIN11 Pin"]
            PIN11,
            #[doc = "ADC AIN12 Pin"]
            PIN12,
            #[doc = "ADC AIN13 Pin"]
            PIN13,
            #[doc = "ADC AIN14 Pin"]
            PIN14,
            #[doc = "ADC AIN15 Pin"]
            PIN15,
            #[doc = "ADC AIN16 Pin"]
            PIN16,
            #[doc = "ADC AIN17 Pin"]
            PIN17,
            #[doc = "ADC AIN18 Pin"]
            PIN18,
            #[doc = "ADC AIN19 Pin"]
            PIN19,
            #[doc = "Temperature Reference"]
            TEMP,
            #[doc = "Bandgap Voltage"]
            BANDGAP,
            #[doc = "1/4  Scaled Core Supply"]
            SCALEDCOREVCC,
            #[doc = "1/4  Scaled I/O Supply"]
            SCALEDIOVCC,
            #[doc = "DAC Output"]
            DAC,
        }
        impl MUXPOSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXPOSW::PIN0 => 0,
                    MUXPOSW::PIN1 => 1,
                    MUXPOSW::PIN2 => 2,
                    MUXPOSW::PIN3 => 3,
                    MUXPOSW::PIN4 => 4,
                    MUXPOSW::PIN5 => 5,
                    MUXPOSW::PIN6 => 6,
                    MUXPOSW::PIN7 => 7,
                    MUXPOSW::PIN8 => 8,
                    MUXPOSW::PIN9 => 9,
                    MUXPOSW::PIN10 => 10,
                    MUXPOSW::PIN11 => 11,
                    MUXPOSW::PIN12 => 12,
                    MUXPOSW::PIN13 => 13,
                    MUXPOSW::PIN14 => 14,
                    MUXPOSW::PIN15 => 15,
                    MUXPOSW::PIN16 => 16,
                    MUXPOSW::PIN17 => 17,
                    MUXPOSW::PIN18 => 18,
                    MUXPOSW::PIN19 => 19,
                    MUXPOSW::TEMP => 24,
                    MUXPOSW::BANDGAP => 25,
                    MUXPOSW::SCALEDCOREVCC => 26,
                    MUXPOSW::SCALEDIOVCC => 27,
                    MUXPOSW::DAC => 28,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXPOSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXPOSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MUXPOSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC AIN0 Pin"]
            #[inline]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN0)
            }
            #[doc = "ADC AIN1 Pin"]
            #[inline]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN1)
            }
            #[doc = "ADC AIN2 Pin"]
            #[inline]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN2)
            }
            #[doc = "ADC AIN3 Pin"]
            #[inline]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN3)
            }
            #[doc = "ADC AIN4 Pin"]
            #[inline]
            pub fn pin4(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN4)
            }
            #[doc = "ADC AIN5 Pin"]
            #[inline]
            pub fn pin5(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN5)
            }
            #[doc = "ADC AIN6 Pin"]
            #[inline]
            pub fn pin6(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN6)
            }
            #[doc = "ADC AIN7 Pin"]
            #[inline]
            pub fn pin7(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN7)
            }
            #[doc = "ADC AIN8 Pin"]
            #[inline]
            pub fn pin8(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN8)
            }
            #[doc = "ADC AIN9 Pin"]
            #[inline]
            pub fn pin9(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN9)
            }
            #[doc = "ADC AIN10 Pin"]
            #[inline]
            pub fn pin10(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN10)
            }
            #[doc = "ADC AIN11 Pin"]
            #[inline]
            pub fn pin11(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN11)
            }
            #[doc = "ADC AIN12 Pin"]
            #[inline]
            pub fn pin12(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN12)
            }
            #[doc = "ADC AIN13 Pin"]
            #[inline]
            pub fn pin13(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN13)
            }
            #[doc = "ADC AIN14 Pin"]
            #[inline]
            pub fn pin14(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN14)
            }
            #[doc = "ADC AIN15 Pin"]
            #[inline]
            pub fn pin15(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN15)
            }
            #[doc = "ADC AIN16 Pin"]
            #[inline]
            pub fn pin16(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN16)
            }
            #[doc = "ADC AIN17 Pin"]
            #[inline]
            pub fn pin17(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN17)
            }
            #[doc = "ADC AIN18 Pin"]
            #[inline]
            pub fn pin18(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN18)
            }
            #[doc = "ADC AIN19 Pin"]
            #[inline]
            pub fn pin19(self) -> &'a mut W {
                self.variant(MUXPOSW::PIN19)
            }
            #[doc = "Temperature Reference"]
            #[inline]
            pub fn temp(self) -> &'a mut W {
                self.variant(MUXPOSW::TEMP)
            }
            #[doc = "Bandgap Voltage"]
            #[inline]
            pub fn bandgap(self) -> &'a mut W {
                self.variant(MUXPOSW::BANDGAP)
            }
            #[doc = "1/4 Scaled Core Supply"]
            #[inline]
            pub fn scaledcorevcc(self) -> &'a mut W {
                self.variant(MUXPOSW::SCALEDCOREVCC)
            }
            #[doc = "1/4 Scaled I/O Supply"]
            #[inline]
            pub fn scalediovcc(self) -> &'a mut W {
                self.variant(MUXPOSW::SCALEDIOVCC)
            }
            #[doc = "DAC Output"]
            #[inline]
            pub fn dac(self) -> &'a mut W {
                self.variant(MUXPOSW::DAC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MUXNEG`"]
        pub enum MUXNEGW {
            #[doc = "ADC AIN0 Pin"]
            PIN0,
            #[doc = "ADC AIN1 Pin"]
            PIN1,
            #[doc = "ADC AIN2 Pin"]
            PIN2,
            #[doc = "ADC AIN3 Pin"]
            PIN3,
            #[doc = "ADC AIN4 Pin"]
            PIN4,
            #[doc = "ADC AIN5 Pin"]
            PIN5,
            #[doc = "ADC AIN6 Pin"]
            PIN6,
            #[doc = "ADC AIN7 Pin"]
            PIN7,
            #[doc = "Internal ground"]
            GND,
            #[doc = "IO ground"]
            IOGND,
        }
        impl MUXNEGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MUXNEGW::PIN0 => 0,
                    MUXNEGW::PIN1 => 1,
                    MUXNEGW::PIN2 => 2,
                    MUXNEGW::PIN3 => 3,
                    MUXNEGW::PIN4 => 4,
                    MUXNEGW::PIN5 => 5,
                    MUXNEGW::PIN6 => 6,
                    MUXNEGW::PIN7 => 7,
                    MUXNEGW::GND => 24,
                    MUXNEGW::IOGND => 25,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXNEGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXNEGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MUXNEGW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC AIN0 Pin"]
            #[inline]
            pub fn pin0(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN0)
            }
            #[doc = "ADC AIN1 Pin"]
            #[inline]
            pub fn pin1(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN1)
            }
            #[doc = "ADC AIN2 Pin"]
            #[inline]
            pub fn pin2(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN2)
            }
            #[doc = "ADC AIN3 Pin"]
            #[inline]
            pub fn pin3(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN3)
            }
            #[doc = "ADC AIN4 Pin"]
            #[inline]
            pub fn pin4(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN4)
            }
            #[doc = "ADC AIN5 Pin"]
            #[inline]
            pub fn pin5(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN5)
            }
            #[doc = "ADC AIN6 Pin"]
            #[inline]
            pub fn pin6(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN6)
            }
            #[doc = "ADC AIN7 Pin"]
            #[inline]
            pub fn pin7(self) -> &'a mut W {
                self.variant(MUXNEGW::PIN7)
            }
            #[doc = "Internal ground"]
            #[inline]
            pub fn gnd(self) -> &'a mut W {
                self.variant(MUXNEGW::GND)
            }
            #[doc = "IO ground"]
            #[inline]
            pub fn iognd(self) -> &'a mut W {
                self.variant(MUXNEGW::IOGND)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUTSCANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUTSCANW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUTOFFSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUTOFFSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GAIN`"]
        pub enum GAINW {
            #[doc = "1x"]
            _1X,
            #[doc = "2x"]
            _2X,
            #[doc = "4x"]
            _4X,
            #[doc = "8x"]
            _8X,
            #[doc = "16x"]
            _16X,
            #[doc = "1/2x"]
            DIV2,
        }
        impl GAINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GAINW::_1X => 0,
                    GAINW::_2X => 1,
                    GAINW::_4X => 2,
                    GAINW::_8X => 3,
                    GAINW::_16X => 4,
                    GAINW::DIV2 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GAINW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1x"]
            #[inline]
            pub fn _1x(self) -> &'a mut W {
                self.variant(GAINW::_1X)
            }
            #[doc = "2x"]
            #[inline]
            pub fn _2x(self) -> &'a mut W {
                self.variant(GAINW::_2X)
            }
            #[doc = "4x"]
            #[inline]
            pub fn _4x(self) -> &'a mut W {
                self.variant(GAINW::_4X)
            }
            #[doc = "8x"]
            #[inline]
            pub fn _8x(self) -> &'a mut W {
                self.variant(GAINW::_8X)
            }
            #[doc = "16x"]
            #[inline]
            pub fn _16x(self) -> &'a mut W {
                self.variant(GAINW::_16X)
            }
            #[doc = "1/2x"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(GAINW::DIV2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Positive MUX Input Selection"]
            #[inline]
            pub fn muxpos(&self) -> MUXPOSR {
                MUXPOSR::_from({
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:12 - Negative MUX Input Selection"]
            #[inline]
            pub fn muxneg(&self) -> MUXNEGR {
                MUXNEGR::_from({
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
            #[inline]
            pub fn inputscan(&self) -> INPUTSCANR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INPUTSCANR { bits }
            }
            #[doc = "Bits 20:23 - Positive MUX Setting Offset"]
            #[inline]
            pub fn inputoffset(&self) -> INPUTOFFSETR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INPUTOFFSETR { bits }
            }
            #[doc = "Bits 24:27 - Gain Factor Selection"]
            #[inline]
            pub fn gain(&self) -> GAINR {
                GAINR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Positive MUX Input Selection"]
            #[inline]
            pub fn muxpos(&mut self) -> _MUXPOSW {
                _MUXPOSW { w: self }
            }
            #[doc = "Bits 8:12 - Negative MUX Input Selection"]
            #[inline]
            pub fn muxneg(&mut self) -> _MUXNEGW {
                _MUXNEGW { w: self }
            }
            #[doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
            #[inline]
            pub fn inputscan(&mut self) -> _INPUTSCANW {
                _INPUTSCANW { w: self }
            }
            #[doc = "Bits 20:23 - Positive MUX Setting Offset"]
            #[inline]
            pub fn inputoffset(&mut self) -> _INPUTOFFSETW {
                _INPUTOFFSETW { w: self }
            }
            #[doc = "Bits 24:27 - Gain Factor Selection"]
            #[inline]
            pub fn gain(&mut self) -> _GAINW {
                _GAINW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready Interrupt Enable"]
            #[inline]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun Interrupt Enable"]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor Interrupt Enable"]
            #[inline]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESRDYR {
            bits: bool,
        }
        impl RESRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINMONR {
            bits: bool,
        }
        impl WINMONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Result Ready"]
            #[inline]
            pub fn resrdy(&self) -> RESRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RESRDYR { bits }
            }
            #[doc = "Bit 1 - Overrun"]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 2 - Window Monitor"]
            #[inline]
            pub fn winmon(&self) -> WINMONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WINMONR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Result Ready"]
            #[inline]
            pub fn resrdy(&mut self) -> _RESRDYW {
                _RESRDYW { w: self }
            }
            #[doc = "Bit 1 - Overrun"]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 2 - Window Monitor"]
            #[inline]
            pub fn winmon(&mut self) -> _WINMONW {
                _WINMONW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Offset Correction"]
    pub struct OFFSETCORR {
        register: VolatileCell<u16>,
    }
    #[doc = "Offset Correction"]
    pub mod offsetcorr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::OFFSETCORR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OFFSETCORRR {
            bits: u16,
        }
        impl OFFSETCORRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFSETCORRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFSETCORRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:11 - Offset Correction Value"]
            #[inline]
            pub fn offsetcorr(&self) -> OFFSETCORRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                OFFSETCORRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Offset Correction Value"]
            #[inline]
            pub fn offsetcorr(&mut self) -> _OFFSETCORRW {
                _OFFSETCORRW { w: self }
            }
        }
    }
    #[doc = "Reference Control"]
    pub struct REFCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Reference Control"]
    pub mod refctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::REFCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "1.0V voltage reference"]
            INT1V,
            #[doc = "1/1.48 VDDANA"]
            INTVCC0,
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            INTVCC1,
            #[doc = "External reference"]
            AREFA,
            #[doc = "External reference"]
            AREFB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::INT1V => 0,
                    REFSELR::INTVCC0 => 0x01,
                    REFSELR::INTVCC1 => 0x02,
                    REFSELR::AREFA => 0x03,
                    REFSELR::AREFB => 0x04,
                    REFSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::INT1V,
                    1 => REFSELR::INTVCC0,
                    2 => REFSELR::INTVCC1,
                    3 => REFSELR::AREFA,
                    4 => REFSELR::AREFB,
                    i => REFSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INT1V`"]
            #[inline]
            pub fn is_int1v(&self) -> bool {
                *self == REFSELR::INT1V
            }
            #[doc = "Checks if the value of the field is `INTVCC0`"]
            #[inline]
            pub fn is_intvcc0(&self) -> bool {
                *self == REFSELR::INTVCC0
            }
            #[doc = "Checks if the value of the field is `INTVCC1`"]
            #[inline]
            pub fn is_intvcc1(&self) -> bool {
                *self == REFSELR::INTVCC1
            }
            #[doc = "Checks if the value of the field is `AREFA`"]
            #[inline]
            pub fn is_arefa(&self) -> bool {
                *self == REFSELR::AREFA
            }
            #[doc = "Checks if the value of the field is `AREFB`"]
            #[inline]
            pub fn is_arefb(&self) -> bool {
                *self == REFSELR::AREFB
            }
        }
        #[doc = r" Value of the field"]
        pub struct REFCOMPR {
            bits: bool,
        }
        impl REFCOMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "1.0V voltage reference"]
            INT1V,
            #[doc = "1/1.48 VDDANA"]
            INTVCC0,
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            INTVCC1,
            #[doc = "External reference"]
            AREFA,
            #[doc = "External reference"]
            AREFB,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::INT1V => 0,
                    REFSELW::INTVCC0 => 1,
                    REFSELW::INTVCC1 => 2,
                    REFSELW::AREFA => 3,
                    REFSELW::AREFB => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1.0V voltage reference"]
            #[inline]
            pub fn int1v(self) -> &'a mut W {
                self.variant(REFSELW::INT1V)
            }
            #[doc = "1/1.48 VDDANA"]
            #[inline]
            pub fn intvcc0(self) -> &'a mut W {
                self.variant(REFSELW::INTVCC0)
            }
            #[doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
            #[inline]
            pub fn intvcc1(self) -> &'a mut W {
                self.variant(REFSELW::INTVCC1)
            }
            #[doc = "External reference"]
            #[inline]
            pub fn arefa(self) -> &'a mut W {
                self.variant(REFSELW::AREFA)
            }
            #[doc = "External reference"]
            #[inline]
            pub fn arefb(self) -> &'a mut W {
                self.variant(REFSELW::AREFB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFCOMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFCOMPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Reference Selection"]
            #[inline]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
            #[inline]
            pub fn refcomp(&self) -> REFCOMPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                REFCOMPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Reference Selection"]
            #[inline]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
            #[doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
            #[inline]
            pub fn refcomp(&mut self) -> _REFCOMPW {
                _REFCOMPW { w: self }
            }
        }
    }
    #[doc = "Result"]
    pub struct RESULT {
        register: VolatileCell<u16>,
    }
    #[doc = "Result"]
    pub mod result {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        impl super::RESULT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Result Conversion Value"]
            #[inline]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                RESULTR { bits }
            }
        }
    }
    #[doc = "Sampling Time Control"]
    pub struct SAMPCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Sampling Time Control"]
    pub mod sampctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SAMPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SAMPLENR {
            bits: u8,
        }
        impl SAMPLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:5 - Sampling Time Length"]
            #[inline]
            pub fn samplen(&self) -> SAMPLENR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                SAMPLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Sampling Time Length"]
            #[inline]
            pub fn samplen(&mut self) -> _SAMPLENW {
                _SAMPLENW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Software Trigger"]
    pub struct SWTRIG {
        register: VolatileCell<u8>,
    }
    #[doc = "Software Trigger"]
    pub mod swtrig {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SWTRIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLUSHR {
            bits: bool,
        }
        impl FLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - ADC Conversion Flush"]
            #[inline]
            pub fn flush(&self) -> FLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FLUSHR { bits }
            }
            #[doc = "Bit 1 - ADC Start Conversion"]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ADC Conversion Flush"]
            #[inline]
            pub fn flush(&mut self) -> _FLUSHW {
                _FLUSHW { w: self }
            }
            #[doc = "Bit 1 - ADC Start Conversion"]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Control"]
    pub struct WINCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Window Monitor Control"]
    pub mod winctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::WINCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WINMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINMODER {
            #[doc = "No window mode (default)"]
            DISABLE,
            #[doc = "Mode 1: RESULT > WINLT"]
            MODE1,
            #[doc = "Mode 2: RESULT < WINUT"]
            MODE2,
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            MODE3,
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            MODE4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WINMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINMODER::DISABLE => 0,
                    WINMODER::MODE1 => 0x01,
                    WINMODER::MODE2 => 0x02,
                    WINMODER::MODE3 => 0x03,
                    WINMODER::MODE4 => 0x04,
                    WINMODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WINMODER {
                match value {
                    0 => WINMODER::DISABLE,
                    1 => WINMODER::MODE1,
                    2 => WINMODER::MODE2,
                    3 => WINMODER::MODE3,
                    4 => WINMODER::MODE4,
                    i => WINMODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == WINMODER::DISABLE
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline]
            pub fn is_mode1(&self) -> bool {
                *self == WINMODER::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline]
            pub fn is_mode2(&self) -> bool {
                *self == WINMODER::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline]
            pub fn is_mode3(&self) -> bool {
                *self == WINMODER::MODE3
            }
            #[doc = "Checks if the value of the field is `MODE4`"]
            #[inline]
            pub fn is_mode4(&self) -> bool {
                *self == WINMODER::MODE4
            }
        }
        #[doc = "Values that can be written to the field `WINMODE`"]
        pub enum WINMODEW {
            #[doc = "No window mode (default)"]
            DISABLE,
            #[doc = "Mode 1: RESULT > WINLT"]
            MODE1,
            #[doc = "Mode 2: RESULT < WINUT"]
            MODE2,
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            MODE3,
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            MODE4,
        }
        impl WINMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINMODEW::DISABLE => 0,
                    WINMODEW::MODE1 => 1,
                    WINMODEW::MODE2 => 2,
                    WINMODEW::MODE3 => 3,
                    WINMODEW::MODE4 => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WINMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No window mode (default)"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(WINMODEW::DISABLE)
            }
            #[doc = "Mode 1: RESULT > WINLT"]
            #[inline]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WINMODEW::MODE1)
            }
            #[doc = "Mode 2: RESULT < WINUT"]
            #[inline]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WINMODEW::MODE2)
            }
            #[doc = "Mode 3: WINLT < RESULT < WINUT"]
            #[inline]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WINMODEW::MODE3)
            }
            #[doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
            #[inline]
            pub fn mode4(self) -> &'a mut W {
                self.variant(WINMODEW::MODE4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - Window Monitor Mode"]
            #[inline]
            pub fn winmode(&self) -> WINMODER {
                WINMODER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Window Monitor Mode"]
            #[inline]
            pub fn winmode(&mut self) -> _WINMODEW {
                _WINMODEW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Lower Threshold"]
    pub struct WINLT {
        register: VolatileCell<u16>,
    }
    #[doc = "Window Monitor Lower Threshold"]
    pub mod winlt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::WINLT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINLTR {
            bits: u16,
        }
        impl WINLTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINLTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINLTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Window Lower Threshold"]
            #[inline]
            pub fn winlt(&self) -> WINLTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                WINLTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Window Lower Threshold"]
            #[inline]
            pub fn winlt(&mut self) -> _WINLTW {
                _WINLTW { w: self }
            }
        }
    }
    #[doc = "Window Monitor Upper Threshold"]
    pub struct WINUT {
        register: VolatileCell<u16>,
    }
    #[doc = "Window Monitor Upper Threshold"]
    pub mod winut {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::WINUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINUTR {
            bits: u16,
        }
        impl WINUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Window Upper Threshold"]
            #[inline]
            pub fn winut(&self) -> WINUTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                WINUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Window Upper Threshold"]
            #[inline]
            pub fn winut(&mut self) -> _WINUTW {
                _WINUTW { w: self }
            }
        }
    }
}
#[doc = "Analog Digital Converter"]
pub struct ADC {
    register_block: adc::RegisterBlock,
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Digital Analog Converter"]
pub const DAC: Peripheral<DAC> = unsafe { Peripheral::new(0x4200_4800) };
#[doc = "Digital Analog Converter"]
pub mod dac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x01 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x02 - Event Control"]
        pub evctrl: EVCTRL,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x07 - Status"]
        pub status: STATUS,
        #[doc = "0x08 - Data"]
        pub data: DATA,
        _reserved1: [u8; 2usize],
        #[doc = "0x0c - Data Buffer"]
        pub databuf: DATABUF,
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u8>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Run in Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOENR {
            bits: bool,
        }
        impl EOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOENR {
            bits: bool,
        }
        impl IOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEFTADJR {
            bits: bool,
        }
        impl LEFTADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct VPDR {
            bits: bool,
        }
        impl VPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "Internal 1.0V reference"]
            INT1V,
            #[doc = "AVCC"]
            AVCC,
            #[doc = "External reference"]
            VREFP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::INT1V => 0,
                    REFSELR::AVCC => 0x01,
                    REFSELR::VREFP => 0x02,
                    REFSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::INT1V,
                    1 => REFSELR::AVCC,
                    2 => REFSELR::VREFP,
                    i => REFSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `INT1V`"]
            #[inline]
            pub fn is_int1v(&self) -> bool {
                *self == REFSELR::INT1V
            }
            #[doc = "Checks if the value of the field is `AVCC`"]
            #[inline]
            pub fn is_avcc(&self) -> bool {
                *self == REFSELR::AVCC
            }
            #[doc = "Checks if the value of the field is `VREFP`"]
            #[inline]
            pub fn is_vrefp(&self) -> bool {
                *self == REFSELR::VREFP
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEFTADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEFTADJW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "Internal 1.0V reference"]
            INT1V,
            #[doc = "AVCC"]
            AVCC,
            #[doc = "External reference"]
            VREFP,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::INT1V => 0,
                    REFSELW::AVCC => 1,
                    REFSELW::VREFP => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Internal 1.0V reference"]
            #[inline]
            pub fn int1v(self) -> &'a mut W {
                self.variant(REFSELW::INT1V)
            }
            #[doc = "AVCC"]
            #[inline]
            pub fn avcc(self) -> &'a mut W {
                self.variant(REFSELW::AVCC)
            }
            #[doc = "External reference"]
            #[inline]
            pub fn vrefp(self) -> &'a mut W {
                self.variant(REFSELW::VREFP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - External Output Enable"]
            #[inline]
            pub fn eoen(&self) -> EOENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EOENR { bits }
            }
            #[doc = "Bit 1 - Internal Output Enable"]
            #[inline]
            pub fn ioen(&self) -> IOENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                IOENR { bits }
            }
            #[doc = "Bit 2 - Left Adjusted Data"]
            #[inline]
            pub fn leftadj(&self) -> LEFTADJR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                LEFTADJR { bits }
            }
            #[doc = "Bit 3 - Voltage Pump Disable"]
            #[inline]
            pub fn vpd(&self) -> VPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                VPDR { bits }
            }
            #[doc = "Bits 6:7 - Reference Selection"]
            #[inline]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Output Enable"]
            #[inline]
            pub fn eoen(&mut self) -> _EOENW {
                _EOENW { w: self }
            }
            #[doc = "Bit 1 - Internal Output Enable"]
            #[inline]
            pub fn ioen(&mut self) -> _IOENW {
                _IOENW { w: self }
            }
            #[doc = "Bit 2 - Left Adjusted Data"]
            #[inline]
            pub fn leftadj(&mut self) -> _LEFTADJW {
                _LEFTADJW { w: self }
            }
            #[doc = "Bit 3 - Voltage Pump Disable"]
            #[inline]
            pub fn vpd(&mut self) -> _VPDW {
                _VPDW { w: self }
            }
            #[doc = "Bits 6:7 - Reference Selection"]
            #[inline]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
        }
    }
    #[doc = "Data"]
    pub struct DATA {
        register: VolatileCell<u16>,
    }
    #[doc = "Data"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data to be converted"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data to be converted"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Data Buffer"]
    pub struct DATABUF {
        register: VolatileCell<u16>,
    }
    #[doc = "Data Buffer"]
    pub mod databuf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DATABUF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATABUFR {
            bits: u16,
        }
        impl DATABUFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATABUFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATABUFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data Buffer"]
            #[inline]
            pub fn databuf(&self) -> DATABUFR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                DATABUFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data Buffer"]
            #[inline]
            pub fn databuf(&mut self) -> _DATABUFW {
                _DATABUFW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTEIR {
            bits: bool,
        }
        impl STARTEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYEOR {
            bits: bool,
        }
        impl EMPTYEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Start Conversion Event Input"]
            #[inline]
            pub fn startei(&self) -> STARTEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STARTEIR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Event Output"]
            #[inline]
            pub fn emptyeo(&self) -> EMPTYEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYEOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start Conversion Event Input"]
            #[inline]
            pub fn startei(&mut self) -> _STARTEIW {
                _STARTEIW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Event Output"]
            #[inline]
            pub fn emptyeo(&mut self) -> _EMPTYEOW {
                _EMPTYEOW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun Interrupt Enable"]
            #[inline]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
            #[inline]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UNDERRUNR {
            bits: bool,
        }
        impl UNDERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNDERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNDERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Underrun"]
            #[inline]
            pub fn underrun(&self) -> UNDERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                UNDERRUNR { bits }
            }
            #[doc = "Bit 1 - Data Buffer Empty"]
            #[inline]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EMPTYR { bits }
            }
            #[doc = "Bit 2 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Underrun"]
            #[inline]
            pub fn underrun(&mut self) -> _UNDERRUNW {
                _UNDERRUNW { w: self }
            }
            #[doc = "Bit 1 - Data Buffer Empty"]
            #[inline]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy Status"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Digital Analog Converter"]
pub struct DAC {
    register_block: dac::RegisterBlock,
}
impl Deref for DAC {
    type Target = dac::RegisterBlock;
    fn deref(&self) -> &dac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Device Service Unit"]
pub const DSU: Peripheral<DSU> = unsafe { Peripheral::new(0x4100_2000) };
#[doc = "Device Service Unit"]
pub mod dsu {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status A"]
        pub statusa: STATUSA,
        #[doc = "0x02 - Status B"]
        pub statusb: STATUSB,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Address"]
        pub addr: ADDR,
        #[doc = "0x08 - Length"]
        pub length: LENGTH,
        #[doc = "0x0c - Data"]
        pub data: DATA,
        #[doc = "0x10 - Debug Communication Channel n"]
        pub dcc: [DCC; 2],
        #[doc = "0x18 - Device Identification"]
        pub did: DID,
        _reserved1: [u8; 212usize],
        #[doc = "0xf0 - Device Configuration"]
        pub dcfg: [DCFG; 2],
        _reserved2: [u8; 3848usize],
        #[doc = "0x1000 - Coresight ROM Table Entry n"]
        pub entry: [ENTRY; 2],
        #[doc = "0x1008 - Coresight ROM Table End"]
        pub end: END,
        _reserved3: [u8; 4032usize],
        #[doc = "0x1fcc - Coresight ROM Table Memory Type"]
        pub memtype: MEMTYPE,
        #[doc = "0x1fd0 - Peripheral Identification 4"]
        pub pid4: PID4,
        #[doc = "0x1fd4 - Peripheral Identification 5"]
        pub pid5: PID5,
        #[doc = "0x1fd8 - Peripheral Identification 6"]
        pub pid6: PID6,
        #[doc = "0x1fdc - Peripheral Identification 7"]
        pub pid7: PID7,
        #[doc = "0x1fe0 - Peripheral Identification 0"]
        pub pid0: PID0,
        #[doc = "0x1fe4 - Peripheral Identification 1"]
        pub pid1: PID1,
        #[doc = "0x1fe8 - Peripheral Identification 2"]
        pub pid2: PID2,
        #[doc = "0x1fec - Peripheral Identification 3"]
        pub pid3: PID3,
        #[doc = "0x1ff0 - Component Identification 0"]
        pub cid0: CID0,
        #[doc = "0x1ff4 - Component Identification 1"]
        pub cid1: CID1,
        #[doc = "0x1ff8 - Component Identification 2"]
        pub cid2: CID2,
        #[doc = "0x1ffc - Component Identification 3"]
        pub cid3: CID3,
    }
    #[doc = "Address"]
    pub struct ADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Address"]
    pub mod addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AMODR {
            bits: u8,
        }
        impl AMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRR {
            bits: u32,
        }
        impl ADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AMODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x3fff_ffff;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Access Mode"]
            #[inline]
            pub fn amod(&self) -> AMODR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AMODR { bits }
            }
            #[doc = "Bits 2:31 - Address"]
            #[inline]
            pub fn addr(&self) -> ADDRR {
                let bits = {
                    const MASK: u32 = 0x3fff_ffff;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Access Mode"]
            #[inline]
            pub fn amod(&mut self) -> _AMODW {
                _AMODW { w: self }
            }
            #[doc = "Bits 2:31 - Address"]
            #[inline]
            pub fn addr(&mut self) -> _ADDRW {
                _ADDRW { w: self }
            }
        }
    }
    #[doc = "Component Identification 0"]
    pub struct CID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 0"]
    pub mod cid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB0R {
            bits: u8,
        }
        impl PREAMBLEB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 0"]
            #[inline]
            pub fn preambleb0(&self) -> PREAMBLEB0R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB0R { bits }
            }
        }
    }
    #[doc = "Component Identification 1"]
    pub struct CID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 1"]
    pub mod cid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLER {
            bits: u8,
        }
        impl PREAMBLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCLASSR {
            bits: u8,
        }
        impl CCLASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Preamble"]
            #[inline]
            pub fn preamble(&self) -> PREAMBLER {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLER { bits }
            }
            #[doc = "Bits 4:7 - Component Class"]
            #[inline]
            pub fn cclass(&self) -> CCLASSR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CCLASSR { bits }
            }
        }
    }
    #[doc = "Component Identification 2"]
    pub struct CID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 2"]
    pub mod cid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB2R {
            bits: u8,
        }
        impl PREAMBLEB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 2"]
            #[inline]
            pub fn preambleb2(&self) -> PREAMBLEB2R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB2R { bits }
            }
        }
    }
    #[doc = "Component Identification 3"]
    pub struct CID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Component Identification 3"]
    pub mod cid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREAMBLEB3R {
            bits: u8,
        }
        impl PREAMBLEB3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Preamble Byte 3"]
            #[inline]
            pub fn preambleb3(&self) -> PREAMBLEB3R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREAMBLEB3R { bits }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MBISTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MBISTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMSAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 2 - 32-bit Cyclic Redundancy Code"]
            #[inline]
            pub fn crc(&mut self) -> _CRCW {
                _CRCW { w: self }
            }
            #[doc = "Bit 3 - Memory built-in self-test"]
            #[inline]
            pub fn mbist(&mut self) -> _MBISTW {
                _MBISTW { w: self }
            }
            #[doc = "Bit 4 - Chip-Erase"]
            #[inline]
            pub fn ce(&mut self) -> _CEW {
                _CEW { w: self }
            }
            #[doc = "Bit 6 - Auxiliary Row Read"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
            #[doc = "Bit 7 - Start Memory Stream Access"]
            #[inline]
            pub fn smsa(&mut self) -> _SMSAW {
                _SMSAW { w: self }
            }
        }
    }
    #[doc = "Data"]
    pub struct DATA {
        register: VolatileCell<u32>,
    }
    #[doc = "Data"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u32,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Debug Communication Channel n"]
    pub struct DCC {
        register: VolatileCell<u32>,
    }
    #[doc = "Debug Communication Channel n"]
    pub mod dcc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u32,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Device Configuration"]
    pub struct DCFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Device Configuration"]
    pub mod dcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCFGR {
            bits: u32,
        }
        impl DCFGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCFGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Device Configuration"]
            #[inline]
            pub fn dcfg(&self) -> DCFGR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DCFGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Device Configuration"]
            #[inline]
            pub fn dcfg(&mut self) -> _DCFGW {
                _DCFGW { w: self }
            }
        }
    }
    #[doc = "Device Identification"]
    pub struct DID {
        register: VolatileCell<u32>,
    }
    #[doc = "Device Identification"]
    pub mod did {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DID {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVSELR {
            bits: u8,
        }
        impl DEVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVISIONR {
            bits: u8,
        }
        impl REVISIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIER {
            bits: u8,
        }
        impl DIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `SERIES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SERIESR {
            #[doc = "Cortex-M0+ processor, basic feature set"]
            _0,
            #[doc = "Cortex-M0+ processor, USB"]
            _1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SERIESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SERIESR::_0 => 0,
                    SERIESR::_1 => 0x01,
                    SERIESR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SERIESR {
                match value {
                    0 => SERIESR::_0,
                    1 => SERIESR::_1,
                    i => SERIESR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0`"]
            #[inline]
            pub fn is_0(&self) -> bool {
                *self == SERIESR::_0
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline]
            pub fn is_1(&self) -> bool {
                *self == SERIESR::_1
            }
        }
        #[doc = "Possible values of the field `FAMILY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FAMILYR {
            #[doc = "General purpose microcontroller"]
            _0,
            #[doc = "PicoPower"]
            _1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FAMILYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FAMILYR::_0 => 0,
                    FAMILYR::_1 => 0x01,
                    FAMILYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FAMILYR {
                match value {
                    0 => FAMILYR::_0,
                    1 => FAMILYR::_1,
                    i => FAMILYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0`"]
            #[inline]
            pub fn is_0(&self) -> bool {
                *self == FAMILYR::_0
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline]
            pub fn is_1(&self) -> bool {
                *self == FAMILYR::_1
            }
        }
        #[doc = "Possible values of the field `PROCESSOR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PROCESSORR {
            #[doc = "Cortex-M0"]
            _0,
            #[doc = "Cortex-M0+"]
            _1,
            #[doc = "Cortex-M3"]
            _2,
            #[doc = "Cortex-M4"]
            _3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PROCESSORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PROCESSORR::_0 => 0,
                    PROCESSORR::_1 => 0x01,
                    PROCESSORR::_2 => 0x02,
                    PROCESSORR::_3 => 0x03,
                    PROCESSORR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PROCESSORR {
                match value {
                    0 => PROCESSORR::_0,
                    1 => PROCESSORR::_1,
                    2 => PROCESSORR::_2,
                    3 => PROCESSORR::_3,
                    i => PROCESSORR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0`"]
            #[inline]
            pub fn is_0(&self) -> bool {
                *self == PROCESSORR::_0
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline]
            pub fn is_1(&self) -> bool {
                *self == PROCESSORR::_1
            }
            #[doc = "Checks if the value of the field is `_2`"]
            #[inline]
            pub fn is_2(&self) -> bool {
                *self == PROCESSORR::_2
            }
            #[doc = "Checks if the value of the field is `_3`"]
            #[inline]
            pub fn is_3(&self) -> bool {
                *self == PROCESSORR::_3
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Device Select"]
            #[inline]
            pub fn devsel(&self) -> DEVSELR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEVSELR { bits }
            }
            #[doc = "Bits 8:11 - Revision Number"]
            #[inline]
            pub fn revision(&self) -> REVISIONR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVISIONR { bits }
            }
            #[doc = "Bits 12:15 - Die Number"]
            #[inline]
            pub fn die(&self) -> DIER {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIER { bits }
            }
            #[doc = "Bits 16:21 - Series"]
            #[inline]
            pub fn series(&self) -> SERIESR {
                SERIESR::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:27 - Family"]
            #[inline]
            pub fn family(&self) -> FAMILYR {
                FAMILYR::_from({
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 28:31 - Processor"]
            #[inline]
            pub fn processor(&self) -> PROCESSORR {
                PROCESSORR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Coresight ROM Table End"]
    pub struct END {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table End"]
    pub mod end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::END {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENDR {
            bits: u32,
        }
        impl ENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - End Marker"]
            #[inline]
            pub fn end(&self) -> ENDR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ENDR { bits }
            }
        }
    }
    #[doc = "Coresight ROM Table Entry n"]
    pub struct ENTRY {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table Entry n"]
    pub mod entry {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ENTRY {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct EPRESR {
            bits: bool,
        }
        impl EPRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FMTR {
            bits: bool,
        }
        impl FMTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDOFFR {
            bits: u32,
        }
        impl ADDOFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Entry Present"]
            #[inline]
            pub fn epres(&self) -> EPRESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EPRESR { bits }
            }
            #[doc = "Bit 1 - Format"]
            #[inline]
            pub fn fmt(&self) -> FMTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FMTR { bits }
            }
            #[doc = "Bits 12:31 - Address Offset"]
            #[inline]
            pub fn addoff(&self) -> ADDOFFR {
                let bits = {
                    const MASK: u32 = 0x000f_ffff;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDOFFR { bits }
            }
        }
    }
    #[doc = "Length"]
    pub struct LENGTH {
        register: VolatileCell<u32>,
    }
    #[doc = "Length"]
    pub mod length {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LENGTH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LENGTHR {
            bits: u32,
        }
        impl LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x3fff_ffff;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 2:31 - Length"]
            #[inline]
            pub fn length(&self) -> LENGTHR {
                let bits = {
                    const MASK: u32 = 0x3fff_ffff;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                LENGTHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 2:31 - Length"]
            #[inline]
            pub fn length(&mut self) -> _LENGTHW {
                _LENGTHW { w: self }
            }
        }
    }
    #[doc = "Coresight ROM Table Memory Type"]
    pub struct MEMTYPE {
        register: VolatileCell<u32>,
    }
    #[doc = "Coresight ROM Table Memory Type"]
    pub mod memtype {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MEMTYPE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMEMPR {
            bits: bool,
        }
        impl SMEMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - System Memory Present"]
            #[inline]
            pub fn smemp(&self) -> SMEMPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SMEMPR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 0"]
    pub struct PID0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 0"]
    pub mod pid0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARTNBLR {
            bits: u8,
        }
        impl PARTNBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Part Number Low"]
            #[inline]
            pub fn partnbl(&self) -> PARTNBLR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PARTNBLR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 1"]
    pub struct PID1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 1"]
    pub mod pid1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARTNBHR {
            bits: u8,
        }
        impl PARTNBHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPIDCLR {
            bits: u8,
        }
        impl JEPIDCLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Part Number High"]
            #[inline]
            pub fn partnbh(&self) -> PARTNBHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PARTNBHR { bits }
            }
            #[doc = "Bits 4:7 - Low part of the JEP-106 Identity Code"]
            #[inline]
            pub fn jepidcl(&self) -> JEPIDCLR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPIDCLR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 2"]
    pub struct PID2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 2"]
    pub mod pid2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPIDCHR {
            bits: u8,
        }
        impl JEPIDCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPUR {
            bits: bool,
        }
        impl JEPUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVISIONR {
            bits: u8,
        }
        impl REVISIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - JEP-106 Identity Code High"]
            #[inline]
            pub fn jepidch(&self) -> JEPIDCHR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPIDCHR { bits }
            }
            #[doc = "Bit 3 - JEP-106 Identity Code is used"]
            #[inline]
            pub fn jepu(&self) -> JEPUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JEPUR { bits }
            }
            #[doc = "Bits 4:7 - Revision Number"]
            #[inline]
            pub fn revision(&self) -> REVISIONR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVISIONR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 3"]
    pub struct PID3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 3"]
    pub mod pid3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID3 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CUSMODR {
            bits: u8,
        }
        impl CUSMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REVANDR {
            bits: u8,
        }
        impl REVANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - ARM CUSMOD"]
            #[inline]
            pub fn cusmod(&self) -> CUSMODR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CUSMODR { bits }
            }
            #[doc = "Bits 4:7 - Revision Number"]
            #[inline]
            pub fn revand(&self) -> REVANDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REVANDR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 4"]
    pub struct PID4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 4"]
    pub mod pid4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID4 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEPCCR {
            bits: u8,
        }
        impl JEPCCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FKBCR {
            bits: u8,
        }
        impl FKBCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - JEP-106 Continuation Code"]
            #[inline]
            pub fn jepcc(&self) -> JEPCCR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEPCCR { bits }
            }
            #[doc = "Bits 4:7 - 4KB count"]
            #[inline]
            pub fn fkbc(&self) -> FKBCR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FKBCR { bits }
            }
        }
    }
    #[doc = "Peripheral Identification 5"]
    pub struct PID5 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 5"]
    pub mod pid5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID5 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Peripheral Identification 6"]
    pub struct PID6 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 6"]
    pub mod pid6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID6 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Peripheral Identification 7"]
    pub struct PID7 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral Identification 7"]
    pub mod pid7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PID7 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Status A"]
    pub struct STATUSA {
        register: VolatileCell<u8>,
    }
    #[doc = "Status A"]
    pub mod statusa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::STATUSA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONER {
            bits: bool,
        }
        impl DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRSTEXTR {
            bits: bool,
        }
        impl CRSTEXTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BERRR {
            bits: bool,
        }
        impl BERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FAILR {
            bits: bool,
        }
        impl FAILR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERRR {
            bits: bool,
        }
        impl PERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRSTEXTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRSTEXTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FAILW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FAILW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Done"]
            #[inline]
            pub fn done(&self) -> DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DONER { bits }
            }
            #[doc = "Bit 1 - CPU Reset Phase Extension"]
            #[inline]
            pub fn crstext(&self) -> CRSTEXTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CRSTEXTR { bits }
            }
            #[doc = "Bit 2 - Bus Error"]
            #[inline]
            pub fn berr(&self) -> BERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BERRR { bits }
            }
            #[doc = "Bit 3 - Failure"]
            #[inline]
            pub fn fail(&self) -> FAILR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                FAILR { bits }
            }
            #[doc = "Bit 4 - Protection Error"]
            #[inline]
            pub fn perr(&self) -> PERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Done"]
            #[inline]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
            #[doc = "Bit 1 - CPU Reset Phase Extension"]
            #[inline]
            pub fn crstext(&mut self) -> _CRSTEXTW {
                _CRSTEXTW { w: self }
            }
            #[doc = "Bit 2 - Bus Error"]
            #[inline]
            pub fn berr(&mut self) -> _BERRW {
                _BERRW { w: self }
            }
            #[doc = "Bit 3 - Failure"]
            #[inline]
            pub fn fail(&mut self) -> _FAILW {
                _FAILW { w: self }
            }
            #[doc = "Bit 4 - Protection Error"]
            #[inline]
            pub fn perr(&mut self) -> _PERRW {
                _PERRW { w: self }
            }
        }
    }
    #[doc = "Status B"]
    pub struct STATUSB {
        register: VolatileCell<u8>,
    }
    #[doc = "Status B"]
    pub mod statusb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUSB {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROTR {
            bits: bool,
        }
        impl PROTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGPRESR {
            bits: bool,
        }
        impl DBGPRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCCD0R {
            bits: bool,
        }
        impl DCCD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCCD1R {
            bits: bool,
        }
        impl DCCD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPER {
            bits: bool,
        }
        impl HPER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Protected"]
            #[inline]
            pub fn prot(&self) -> PROTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PROTR { bits }
            }
            #[doc = "Bit 1 - Debugger Present"]
            #[inline]
            pub fn dbgpres(&self) -> DBGPRESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGPRESR { bits }
            }
            #[doc = "Bit 2 - Debug Communication Channel 0 Dirty"]
            #[inline]
            pub fn dccd0(&self) -> DCCD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DCCD0R { bits }
            }
            #[doc = "Bit 3 - Debug Communication Channel 1 Dirty"]
            #[inline]
            pub fn dccd1(&self) -> DCCD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DCCD1R { bits }
            }
            #[doc = "Bit 4 - Hot-Plugging Enable"]
            #[inline]
            pub fn hpe(&self) -> HPER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                HPER { bits }
            }
        }
    }
}
#[doc = "Device Service Unit"]
pub struct DSU {
    register_block: dsu::RegisterBlock,
}
impl Deref for DSU {
    type Target = dsu::RegisterBlock;
    fn deref(&self) -> &dsu::RegisterBlock {
        &self.register_block
    }
}
#[doc = "External Interrupt Controller"]
pub const EIC: Peripheral<EIC> = unsafe { Peripheral::new(0x4000_1800) };
#[doc = "External Interrupt Controller"]
pub mod eic {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status"]
        pub status: STATUS,
        #[doc = "0x02 - Non-Maskable Interrupt Control"]
        pub nmictrl: NMICTRL,
        #[doc = "0x03 - Non-Maskable Interrupt Flag Status and Clear"]
        pub nmiflag: NMIFLAG,
        #[doc = "0x04 - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x08 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x0c - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x10 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x14 - Wake-Up Enable"]
        pub wakeup: WAKEUP,
        #[doc = "0x18 - Configuration n"]
        pub config: [CONFIG; 2],
    }
    #[doc = "Configuration n"]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration n"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SENSE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE0R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE0R::NONE => 0,
                    SENSE0R::RISE => 0x01,
                    SENSE0R::FALL => 0x02,
                    SENSE0R::BOTH => 0x03,
                    SENSE0R::HIGH => 0x04,
                    SENSE0R::LOW => 0x05,
                    SENSE0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE0R {
                match value {
                    0 => SENSE0R::NONE,
                    1 => SENSE0R::RISE,
                    2 => SENSE0R::FALL,
                    3 => SENSE0R::BOTH,
                    4 => SENSE0R::HIGH,
                    5 => SENSE0R::LOW,
                    i => SENSE0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE0R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE0R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE0R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE0R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE0R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE0R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN0R {
            bits: bool,
        }
        impl FILTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE1R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE1R::NONE => 0,
                    SENSE1R::RISE => 0x01,
                    SENSE1R::FALL => 0x02,
                    SENSE1R::BOTH => 0x03,
                    SENSE1R::HIGH => 0x04,
                    SENSE1R::LOW => 0x05,
                    SENSE1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE1R {
                match value {
                    0 => SENSE1R::NONE,
                    1 => SENSE1R::RISE,
                    2 => SENSE1R::FALL,
                    3 => SENSE1R::BOTH,
                    4 => SENSE1R::HIGH,
                    5 => SENSE1R::LOW,
                    i => SENSE1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE1R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE1R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE1R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE1R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE1R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE1R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN1R {
            bits: bool,
        }
        impl FILTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE2R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE2R::NONE => 0,
                    SENSE2R::RISE => 0x01,
                    SENSE2R::FALL => 0x02,
                    SENSE2R::BOTH => 0x03,
                    SENSE2R::HIGH => 0x04,
                    SENSE2R::LOW => 0x05,
                    SENSE2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE2R {
                match value {
                    0 => SENSE2R::NONE,
                    1 => SENSE2R::RISE,
                    2 => SENSE2R::FALL,
                    3 => SENSE2R::BOTH,
                    4 => SENSE2R::HIGH,
                    5 => SENSE2R::LOW,
                    i => SENSE2R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE2R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE2R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE2R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE2R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE2R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE2R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN2R {
            bits: bool,
        }
        impl FILTEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE3R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE3R::NONE => 0,
                    SENSE3R::RISE => 0x01,
                    SENSE3R::FALL => 0x02,
                    SENSE3R::BOTH => 0x03,
                    SENSE3R::HIGH => 0x04,
                    SENSE3R::LOW => 0x05,
                    SENSE3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE3R {
                match value {
                    0 => SENSE3R::NONE,
                    1 => SENSE3R::RISE,
                    2 => SENSE3R::FALL,
                    3 => SENSE3R::BOTH,
                    4 => SENSE3R::HIGH,
                    5 => SENSE3R::LOW,
                    i => SENSE3R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE3R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE3R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE3R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE3R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE3R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE3R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN3R {
            bits: bool,
        }
        impl FILTEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE4R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE4R::NONE => 0,
                    SENSE4R::RISE => 0x01,
                    SENSE4R::FALL => 0x02,
                    SENSE4R::BOTH => 0x03,
                    SENSE4R::HIGH => 0x04,
                    SENSE4R::LOW => 0x05,
                    SENSE4R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE4R {
                match value {
                    0 => SENSE4R::NONE,
                    1 => SENSE4R::RISE,
                    2 => SENSE4R::FALL,
                    3 => SENSE4R::BOTH,
                    4 => SENSE4R::HIGH,
                    5 => SENSE4R::LOW,
                    i => SENSE4R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE4R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE4R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE4R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE4R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE4R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE4R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN4R {
            bits: bool,
        }
        impl FILTEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE5R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE5R::NONE => 0,
                    SENSE5R::RISE => 0x01,
                    SENSE5R::FALL => 0x02,
                    SENSE5R::BOTH => 0x03,
                    SENSE5R::HIGH => 0x04,
                    SENSE5R::LOW => 0x05,
                    SENSE5R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE5R {
                match value {
                    0 => SENSE5R::NONE,
                    1 => SENSE5R::RISE,
                    2 => SENSE5R::FALL,
                    3 => SENSE5R::BOTH,
                    4 => SENSE5R::HIGH,
                    5 => SENSE5R::LOW,
                    i => SENSE5R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE5R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE5R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE5R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE5R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE5R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE5R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN5R {
            bits: bool,
        }
        impl FILTEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE6R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE6R::NONE => 0,
                    SENSE6R::RISE => 0x01,
                    SENSE6R::FALL => 0x02,
                    SENSE6R::BOTH => 0x03,
                    SENSE6R::HIGH => 0x04,
                    SENSE6R::LOW => 0x05,
                    SENSE6R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE6R {
                match value {
                    0 => SENSE6R::NONE,
                    1 => SENSE6R::RISE,
                    2 => SENSE6R::FALL,
                    3 => SENSE6R::BOTH,
                    4 => SENSE6R::HIGH,
                    5 => SENSE6R::LOW,
                    i => SENSE6R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE6R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE6R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE6R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE6R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE6R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE6R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN6R {
            bits: bool,
        }
        impl FILTEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SENSE7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSE7R {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSE7R::NONE => 0,
                    SENSE7R::RISE => 0x01,
                    SENSE7R::FALL => 0x02,
                    SENSE7R::BOTH => 0x03,
                    SENSE7R::HIGH => 0x04,
                    SENSE7R::LOW => 0x05,
                    SENSE7R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSE7R {
                match value {
                    0 => SENSE7R::NONE,
                    1 => SENSE7R::RISE,
                    2 => SENSE7R::FALL,
                    3 => SENSE7R::BOTH,
                    4 => SENSE7R::HIGH,
                    5 => SENSE7R::LOW,
                    i => SENSE7R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == SENSE7R::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == SENSE7R::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == SENSE7R::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == SENSE7R::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSE7R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSE7R::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct FILTEN7R {
            bits: bool,
        }
        impl FILTEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `SENSE0`"]
        pub enum SENSE0W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
        }
        impl SENSE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE0W::NONE => 0,
                    SENSE0W::RISE => 1,
                    SENSE0W::FALL => 2,
                    SENSE0W::BOTH => 3,
                    SENSE0W::HIGH => 4,
                    SENSE0W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE0W::NONE)
            }
            #[doc = "Rising-edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE0W::RISE)
            }
            #[doc = "Falling-edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE0W::FALL)
            }
            #[doc = "Both-edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE0W::BOTH)
            }
            #[doc = "High-level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE0W::HIGH)
            }
            #[doc = "Low-level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE0W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE1`"]
        pub enum SENSE1W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE1W::NONE => 0,
                    SENSE1W::RISE => 1,
                    SENSE1W::FALL => 2,
                    SENSE1W::BOTH => 3,
                    SENSE1W::HIGH => 4,
                    SENSE1W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE1W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE1W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE1W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE1W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE1W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE1W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE2`"]
        pub enum SENSE2W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE2W::NONE => 0,
                    SENSE2W::RISE => 1,
                    SENSE2W::FALL => 2,
                    SENSE2W::BOTH => 3,
                    SENSE2W::HIGH => 4,
                    SENSE2W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE2W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE2W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE2W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE2W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE2W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE2W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE3`"]
        pub enum SENSE3W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE3W::NONE => 0,
                    SENSE3W::RISE => 1,
                    SENSE3W::FALL => 2,
                    SENSE3W::BOTH => 3,
                    SENSE3W::HIGH => 4,
                    SENSE3W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE3W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE3W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE3W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE3W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE3W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE3W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE4`"]
        pub enum SENSE4W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE4W::NONE => 0,
                    SENSE4W::RISE => 1,
                    SENSE4W::FALL => 2,
                    SENSE4W::BOTH => 3,
                    SENSE4W::HIGH => 4,
                    SENSE4W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE4W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE4W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE4W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE4W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE4W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE4W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE5`"]
        pub enum SENSE5W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE5W::NONE => 0,
                    SENSE5W::RISE => 1,
                    SENSE5W::FALL => 2,
                    SENSE5W::BOTH => 3,
                    SENSE5W::HIGH => 4,
                    SENSE5W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE5W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE5W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE5W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE5W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE5W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE5W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE6`"]
        pub enum SENSE6W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE6W::NONE => 0,
                    SENSE6W::RISE => 1,
                    SENSE6W::FALL => 2,
                    SENSE6W::BOTH => 3,
                    SENSE6W::HIGH => 4,
                    SENSE6W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE6W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE6W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE6W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE6W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE6W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE6W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE7`"]
        pub enum SENSE7W {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising edge detection"]
            RISE,
            #[doc = "Falling edge detection"]
            FALL,
            #[doc = "Both edges detection"]
            BOTH,
            #[doc = "High level detection"]
            HIGH,
            #[doc = "Low level detection"]
            LOW,
        }
        impl SENSE7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSE7W::NONE => 0,
                    SENSE7W::RISE => 1,
                    SENSE7W::FALL => 2,
                    SENSE7W::BOTH => 3,
                    SENSE7W::HIGH => 4,
                    SENSE7W::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSE7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSE7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(SENSE7W::NONE)
            }
            #[doc = "Rising edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(SENSE7W::RISE)
            }
            #[doc = "Falling edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(SENSE7W::FALL)
            }
            #[doc = "Both edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(SENSE7W::BOTH)
            }
            #[doc = "High level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSE7W::HIGH)
            }
            #[doc = "Low level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSE7W::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FILTEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FILTEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Input Sense 0 Configuration"]
            #[inline]
            pub fn sense0(&self) -> SENSE0R {
                SENSE0R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - Filter 0 Enable"]
            #[inline]
            pub fn filten0(&self) -> FILTEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN0R { bits }
            }
            #[doc = "Bits 4:6 - Input Sense 1 Configuration"]
            #[inline]
            pub fn sense1(&self) -> SENSE1R {
                SENSE1R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Filter 1 Enable"]
            #[inline]
            pub fn filten1(&self) -> FILTEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN1R { bits }
            }
            #[doc = "Bits 8:10 - Input Sense 2 Configuration"]
            #[inline]
            pub fn sense2(&self) -> SENSE2R {
                SENSE2R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 11 - Filter 2 Enable"]
            #[inline]
            pub fn filten2(&self) -> FILTEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN2R { bits }
            }
            #[doc = "Bits 12:14 - Input Sense 3 Configuration"]
            #[inline]
            pub fn sense3(&self) -> SENSE3R {
                SENSE3R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - Filter 3 Enable"]
            #[inline]
            pub fn filten3(&self) -> FILTEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN3R { bits }
            }
            #[doc = "Bits 16:18 - Input Sense 4 Configuration"]
            #[inline]
            pub fn sense4(&self) -> SENSE4R {
                SENSE4R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 19 - Filter 4 Enable"]
            #[inline]
            pub fn filten4(&self) -> FILTEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN4R { bits }
            }
            #[doc = "Bits 20:22 - Input Sense 5 Configuration"]
            #[inline]
            pub fn sense5(&self) -> SENSE5R {
                SENSE5R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 23 - Filter 5 Enable"]
            #[inline]
            pub fn filten5(&self) -> FILTEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN5R { bits }
            }
            #[doc = "Bits 24:26 - Input Sense 6 Configuration"]
            #[inline]
            pub fn sense6(&self) -> SENSE6R {
                SENSE6R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 27 - Filter 6 Enable"]
            #[inline]
            pub fn filten6(&self) -> FILTEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN6R { bits }
            }
            #[doc = "Bits 28:30 - Input Sense 7 Configuration"]
            #[inline]
            pub fn sense7(&self) -> SENSE7R {
                SENSE7R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 31 - Filter 7 Enable"]
            #[inline]
            pub fn filten7(&self) -> FILTEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FILTEN7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Input Sense 0 Configuration"]
            #[inline]
            pub fn sense0(&mut self) -> _SENSE0W {
                _SENSE0W { w: self }
            }
            #[doc = "Bit 3 - Filter 0 Enable"]
            #[inline]
            pub fn filten0(&mut self) -> _FILTEN0W {
                _FILTEN0W { w: self }
            }
            #[doc = "Bits 4:6 - Input Sense 1 Configuration"]
            #[inline]
            pub fn sense1(&mut self) -> _SENSE1W {
                _SENSE1W { w: self }
            }
            #[doc = "Bit 7 - Filter 1 Enable"]
            #[inline]
            pub fn filten1(&mut self) -> _FILTEN1W {
                _FILTEN1W { w: self }
            }
            #[doc = "Bits 8:10 - Input Sense 2 Configuration"]
            #[inline]
            pub fn sense2(&mut self) -> _SENSE2W {
                _SENSE2W { w: self }
            }
            #[doc = "Bit 11 - Filter 2 Enable"]
            #[inline]
            pub fn filten2(&mut self) -> _FILTEN2W {
                _FILTEN2W { w: self }
            }
            #[doc = "Bits 12:14 - Input Sense 3 Configuration"]
            #[inline]
            pub fn sense3(&mut self) -> _SENSE3W {
                _SENSE3W { w: self }
            }
            #[doc = "Bit 15 - Filter 3 Enable"]
            #[inline]
            pub fn filten3(&mut self) -> _FILTEN3W {
                _FILTEN3W { w: self }
            }
            #[doc = "Bits 16:18 - Input Sense 4 Configuration"]
            #[inline]
            pub fn sense4(&mut self) -> _SENSE4W {
                _SENSE4W { w: self }
            }
            #[doc = "Bit 19 - Filter 4 Enable"]
            #[inline]
            pub fn filten4(&mut self) -> _FILTEN4W {
                _FILTEN4W { w: self }
            }
            #[doc = "Bits 20:22 - Input Sense 5 Configuration"]
            #[inline]
            pub fn sense5(&mut self) -> _SENSE5W {
                _SENSE5W { w: self }
            }
            #[doc = "Bit 23 - Filter 5 Enable"]
            #[inline]
            pub fn filten5(&mut self) -> _FILTEN5W {
                _FILTEN5W { w: self }
            }
            #[doc = "Bits 24:26 - Input Sense 6 Configuration"]
            #[inline]
            pub fn sense6(&mut self) -> _SENSE6W {
                _SENSE6W { w: self }
            }
            #[doc = "Bit 27 - Filter 6 Enable"]
            #[inline]
            pub fn filten6(&mut self) -> _FILTEN6W {
                _FILTEN6W { w: self }
            }
            #[doc = "Bits 28:30 - Input Sense 7 Configuration"]
            #[inline]
            pub fn sense7(&mut self) -> _SENSE7W {
                _SENSE7W { w: self }
            }
            #[doc = "Bit 31 - Filter 7 Enable"]
            #[inline]
            pub fn filten7(&mut self) -> _FILTEN7W {
                _FILTEN7W { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO0R {
            bits: bool,
        }
        impl EXTINTEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO1R {
            bits: bool,
        }
        impl EXTINTEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO2R {
            bits: bool,
        }
        impl EXTINTEO2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO3R {
            bits: bool,
        }
        impl EXTINTEO3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO4R {
            bits: bool,
        }
        impl EXTINTEO4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO5R {
            bits: bool,
        }
        impl EXTINTEO5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO6R {
            bits: bool,
        }
        impl EXTINTEO6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO7R {
            bits: bool,
        }
        impl EXTINTEO7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO8R {
            bits: bool,
        }
        impl EXTINTEO8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO9R {
            bits: bool,
        }
        impl EXTINTEO9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO10R {
            bits: bool,
        }
        impl EXTINTEO10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO11R {
            bits: bool,
        }
        impl EXTINTEO11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO12R {
            bits: bool,
        }
        impl EXTINTEO12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO13R {
            bits: bool,
        }
        impl EXTINTEO13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO14R {
            bits: bool,
        }
        impl EXTINTEO14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINTEO15R {
            bits: bool,
        }
        impl EXTINTEO15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINTEO15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINTEO15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
            #[inline]
            pub fn extinteo0(&self) -> EXTINTEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
            #[inline]
            pub fn extinteo1(&self) -> EXTINTEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
            #[inline]
            pub fn extinteo2(&self) -> EXTINTEO2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
            #[inline]
            pub fn extinteo3(&self) -> EXTINTEO3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
            #[inline]
            pub fn extinteo4(&self) -> EXTINTEO4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
            #[inline]
            pub fn extinteo5(&self) -> EXTINTEO5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
            #[inline]
            pub fn extinteo6(&self) -> EXTINTEO6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
            #[inline]
            pub fn extinteo7(&self) -> EXTINTEO7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
            #[inline]
            pub fn extinteo8(&self) -> EXTINTEO8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
            #[inline]
            pub fn extinteo9(&self) -> EXTINTEO9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
            #[inline]
            pub fn extinteo10(&self) -> EXTINTEO10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
            #[inline]
            pub fn extinteo11(&self) -> EXTINTEO11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
            #[inline]
            pub fn extinteo12(&self) -> EXTINTEO12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
            #[inline]
            pub fn extinteo13(&self) -> EXTINTEO13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
            #[inline]
            pub fn extinteo14(&self) -> EXTINTEO14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
            #[inline]
            pub fn extinteo15(&self) -> EXTINTEO15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINTEO15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
            #[inline]
            pub fn extinteo0(&mut self) -> _EXTINTEO0W {
                _EXTINTEO0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
            #[inline]
            pub fn extinteo1(&mut self) -> _EXTINTEO1W {
                _EXTINTEO1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
            #[inline]
            pub fn extinteo2(&mut self) -> _EXTINTEO2W {
                _EXTINTEO2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
            #[inline]
            pub fn extinteo3(&mut self) -> _EXTINTEO3W {
                _EXTINTEO3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
            #[inline]
            pub fn extinteo4(&mut self) -> _EXTINTEO4W {
                _EXTINTEO4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
            #[inline]
            pub fn extinteo5(&mut self) -> _EXTINTEO5W {
                _EXTINTEO5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
            #[inline]
            pub fn extinteo6(&mut self) -> _EXTINTEO6W {
                _EXTINTEO6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
            #[inline]
            pub fn extinteo7(&mut self) -> _EXTINTEO7W {
                _EXTINTEO7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
            #[inline]
            pub fn extinteo8(&mut self) -> _EXTINTEO8W {
                _EXTINTEO8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
            #[inline]
            pub fn extinteo9(&mut self) -> _EXTINTEO9W {
                _EXTINTEO9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
            #[inline]
            pub fn extinteo10(&mut self) -> _EXTINTEO10W {
                _EXTINTEO10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
            #[inline]
            pub fn extinteo11(&mut self) -> _EXTINTEO11W {
                _EXTINTEO11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
            #[inline]
            pub fn extinteo12(&mut self) -> _EXTINTEO12W {
                _EXTINTEO12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
            #[inline]
            pub fn extinteo13(&mut self) -> _EXTINTEO13W {
                _EXTINTEO13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
            #[inline]
            pub fn extinteo14(&mut self) -> _EXTINTEO14W {
                _EXTINTEO14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
            #[inline]
            pub fn extinteo15(&mut self) -> _EXTINTEO15W {
                _EXTINTEO15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Enable"]
            #[inline]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Enable"]
            #[inline]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Enable"]
            #[inline]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Enable"]
            #[inline]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Enable"]
            #[inline]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Enable"]
            #[inline]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Enable"]
            #[inline]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Enable"]
            #[inline]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Enable"]
            #[inline]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Enable"]
            #[inline]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Enable"]
            #[inline]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Enable"]
            #[inline]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Enable"]
            #[inline]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Enable"]
            #[inline]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Enable"]
            #[inline]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Enable"]
            #[inline]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT0R {
            bits: bool,
        }
        impl EXTINT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT1R {
            bits: bool,
        }
        impl EXTINT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT2R {
            bits: bool,
        }
        impl EXTINT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT3R {
            bits: bool,
        }
        impl EXTINT3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT4R {
            bits: bool,
        }
        impl EXTINT4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT5R {
            bits: bool,
        }
        impl EXTINT5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT6R {
            bits: bool,
        }
        impl EXTINT6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT7R {
            bits: bool,
        }
        impl EXTINT7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT8R {
            bits: bool,
        }
        impl EXTINT8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT9R {
            bits: bool,
        }
        impl EXTINT9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT10R {
            bits: bool,
        }
        impl EXTINT10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT11R {
            bits: bool,
        }
        impl EXTINT11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT12R {
            bits: bool,
        }
        impl EXTINT12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT13R {
            bits: bool,
        }
        impl EXTINT13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT14R {
            bits: bool,
        }
        impl EXTINT14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTINT15R {
            bits: bool,
        }
        impl EXTINT15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTINT15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTINT15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline]
            pub fn extint0(&self) -> EXTINT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline]
            pub fn extint1(&self) -> EXTINT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline]
            pub fn extint2(&self) -> EXTINT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline]
            pub fn extint3(&self) -> EXTINT3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline]
            pub fn extint4(&self) -> EXTINT4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline]
            pub fn extint5(&self) -> EXTINT5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline]
            pub fn extint6(&self) -> EXTINT6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline]
            pub fn extint7(&self) -> EXTINT7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline]
            pub fn extint8(&self) -> EXTINT8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline]
            pub fn extint9(&self) -> EXTINT9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10"]
            #[inline]
            pub fn extint10(&self) -> EXTINT10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11"]
            #[inline]
            pub fn extint11(&self) -> EXTINT11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12"]
            #[inline]
            pub fn extint12(&self) -> EXTINT12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13"]
            #[inline]
            pub fn extint13(&self) -> EXTINT13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14"]
            #[inline]
            pub fn extint14(&self) -> EXTINT14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15"]
            #[inline]
            pub fn extint15(&self) -> EXTINT15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTINT15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline]
            pub fn extint0(&mut self) -> _EXTINT0W {
                _EXTINT0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline]
            pub fn extint1(&mut self) -> _EXTINT1W {
                _EXTINT1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline]
            pub fn extint2(&mut self) -> _EXTINT2W {
                _EXTINT2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline]
            pub fn extint3(&mut self) -> _EXTINT3W {
                _EXTINT3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline]
            pub fn extint4(&mut self) -> _EXTINT4W {
                _EXTINT4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline]
            pub fn extint5(&mut self) -> _EXTINT5W {
                _EXTINT5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline]
            pub fn extint6(&mut self) -> _EXTINT6W {
                _EXTINT6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline]
            pub fn extint7(&mut self) -> _EXTINT7W {
                _EXTINT7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline]
            pub fn extint8(&mut self) -> _EXTINT8W {
                _EXTINT8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline]
            pub fn extint9(&mut self) -> _EXTINT9W {
                _EXTINT9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10"]
            #[inline]
            pub fn extint10(&mut self) -> _EXTINT10W {
                _EXTINT10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11"]
            #[inline]
            pub fn extint11(&mut self) -> _EXTINT11W {
                _EXTINT11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12"]
            #[inline]
            pub fn extint12(&mut self) -> _EXTINT12W {
                _EXTINT12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13"]
            #[inline]
            pub fn extint13(&mut self) -> _EXTINT13W {
                _EXTINT13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14"]
            #[inline]
            pub fn extint14(&mut self) -> _EXTINT14W {
                _EXTINT14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15"]
            #[inline]
            pub fn extint15(&mut self) -> _EXTINT15W {
                _EXTINT15W { w: self }
            }
        }
    }
    #[doc = "Non-Maskable Interrupt Control"]
    pub struct NMICTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Non-Maskable Interrupt Control"]
    pub mod nmictrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::NMICTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `NMISENSE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NMISENSER {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl NMISENSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    NMISENSER::NONE => 0,
                    NMISENSER::RISE => 0x01,
                    NMISENSER::FALL => 0x02,
                    NMISENSER::BOTH => 0x03,
                    NMISENSER::HIGH => 0x04,
                    NMISENSER::LOW => 0x05,
                    NMISENSER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> NMISENSER {
                match value {
                    0 => NMISENSER::NONE,
                    1 => NMISENSER::RISE,
                    2 => NMISENSER::FALL,
                    3 => NMISENSER::BOTH,
                    4 => NMISENSER::HIGH,
                    5 => NMISENSER::LOW,
                    i => NMISENSER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == NMISENSER::NONE
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline]
            pub fn is_rise(&self) -> bool {
                *self == NMISENSER::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline]
            pub fn is_fall(&self) -> bool {
                *self == NMISENSER::FALL
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline]
            pub fn is_both(&self) -> bool {
                *self == NMISENSER::BOTH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == NMISENSER::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == NMISENSER::LOW
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIFILTENR {
            bits: bool,
        }
        impl NMIFILTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `NMISENSE`"]
        pub enum NMISENSEW {
            #[doc = "No detection"]
            NONE,
            #[doc = "Rising-edge detection"]
            RISE,
            #[doc = "Falling-edge detection"]
            FALL,
            #[doc = "Both-edges detection"]
            BOTH,
            #[doc = "High-level detection"]
            HIGH,
            #[doc = "Low-level detection"]
            LOW,
        }
        impl NMISENSEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NMISENSEW::NONE => 0,
                    NMISENSEW::RISE => 1,
                    NMISENSEW::FALL => 2,
                    NMISENSEW::BOTH => 3,
                    NMISENSEW::HIGH => 4,
                    NMISENSEW::LOW => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMISENSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMISENSEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NMISENSEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No detection"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(NMISENSEW::NONE)
            }
            #[doc = "Rising-edge detection"]
            #[inline]
            pub fn rise(self) -> &'a mut W {
                self.variant(NMISENSEW::RISE)
            }
            #[doc = "Falling-edge detection"]
            #[inline]
            pub fn fall(self) -> &'a mut W {
                self.variant(NMISENSEW::FALL)
            }
            #[doc = "Both-edges detection"]
            #[inline]
            pub fn both(self) -> &'a mut W {
                self.variant(NMISENSEW::BOTH)
            }
            #[doc = "High-level detection"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(NMISENSEW::HIGH)
            }
            #[doc = "Low-level detection"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(NMISENSEW::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIFILTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIFILTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
            #[inline]
            pub fn nmisense(&self) -> NMISENSER {
                NMISENSER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
            #[inline]
            pub fn nmifilten(&self) -> NMIFILTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                NMIFILTENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
            #[inline]
            pub fn nmisense(&mut self) -> _NMISENSEW {
                _NMISENSEW { w: self }
            }
            #[doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
            #[inline]
            pub fn nmifilten(&mut self) -> _NMIFILTENW {
                _NMIFILTENW { w: self }
            }
        }
    }
    #[doc = "Non-Maskable Interrupt Flag Status and Clear"]
    pub struct NMIFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Non-Maskable Interrupt Flag Status and Clear"]
    pub mod nmiflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::NMIFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIR {
            bits: bool,
        }
        impl NMIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Non-Maskable Interrupt"]
            #[inline]
            pub fn nmi(&self) -> NMIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                NMIR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Non-Maskable Interrupt"]
            #[inline]
            pub fn nmi(&mut self) -> _NMIW {
                _NMIW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
    #[doc = "Wake-Up Enable"]
    pub struct WAKEUP {
        register: VolatileCell<u32>,
    }
    #[doc = "Wake-Up Enable"]
    pub mod wakeup {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WAKEUP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN0R {
            bits: bool,
        }
        impl WAKEUPEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN1R {
            bits: bool,
        }
        impl WAKEUPEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN2R {
            bits: bool,
        }
        impl WAKEUPEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN3R {
            bits: bool,
        }
        impl WAKEUPEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN4R {
            bits: bool,
        }
        impl WAKEUPEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN5R {
            bits: bool,
        }
        impl WAKEUPEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN6R {
            bits: bool,
        }
        impl WAKEUPEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN7R {
            bits: bool,
        }
        impl WAKEUPEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN8R {
            bits: bool,
        }
        impl WAKEUPEN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN9R {
            bits: bool,
        }
        impl WAKEUPEN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN10R {
            bits: bool,
        }
        impl WAKEUPEN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN11R {
            bits: bool,
        }
        impl WAKEUPEN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN12R {
            bits: bool,
        }
        impl WAKEUPEN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN13R {
            bits: bool,
        }
        impl WAKEUPEN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN14R {
            bits: bool,
        }
        impl WAKEUPEN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKEUPEN15R {
            bits: bool,
        }
        impl WAKEUPEN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPEN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPEN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
            #[inline]
            pub fn wakeupen0(&self) -> WAKEUPEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN0R { bits }
            }
            #[doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
            #[inline]
            pub fn wakeupen1(&self) -> WAKEUPEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN1R { bits }
            }
            #[doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
            #[inline]
            pub fn wakeupen2(&self) -> WAKEUPEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN2R { bits }
            }
            #[doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
            #[inline]
            pub fn wakeupen3(&self) -> WAKEUPEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN3R { bits }
            }
            #[doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
            #[inline]
            pub fn wakeupen4(&self) -> WAKEUPEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN4R { bits }
            }
            #[doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
            #[inline]
            pub fn wakeupen5(&self) -> WAKEUPEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN5R { bits }
            }
            #[doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
            #[inline]
            pub fn wakeupen6(&self) -> WAKEUPEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN6R { bits }
            }
            #[doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
            #[inline]
            pub fn wakeupen7(&self) -> WAKEUPEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN7R { bits }
            }
            #[doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
            #[inline]
            pub fn wakeupen8(&self) -> WAKEUPEN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN8R { bits }
            }
            #[doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
            #[inline]
            pub fn wakeupen9(&self) -> WAKEUPEN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN9R { bits }
            }
            #[doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
            #[inline]
            pub fn wakeupen10(&self) -> WAKEUPEN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN10R { bits }
            }
            #[doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
            #[inline]
            pub fn wakeupen11(&self) -> WAKEUPEN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN11R { bits }
            }
            #[doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
            #[inline]
            pub fn wakeupen12(&self) -> WAKEUPEN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN12R { bits }
            }
            #[doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
            #[inline]
            pub fn wakeupen13(&self) -> WAKEUPEN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN13R { bits }
            }
            #[doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
            #[inline]
            pub fn wakeupen14(&self) -> WAKEUPEN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN14R { bits }
            }
            #[doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
            #[inline]
            pub fn wakeupen15(&self) -> WAKEUPEN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKEUPEN15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
            #[inline]
            pub fn wakeupen0(&mut self) -> _WAKEUPEN0W {
                _WAKEUPEN0W { w: self }
            }
            #[doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
            #[inline]
            pub fn wakeupen1(&mut self) -> _WAKEUPEN1W {
                _WAKEUPEN1W { w: self }
            }
            #[doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
            #[inline]
            pub fn wakeupen2(&mut self) -> _WAKEUPEN2W {
                _WAKEUPEN2W { w: self }
            }
            #[doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
            #[inline]
            pub fn wakeupen3(&mut self) -> _WAKEUPEN3W {
                _WAKEUPEN3W { w: self }
            }
            #[doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
            #[inline]
            pub fn wakeupen4(&mut self) -> _WAKEUPEN4W {
                _WAKEUPEN4W { w: self }
            }
            #[doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
            #[inline]
            pub fn wakeupen5(&mut self) -> _WAKEUPEN5W {
                _WAKEUPEN5W { w: self }
            }
            #[doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
            #[inline]
            pub fn wakeupen6(&mut self) -> _WAKEUPEN6W {
                _WAKEUPEN6W { w: self }
            }
            #[doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
            #[inline]
            pub fn wakeupen7(&mut self) -> _WAKEUPEN7W {
                _WAKEUPEN7W { w: self }
            }
            #[doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
            #[inline]
            pub fn wakeupen8(&mut self) -> _WAKEUPEN8W {
                _WAKEUPEN8W { w: self }
            }
            #[doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
            #[inline]
            pub fn wakeupen9(&mut self) -> _WAKEUPEN9W {
                _WAKEUPEN9W { w: self }
            }
            #[doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
            #[inline]
            pub fn wakeupen10(&mut self) -> _WAKEUPEN10W {
                _WAKEUPEN10W { w: self }
            }
            #[doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
            #[inline]
            pub fn wakeupen11(&mut self) -> _WAKEUPEN11W {
                _WAKEUPEN11W { w: self }
            }
            #[doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
            #[inline]
            pub fn wakeupen12(&mut self) -> _WAKEUPEN12W {
                _WAKEUPEN12W { w: self }
            }
            #[doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
            #[inline]
            pub fn wakeupen13(&mut self) -> _WAKEUPEN13W {
                _WAKEUPEN13W { w: self }
            }
            #[doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
            #[inline]
            pub fn wakeupen14(&mut self) -> _WAKEUPEN14W {
                _WAKEUPEN14W { w: self }
            }
            #[doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
            #[inline]
            pub fn wakeupen15(&mut self) -> _WAKEUPEN15W {
                _WAKEUPEN15W { w: self }
            }
        }
    }
}
#[doc = "External Interrupt Controller"]
pub struct EIC {
    register_block: eic::RegisterBlock,
}
impl Deref for EIC {
    type Target = eic::RegisterBlock;
    fn deref(&self) -> &eic::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Event System Interface"]
pub const EVSYS: Peripheral<EVSYS> = unsafe { Peripheral::new(0x4200_0400) };
#[doc = "Event System Interface"]
pub mod evsys {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        _reserved0: [u8; 3usize],
        #[doc = "0x04 - Channel"]
        pub channel: CHANNEL,
        #[doc = "0x08 - User Multiplexer"]
        pub user: USER,
        _reserved1: [u8; 2usize],
        #[doc = "0x0c - Channel Status"]
        pub chstatus: CHSTATUS,
        #[doc = "0x10 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x18 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
    }
    #[doc = "Channel"]
    pub struct CHANNEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel"]
    pub mod channel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHANNEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELR {
            bits: u8,
        }
        impl CHANNELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWEVTR {
            bits: bool,
        }
        impl SWEVTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVGENR {
            bits: u8,
        }
        impl EVGENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PATH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PATHR {
            #[doc = "Synchronous path"]
            SYNCHRONOUS,
            #[doc = "Resynchronized path"]
            RESYNCHRONIZED,
            #[doc = "Asynchronous path"]
            ASYNCHRONOUS,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PATHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PATHR::SYNCHRONOUS => 0,
                    PATHR::RESYNCHRONIZED => 0x01,
                    PATHR::ASYNCHRONOUS => 0x02,
                    PATHR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PATHR {
                match value {
                    0 => PATHR::SYNCHRONOUS,
                    1 => PATHR::RESYNCHRONIZED,
                    2 => PATHR::ASYNCHRONOUS,
                    i => PATHR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SYNCHRONOUS`"]
            #[inline]
            pub fn is_synchronous(&self) -> bool {
                *self == PATHR::SYNCHRONOUS
            }
            #[doc = "Checks if the value of the field is `RESYNCHRONIZED`"]
            #[inline]
            pub fn is_resynchronized(&self) -> bool {
                *self == PATHR::RESYNCHRONIZED
            }
            #[doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
            #[inline]
            pub fn is_asynchronous(&self) -> bool {
                *self == PATHR::ASYNCHRONOUS
            }
        }
        #[doc = "Possible values of the field `EDGSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EDGSELR {
            #[doc = "No event output when using the resynchronized or synchronous path"]
            NO_EVT_OUTPUT,
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            RISING_EDGE,
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            FALLING_EDGE,
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            BOTH_EDGES,
        }
        impl EDGSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EDGSELR::NO_EVT_OUTPUT => 0,
                    EDGSELR::RISING_EDGE => 0x01,
                    EDGSELR::FALLING_EDGE => 0x02,
                    EDGSELR::BOTH_EDGES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EDGSELR {
                match value {
                    0 => EDGSELR::NO_EVT_OUTPUT,
                    1 => EDGSELR::RISING_EDGE,
                    2 => EDGSELR::FALLING_EDGE,
                    3 => EDGSELR::BOTH_EDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_EVT_OUTPUT`"]
            #[inline]
            pub fn is_no_evt_output(&self) -> bool {
                *self == EDGSELR::NO_EVT_OUTPUT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE`"]
            #[inline]
            pub fn is_rising_edge(&self) -> bool {
                *self == EDGSELR::RISING_EDGE
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE`"]
            #[inline]
            pub fn is_falling_edge(&self) -> bool {
                *self == EDGSELR::FALLING_EDGE
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES`"]
            #[inline]
            pub fn is_both_edges(&self) -> bool {
                *self == EDGSELR::BOTH_EDGES
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWEVTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWEVTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVGENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PATH`"]
        pub enum PATHW {
            #[doc = "Synchronous path"]
            SYNCHRONOUS,
            #[doc = "Resynchronized path"]
            RESYNCHRONIZED,
            #[doc = "Asynchronous path"]
            ASYNCHRONOUS,
        }
        impl PATHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PATHW::SYNCHRONOUS => 0,
                    PATHW::RESYNCHRONIZED => 1,
                    PATHW::ASYNCHRONOUS => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PATHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PATHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PATHW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Synchronous path"]
            #[inline]
            pub fn synchronous(self) -> &'a mut W {
                self.variant(PATHW::SYNCHRONOUS)
            }
            #[doc = "Resynchronized path"]
            #[inline]
            pub fn resynchronized(self) -> &'a mut W {
                self.variant(PATHW::RESYNCHRONIZED)
            }
            #[doc = "Asynchronous path"]
            #[inline]
            pub fn asynchronous(self) -> &'a mut W {
                self.variant(PATHW::ASYNCHRONOUS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EDGSEL`"]
        pub enum EDGSELW {
            #[doc = "No event output when using the resynchronized or synchronous path"]
            NO_EVT_OUTPUT,
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            RISING_EDGE,
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            FALLING_EDGE,
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            BOTH_EDGES,
        }
        impl EDGSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EDGSELW::NO_EVT_OUTPUT => 0,
                    EDGSELW::RISING_EDGE => 1,
                    EDGSELW::FALLING_EDGE => 2,
                    EDGSELW::BOTH_EDGES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EDGSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No event output when using the resynchronized or synchronous path"]
            #[inline]
            pub fn no_evt_output(self) -> &'a mut W {
                self.variant(EDGSELW::NO_EVT_OUTPUT)
            }
            #[doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(EDGSELW::RISING_EDGE)
            }
            #[doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(EDGSELW::FALLING_EDGE)
            }
            #[doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
            #[inline]
            pub fn both_edges(self) -> &'a mut W {
                self.variant(EDGSELW::BOTH_EDGES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Channel Selection"]
            #[inline]
            pub fn channel(&self) -> CHANNELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHANNELR { bits }
            }
            #[doc = "Bit 8 - Software Event"]
            #[inline]
            pub fn swevt(&self) -> SWEVTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWEVTR { bits }
            }
            #[doc = "Bits 16:21 - Event Generator Selection"]
            #[inline]
            pub fn evgen(&self) -> EVGENR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EVGENR { bits }
            }
            #[doc = "Bits 24:25 - Path Selection"]
            #[inline]
            pub fn path(&self) -> PATHR {
                PATHR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:27 - Edge Detection Selection"]
            #[inline]
            pub fn edgsel(&self) -> EDGSELR {
                EDGSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Channel Selection"]
            #[inline]
            pub fn channel(&mut self) -> _CHANNELW {
                _CHANNELW { w: self }
            }
            #[doc = "Bit 8 - Software Event"]
            #[inline]
            pub fn swevt(&mut self) -> _SWEVTW {
                _SWEVTW { w: self }
            }
            #[doc = "Bits 16:21 - Event Generator Selection"]
            #[inline]
            pub fn evgen(&mut self) -> _EVGENW {
                _EVGENW { w: self }
            }
            #[doc = "Bits 24:25 - Path Selection"]
            #[inline]
            pub fn path(&mut self) -> _PATHW {
                _PATHW { w: self }
            }
            #[doc = "Bits 26:27 - Edge Detection Selection"]
            #[inline]
            pub fn edgsel(&mut self) -> _EDGSELW {
                _EDGSELW { w: self }
            }
        }
    }
    #[doc = "Channel Status"]
    pub struct CHSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel Status"]
    pub mod chstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CHSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY0R {
            bits: bool,
        }
        impl USRRDY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY1R {
            bits: bool,
        }
        impl USRRDY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY2R {
            bits: bool,
        }
        impl USRRDY2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY3R {
            bits: bool,
        }
        impl USRRDY3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY4R {
            bits: bool,
        }
        impl USRRDY4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY5R {
            bits: bool,
        }
        impl USRRDY5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY6R {
            bits: bool,
        }
        impl USRRDY6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USRRDY7R {
            bits: bool,
        }
        impl USRRDY7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY0R {
            bits: bool,
        }
        impl CHBUSY0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY1R {
            bits: bool,
        }
        impl CHBUSY1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY2R {
            bits: bool,
        }
        impl CHBUSY2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY3R {
            bits: bool,
        }
        impl CHBUSY3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY4R {
            bits: bool,
        }
        impl CHBUSY4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY5R {
            bits: bool,
        }
        impl CHBUSY5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY6R {
            bits: bool,
        }
        impl CHBUSY6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHBUSY7R {
            bits: bool,
        }
        impl CHBUSY7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 User Ready"]
            #[inline]
            pub fn usrrdy0(&self) -> USRRDY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 User Ready"]
            #[inline]
            pub fn usrrdy1(&self) -> USRRDY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 User Ready"]
            #[inline]
            pub fn usrrdy2(&self) -> USRRDY2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 User Ready"]
            #[inline]
            pub fn usrrdy3(&self) -> USRRDY3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 User Ready"]
            #[inline]
            pub fn usrrdy4(&self) -> USRRDY4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 User Ready"]
            #[inline]
            pub fn usrrdy5(&self) -> USRRDY5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 User Ready"]
            #[inline]
            pub fn usrrdy6(&self) -> USRRDY6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 User Ready"]
            #[inline]
            pub fn usrrdy7(&self) -> USRRDY7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USRRDY7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Busy"]
            #[inline]
            pub fn chbusy0(&self) -> CHBUSY0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Busy"]
            #[inline]
            pub fn chbusy1(&self) -> CHBUSY1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Busy"]
            #[inline]
            pub fn chbusy2(&self) -> CHBUSY2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Busy"]
            #[inline]
            pub fn chbusy3(&self) -> CHBUSY3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Busy"]
            #[inline]
            pub fn chbusy4(&self) -> CHBUSY4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Busy"]
            #[inline]
            pub fn chbusy5(&self) -> CHBUSY5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Busy"]
            #[inline]
            pub fn chbusy6(&self) -> CHBUSY6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Busy"]
            #[inline]
            pub fn chbusy7(&self) -> CHBUSY7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CHBUSY7R { bits }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCLKREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCLKREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 4 - Generic Clock Requests"]
            #[inline]
            pub fn gclkreq(&mut self) -> _GCLKREQW {
                _GCLKREQW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
            #[inline]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
            #[inline]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR0R {
            bits: bool,
        }
        impl OVR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR1R {
            bits: bool,
        }
        impl OVR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR2R {
            bits: bool,
        }
        impl OVR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR3R {
            bits: bool,
        }
        impl OVR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR4R {
            bits: bool,
        }
        impl OVR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR5R {
            bits: bool,
        }
        impl OVR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR6R {
            bits: bool,
        }
        impl OVR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVR7R {
            bits: bool,
        }
        impl OVR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD0R {
            bits: bool,
        }
        impl EVD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD1R {
            bits: bool,
        }
        impl EVD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD2R {
            bits: bool,
        }
        impl EVD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD3R {
            bits: bool,
        }
        impl EVD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD4R {
            bits: bool,
        }
        impl EVD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD5R {
            bits: bool,
        }
        impl EVD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD6R {
            bits: bool,
        }
        impl EVD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVD7R {
            bits: bool,
        }
        impl EVD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 0 Overrun"]
            #[inline]
            pub fn ovr0(&self) -> OVR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR0R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Overrun"]
            #[inline]
            pub fn ovr1(&self) -> OVR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR1R { bits }
            }
            #[doc = "Bit 2 - Channel 2 Overrun"]
            #[inline]
            pub fn ovr2(&self) -> OVR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR2R { bits }
            }
            #[doc = "Bit 3 - Channel 3 Overrun"]
            #[inline]
            pub fn ovr3(&self) -> OVR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR3R { bits }
            }
            #[doc = "Bit 4 - Channel 4 Overrun"]
            #[inline]
            pub fn ovr4(&self) -> OVR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR4R { bits }
            }
            #[doc = "Bit 5 - Channel 5 Overrun"]
            #[inline]
            pub fn ovr5(&self) -> OVR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR5R { bits }
            }
            #[doc = "Bit 6 - Channel 6 Overrun"]
            #[inline]
            pub fn ovr6(&self) -> OVR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR6R { bits }
            }
            #[doc = "Bit 7 - Channel 7 Overrun"]
            #[inline]
            pub fn ovr7(&self) -> OVR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVR7R { bits }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection"]
            #[inline]
            pub fn evd0(&self) -> EVD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD0R { bits }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection"]
            #[inline]
            pub fn evd1(&self) -> EVD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD1R { bits }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection"]
            #[inline]
            pub fn evd2(&self) -> EVD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD2R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection"]
            #[inline]
            pub fn evd3(&self) -> EVD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection"]
            #[inline]
            pub fn evd4(&self) -> EVD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD4R { bits }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection"]
            #[inline]
            pub fn evd5(&self) -> EVD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD5R { bits }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection"]
            #[inline]
            pub fn evd6(&self) -> EVD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD6R { bits }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection"]
            #[inline]
            pub fn evd7(&self) -> EVD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVD7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 0 Overrun"]
            #[inline]
            pub fn ovr0(&mut self) -> _OVR0W {
                _OVR0W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Overrun"]
            #[inline]
            pub fn ovr1(&mut self) -> _OVR1W {
                _OVR1W { w: self }
            }
            #[doc = "Bit 2 - Channel 2 Overrun"]
            #[inline]
            pub fn ovr2(&mut self) -> _OVR2W {
                _OVR2W { w: self }
            }
            #[doc = "Bit 3 - Channel 3 Overrun"]
            #[inline]
            pub fn ovr3(&mut self) -> _OVR3W {
                _OVR3W { w: self }
            }
            #[doc = "Bit 4 - Channel 4 Overrun"]
            #[inline]
            pub fn ovr4(&mut self) -> _OVR4W {
                _OVR4W { w: self }
            }
            #[doc = "Bit 5 - Channel 5 Overrun"]
            #[inline]
            pub fn ovr5(&mut self) -> _OVR5W {
                _OVR5W { w: self }
            }
            #[doc = "Bit 6 - Channel 6 Overrun"]
            #[inline]
            pub fn ovr6(&mut self) -> _OVR6W {
                _OVR6W { w: self }
            }
            #[doc = "Bit 7 - Channel 7 Overrun"]
            #[inline]
            pub fn ovr7(&mut self) -> _OVR7W {
                _OVR7W { w: self }
            }
            #[doc = "Bit 8 - Channel 0 Event Detection"]
            #[inline]
            pub fn evd0(&mut self) -> _EVD0W {
                _EVD0W { w: self }
            }
            #[doc = "Bit 9 - Channel 1 Event Detection"]
            #[inline]
            pub fn evd1(&mut self) -> _EVD1W {
                _EVD1W { w: self }
            }
            #[doc = "Bit 10 - Channel 2 Event Detection"]
            #[inline]
            pub fn evd2(&mut self) -> _EVD2W {
                _EVD2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Event Detection"]
            #[inline]
            pub fn evd3(&mut self) -> _EVD3W {
                _EVD3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Event Detection"]
            #[inline]
            pub fn evd4(&mut self) -> _EVD4W {
                _EVD4W { w: self }
            }
            #[doc = "Bit 13 - Channel 5 Event Detection"]
            #[inline]
            pub fn evd5(&mut self) -> _EVD5W {
                _EVD5W { w: self }
            }
            #[doc = "Bit 14 - Channel 6 Event Detection"]
            #[inline]
            pub fn evd6(&mut self) -> _EVD6W {
                _EVD6W { w: self }
            }
            #[doc = "Bit 15 - Channel 7 Event Detection"]
            #[inline]
            pub fn evd7(&mut self) -> _EVD7W {
                _EVD7W { w: self }
            }
        }
    }
    #[doc = "User Multiplexer"]
    pub struct USER {
        register: VolatileCell<u16>,
    }
    #[doc = "User Multiplexer"]
    pub mod user {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::USER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct USERR {
            bits: u8,
        }
        impl USERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANNELR {
            bits: u8,
        }
        impl CHANNELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _USERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHANNELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHANNELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:3 - User Multiplexer Selection"]
            #[inline]
            pub fn user(&self) -> USERR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                USERR { bits }
            }
            #[doc = "Bits 8:11 - Channel Event Selection"]
            #[inline]
            pub fn channel(&self) -> CHANNELR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CHANNELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - User Multiplexer Selection"]
            #[inline]
            pub fn user(&mut self) -> _USERW {
                _USERW { w: self }
            }
            #[doc = "Bits 8:11 - Channel Event Selection"]
            #[inline]
            pub fn channel(&mut self) -> _CHANNELW {
                _CHANNELW { w: self }
            }
        }
    }
}
#[doc = "Event System Interface"]
pub struct EVSYS {
    register_block: evsys::RegisterBlock,
}
impl Deref for EVSYS {
    type Target = evsys::RegisterBlock;
    fn deref(&self) -> &evsys::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Generic Clock Generator"]
pub const GCLK: Peripheral<GCLK> = unsafe { Peripheral::new(0x4000_0c00) };
#[doc = "Generic Clock Generator"]
pub mod gclk {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Status"]
        pub status: STATUS,
        #[doc = "0x02 - Generic Clock Control"]
        pub clkctrl: CLKCTRL,
        #[doc = "0x04 - Generic Clock Generator Control"]
        pub genctrl: GENCTRL,
        #[doc = "0x08 - Generic Clock Generator Division"]
        pub gendiv: GENDIV,
    }
    #[doc = "Generic Clock Control"]
    pub struct CLKCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Generic Clock Control"]
    pub mod clkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR {
            #[doc = "DFLL48M Reference"]
            DFLL48M,
            #[doc = "WDT"]
            WDT,
            #[doc = "RTC"]
            RTC,
            #[doc = "EIC"]
            EIC,
            #[doc = "EVSYS_CHANNEL_0"]
            EVSYS_CHANNEL_0,
            #[doc = "EVSYS_CHANNEL_1"]
            EVSYS_CHANNEL_1,
            #[doc = "EVSYS_CHANNEL_2"]
            EVSYS_CHANNEL_2,
            #[doc = "EVSYS_CHANNEL_3"]
            EVSYS_CHANNEL_3,
            #[doc = "EVSYS_CHANNEL_4"]
            EVSYS_CHANNEL_4,
            #[doc = "EVSYS_CHANNEL_5"]
            EVSYS_CHANNEL_5,
            #[doc = "EVSYS_CHANNEL_6"]
            EVSYS_CHANNEL_6,
            #[doc = "EVSYS_CHANNEL_7"]
            EVSYS_CHANNEL_7,
            #[doc = "SERCOMx_SLOW"]
            SERCOMX_SLOW,
            #[doc = "SERCOM0_CORE"]
            SERCOM0_CORE,
            #[doc = "SERCOM1_CORE"]
            SERCOM1_CORE,
            #[doc = "SERCOM2_CORE"]
            SERCOM2_CORE,
            #[doc = "SERCOM3_CORE"]
            SERCOM3_CORE,
            #[doc = "SERCOM4_CORE"]
            SERCOM4_CORE,
            #[doc = "SERCOM5_CORE"]
            SERCOM5_CORE,
            #[doc = "TC0,TC1"]
            TC0_TC1,
            #[doc = "TC2,TC3"]
            TC2_TC3,
            #[doc = "TC4,TC5"]
            TC4_TC5,
            #[doc = "TC6,TC7"]
            TC6_TC7,
            #[doc = "ADC"]
            ADC,
            #[doc = "AC_DIG"]
            AC_DIG,
            #[doc = "AC_ANA"]
            AC_ANA,
            #[doc = "DAC"]
            DAC,
            #[doc = "PTC"]
            PTC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDR::DFLL48M => 0,
                    IDR::WDT => 0x01,
                    IDR::RTC => 0x02,
                    IDR::EIC => 0x03,
                    IDR::EVSYS_CHANNEL_0 => 0x04,
                    IDR::EVSYS_CHANNEL_1 => 0x05,
                    IDR::EVSYS_CHANNEL_2 => 0x06,
                    IDR::EVSYS_CHANNEL_3 => 0x07,
                    IDR::EVSYS_CHANNEL_4 => 0x08,
                    IDR::EVSYS_CHANNEL_5 => 0x09,
                    IDR::EVSYS_CHANNEL_6 => 0x0a,
                    IDR::EVSYS_CHANNEL_7 => 0x0b,
                    IDR::SERCOMX_SLOW => 0x0c,
                    IDR::SERCOM0_CORE => 0x0d,
                    IDR::SERCOM1_CORE => 0x0e,
                    IDR::SERCOM2_CORE => 0x0f,
                    IDR::SERCOM3_CORE => 0x10,
                    IDR::SERCOM4_CORE => 0x11,
                    IDR::SERCOM5_CORE => 0x12,
                    IDR::TC0_TC1 => 0x13,
                    IDR::TC2_TC3 => 0x14,
                    IDR::TC4_TC5 => 0x15,
                    IDR::TC6_TC7 => 0x16,
                    IDR::ADC => 0x17,
                    IDR::AC_DIG => 0x18,
                    IDR::AC_ANA => 0x19,
                    IDR::DAC => 0x1a,
                    IDR::PTC => 0x1b,
                    IDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IDR {
                match value {
                    0 => IDR::DFLL48M,
                    1 => IDR::WDT,
                    2 => IDR::RTC,
                    3 => IDR::EIC,
                    4 => IDR::EVSYS_CHANNEL_0,
                    5 => IDR::EVSYS_CHANNEL_1,
                    6 => IDR::EVSYS_CHANNEL_2,
                    7 => IDR::EVSYS_CHANNEL_3,
                    8 => IDR::EVSYS_CHANNEL_4,
                    9 => IDR::EVSYS_CHANNEL_5,
                    10 => IDR::EVSYS_CHANNEL_6,
                    11 => IDR::EVSYS_CHANNEL_7,
                    12 => IDR::SERCOMX_SLOW,
                    13 => IDR::SERCOM0_CORE,
                    14 => IDR::SERCOM1_CORE,
                    15 => IDR::SERCOM2_CORE,
                    16 => IDR::SERCOM3_CORE,
                    17 => IDR::SERCOM4_CORE,
                    18 => IDR::SERCOM5_CORE,
                    19 => IDR::TC0_TC1,
                    20 => IDR::TC2_TC3,
                    21 => IDR::TC4_TC5,
                    22 => IDR::TC6_TC7,
                    23 => IDR::ADC,
                    24 => IDR::AC_DIG,
                    25 => IDR::AC_ANA,
                    26 => IDR::DAC,
                    27 => IDR::PTC,
                    i => IDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DFLL48M`"]
            #[inline]
            pub fn is_dfll48m(&self) -> bool {
                *self == IDR::DFLL48M
            }
            #[doc = "Checks if the value of the field is `WDT`"]
            #[inline]
            pub fn is_wdt(&self) -> bool {
                *self == IDR::WDT
            }
            #[doc = "Checks if the value of the field is `RTC`"]
            #[inline]
            pub fn is_rtc(&self) -> bool {
                *self == IDR::RTC
            }
            #[doc = "Checks if the value of the field is `EIC`"]
            #[inline]
            pub fn is_eic(&self) -> bool {
                *self == IDR::EIC
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_0`"]
            #[inline]
            pub fn is_evsys_channel_0(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_0
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_1`"]
            #[inline]
            pub fn is_evsys_channel_1(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_1
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_2`"]
            #[inline]
            pub fn is_evsys_channel_2(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_2
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_3`"]
            #[inline]
            pub fn is_evsys_channel_3(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_3
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_4`"]
            #[inline]
            pub fn is_evsys_channel_4(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_4
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_5`"]
            #[inline]
            pub fn is_evsys_channel_5(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_5
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_6`"]
            #[inline]
            pub fn is_evsys_channel_6(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_6
            }
            #[doc = "Checks if the value of the field is `EVSYS_CHANNEL_7`"]
            #[inline]
            pub fn is_evsys_channel_7(&self) -> bool {
                *self == IDR::EVSYS_CHANNEL_7
            }
            #[doc = "Checks if the value of the field is `SERCOMX_SLOW`"]
            #[inline]
            pub fn is_sercomx_slow(&self) -> bool {
                *self == IDR::SERCOMX_SLOW
            }
            #[doc = "Checks if the value of the field is `SERCOM0_CORE`"]
            #[inline]
            pub fn is_sercom0_core(&self) -> bool {
                *self == IDR::SERCOM0_CORE
            }
            #[doc = "Checks if the value of the field is `SERCOM1_CORE`"]
            #[inline]
            pub fn is_sercom1_core(&self) -> bool {
                *self == IDR::SERCOM1_CORE
            }
            #[doc = "Checks if the value of the field is `SERCOM2_CORE`"]
            #[inline]
            pub fn is_sercom2_core(&self) -> bool {
                *self == IDR::SERCOM2_CORE
            }
            #[doc = "Checks if the value of the field is `SERCOM3_CORE`"]
            #[inline]
            pub fn is_sercom3_core(&self) -> bool {
                *self == IDR::SERCOM3_CORE
            }
            #[doc = "Checks if the value of the field is `SERCOM4_CORE`"]
            #[inline]
            pub fn is_sercom4_core(&self) -> bool {
                *self == IDR::SERCOM4_CORE
            }
            #[doc = "Checks if the value of the field is `SERCOM5_CORE`"]
            #[inline]
            pub fn is_sercom5_core(&self) -> bool {
                *self == IDR::SERCOM5_CORE
            }
            #[doc = "Checks if the value of the field is `TC0_TC1`"]
            #[inline]
            pub fn is_tc0_tc1(&self) -> bool {
                *self == IDR::TC0_TC1
            }
            #[doc = "Checks if the value of the field is `TC2_TC3`"]
            #[inline]
            pub fn is_tc2_tc3(&self) -> bool {
                *self == IDR::TC2_TC3
            }
            #[doc = "Checks if the value of the field is `TC4_TC5`"]
            #[inline]
            pub fn is_tc4_tc5(&self) -> bool {
                *self == IDR::TC4_TC5
            }
            #[doc = "Checks if the value of the field is `TC6_TC7`"]
            #[inline]
            pub fn is_tc6_tc7(&self) -> bool {
                *self == IDR::TC6_TC7
            }
            #[doc = "Checks if the value of the field is `ADC`"]
            #[inline]
            pub fn is_adc(&self) -> bool {
                *self == IDR::ADC
            }
            #[doc = "Checks if the value of the field is `AC_DIG`"]
            #[inline]
            pub fn is_ac_dig(&self) -> bool {
                *self == IDR::AC_DIG
            }
            #[doc = "Checks if the value of the field is `AC_ANA`"]
            #[inline]
            pub fn is_ac_ana(&self) -> bool {
                *self == IDR::AC_ANA
            }
            #[doc = "Checks if the value of the field is `DAC`"]
            #[inline]
            pub fn is_dac(&self) -> bool {
                *self == IDR::DAC
            }
            #[doc = "Checks if the value of the field is `PTC`"]
            #[inline]
            pub fn is_ptc(&self) -> bool {
                *self == IDR::PTC
            }
        }
        #[doc = "Possible values of the field `GEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GENR {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    GENR::GCLK0 => 0,
                    GENR::GCLK1 => 0x01,
                    GENR::GCLK2 => 0x02,
                    GENR::GCLK3 => 0x03,
                    GENR::GCLK4 => 0x04,
                    GENR::GCLK5 => 0x05,
                    GENR::GCLK6 => 0x06,
                    GENR::GCLK7 => 0x07,
                    GENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> GENR {
                match value {
                    0 => GENR::GCLK0,
                    1 => GENR::GCLK1,
                    2 => GENR::GCLK2,
                    3 => GENR::GCLK3,
                    4 => GENR::GCLK4,
                    5 => GENR::GCLK5,
                    6 => GENR::GCLK6,
                    7 => GENR::GCLK7,
                    i => GENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK0`"]
            #[inline]
            pub fn is_gclk0(&self) -> bool {
                *self == GENR::GCLK0
            }
            #[doc = "Checks if the value of the field is `GCLK1`"]
            #[inline]
            pub fn is_gclk1(&self) -> bool {
                *self == GENR::GCLK1
            }
            #[doc = "Checks if the value of the field is `GCLK2`"]
            #[inline]
            pub fn is_gclk2(&self) -> bool {
                *self == GENR::GCLK2
            }
            #[doc = "Checks if the value of the field is `GCLK3`"]
            #[inline]
            pub fn is_gclk3(&self) -> bool {
                *self == GENR::GCLK3
            }
            #[doc = "Checks if the value of the field is `GCLK4`"]
            #[inline]
            pub fn is_gclk4(&self) -> bool {
                *self == GENR::GCLK4
            }
            #[doc = "Checks if the value of the field is `GCLK5`"]
            #[inline]
            pub fn is_gclk5(&self) -> bool {
                *self == GENR::GCLK5
            }
            #[doc = "Checks if the value of the field is `GCLK6`"]
            #[inline]
            pub fn is_gclk6(&self) -> bool {
                *self == GENR::GCLK6
            }
            #[doc = "Checks if the value of the field is `GCLK7`"]
            #[inline]
            pub fn is_gclk7(&self) -> bool {
                *self == GENR::GCLK7
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKENR {
            bits: bool,
        }
        impl CLKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `ID`"]
        pub enum IDW {
            #[doc = "DFLL48M Reference"]
            DFLL48M,
            #[doc = "WDT"]
            WDT,
            #[doc = "RTC"]
            RTC,
            #[doc = "EIC"]
            EIC,
            #[doc = "EVSYS_CHANNEL_0"]
            EVSYS_CHANNEL_0,
            #[doc = "EVSYS_CHANNEL_1"]
            EVSYS_CHANNEL_1,
            #[doc = "EVSYS_CHANNEL_2"]
            EVSYS_CHANNEL_2,
            #[doc = "EVSYS_CHANNEL_3"]
            EVSYS_CHANNEL_3,
            #[doc = "EVSYS_CHANNEL_4"]
            EVSYS_CHANNEL_4,
            #[doc = "EVSYS_CHANNEL_5"]
            EVSYS_CHANNEL_5,
            #[doc = "EVSYS_CHANNEL_6"]
            EVSYS_CHANNEL_6,
            #[doc = "EVSYS_CHANNEL_7"]
            EVSYS_CHANNEL_7,
            #[doc = "SERCOMx_SLOW"]
            SERCOMX_SLOW,
            #[doc = "SERCOM0_CORE"]
            SERCOM0_CORE,
            #[doc = "SERCOM1_CORE"]
            SERCOM1_CORE,
            #[doc = "SERCOM2_CORE"]
            SERCOM2_CORE,
            #[doc = "SERCOM3_CORE"]
            SERCOM3_CORE,
            #[doc = "SERCOM4_CORE"]
            SERCOM4_CORE,
            #[doc = "SERCOM5_CORE"]
            SERCOM5_CORE,
            #[doc = "TC0,TC1"]
            TC0_TC1,
            #[doc = "TC2,TC3"]
            TC2_TC3,
            #[doc = "TC4,TC5"]
            TC4_TC5,
            #[doc = "TC6,TC7"]
            TC6_TC7,
            #[doc = "ADC"]
            ADC,
            #[doc = "AC_DIG"]
            AC_DIG,
            #[doc = "AC_ANA"]
            AC_ANA,
            #[doc = "DAC"]
            DAC,
            #[doc = "PTC"]
            PTC,
        }
        impl IDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDW::DFLL48M => 0,
                    IDW::WDT => 1,
                    IDW::RTC => 2,
                    IDW::EIC => 3,
                    IDW::EVSYS_CHANNEL_0 => 4,
                    IDW::EVSYS_CHANNEL_1 => 5,
                    IDW::EVSYS_CHANNEL_2 => 6,
                    IDW::EVSYS_CHANNEL_3 => 7,
                    IDW::EVSYS_CHANNEL_4 => 8,
                    IDW::EVSYS_CHANNEL_5 => 9,
                    IDW::EVSYS_CHANNEL_6 => 10,
                    IDW::EVSYS_CHANNEL_7 => 11,
                    IDW::SERCOMX_SLOW => 12,
                    IDW::SERCOM0_CORE => 13,
                    IDW::SERCOM1_CORE => 14,
                    IDW::SERCOM2_CORE => 15,
                    IDW::SERCOM3_CORE => 16,
                    IDW::SERCOM4_CORE => 17,
                    IDW::SERCOM5_CORE => 18,
                    IDW::TC0_TC1 => 19,
                    IDW::TC2_TC3 => 20,
                    IDW::TC4_TC5 => 21,
                    IDW::TC6_TC7 => 22,
                    IDW::ADC => 23,
                    IDW::AC_DIG => 24,
                    IDW::AC_ANA => 25,
                    IDW::DAC => 26,
                    IDW::PTC => 27,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "DFLL48M Reference"]
            #[inline]
            pub fn dfll48m(self) -> &'a mut W {
                self.variant(IDW::DFLL48M)
            }
            #[doc = "WDT"]
            #[inline]
            pub fn wdt(self) -> &'a mut W {
                self.variant(IDW::WDT)
            }
            #[doc = "RTC"]
            #[inline]
            pub fn rtc(self) -> &'a mut W {
                self.variant(IDW::RTC)
            }
            #[doc = "EIC"]
            #[inline]
            pub fn eic(self) -> &'a mut W {
                self.variant(IDW::EIC)
            }
            #[doc = "EVSYS_CHANNEL_0"]
            #[inline]
            pub fn evsys_channel_0(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_0)
            }
            #[doc = "EVSYS_CHANNEL_1"]
            #[inline]
            pub fn evsys_channel_1(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_1)
            }
            #[doc = "EVSYS_CHANNEL_2"]
            #[inline]
            pub fn evsys_channel_2(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_2)
            }
            #[doc = "EVSYS_CHANNEL_3"]
            #[inline]
            pub fn evsys_channel_3(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_3)
            }
            #[doc = "EVSYS_CHANNEL_4"]
            #[inline]
            pub fn evsys_channel_4(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_4)
            }
            #[doc = "EVSYS_CHANNEL_5"]
            #[inline]
            pub fn evsys_channel_5(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_5)
            }
            #[doc = "EVSYS_CHANNEL_6"]
            #[inline]
            pub fn evsys_channel_6(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_6)
            }
            #[doc = "EVSYS_CHANNEL_7"]
            #[inline]
            pub fn evsys_channel_7(self) -> &'a mut W {
                self.variant(IDW::EVSYS_CHANNEL_7)
            }
            #[doc = "SERCOMx_SLOW"]
            #[inline]
            pub fn sercomx_slow(self) -> &'a mut W {
                self.variant(IDW::SERCOMX_SLOW)
            }
            #[doc = "SERCOM0_CORE"]
            #[inline]
            pub fn sercom0_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM0_CORE)
            }
            #[doc = "SERCOM1_CORE"]
            #[inline]
            pub fn sercom1_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM1_CORE)
            }
            #[doc = "SERCOM2_CORE"]
            #[inline]
            pub fn sercom2_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM2_CORE)
            }
            #[doc = "SERCOM3_CORE"]
            #[inline]
            pub fn sercom3_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM3_CORE)
            }
            #[doc = "SERCOM4_CORE"]
            #[inline]
            pub fn sercom4_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM4_CORE)
            }
            #[doc = "SERCOM5_CORE"]
            #[inline]
            pub fn sercom5_core(self) -> &'a mut W {
                self.variant(IDW::SERCOM5_CORE)
            }
            #[doc = "TC0,TC1"]
            #[inline]
            pub fn tc0_tc1(self) -> &'a mut W {
                self.variant(IDW::TC0_TC1)
            }
            #[doc = "TC2,TC3"]
            #[inline]
            pub fn tc2_tc3(self) -> &'a mut W {
                self.variant(IDW::TC2_TC3)
            }
            #[doc = "TC4,TC5"]
            #[inline]
            pub fn tc4_tc5(self) -> &'a mut W {
                self.variant(IDW::TC4_TC5)
            }
            #[doc = "TC6,TC7"]
            #[inline]
            pub fn tc6_tc7(self) -> &'a mut W {
                self.variant(IDW::TC6_TC7)
            }
            #[doc = "ADC"]
            #[inline]
            pub fn adc(self) -> &'a mut W {
                self.variant(IDW::ADC)
            }
            #[doc = "AC_DIG"]
            #[inline]
            pub fn ac_dig(self) -> &'a mut W {
                self.variant(IDW::AC_DIG)
            }
            #[doc = "AC_ANA"]
            #[inline]
            pub fn ac_ana(self) -> &'a mut W {
                self.variant(IDW::AC_ANA)
            }
            #[doc = "DAC"]
            #[inline]
            pub fn dac(self) -> &'a mut W {
                self.variant(IDW::DAC)
            }
            #[doc = "PTC"]
            #[inline]
            pub fn ptc(self) -> &'a mut W {
                self.variant(IDW::PTC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GEN`"]
        pub enum GENW {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
        }
        impl GENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GENW::GCLK0 => 0,
                    GENW::GCLK1 => 1,
                    GENW::GCLK2 => 2,
                    GENW::GCLK3 => 3,
                    GENW::GCLK4 => 4,
                    GENW::GCLK5 => 5,
                    GENW::GCLK6 => 6,
                    GENW::GCLK7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Generic clock generator 0"]
            #[inline]
            pub fn gclk0(self) -> &'a mut W {
                self.variant(GENW::GCLK0)
            }
            #[doc = "Generic clock generator 1"]
            #[inline]
            pub fn gclk1(self) -> &'a mut W {
                self.variant(GENW::GCLK1)
            }
            #[doc = "Generic clock generator 2"]
            #[inline]
            pub fn gclk2(self) -> &'a mut W {
                self.variant(GENW::GCLK2)
            }
            #[doc = "Generic clock generator 3"]
            #[inline]
            pub fn gclk3(self) -> &'a mut W {
                self.variant(GENW::GCLK3)
            }
            #[doc = "Generic clock generator 4"]
            #[inline]
            pub fn gclk4(self) -> &'a mut W {
                self.variant(GENW::GCLK4)
            }
            #[doc = "Generic clock generator 5"]
            #[inline]
            pub fn gclk5(self) -> &'a mut W {
                self.variant(GENW::GCLK5)
            }
            #[doc = "Generic clock generator 6"]
            #[inline]
            pub fn gclk6(self) -> &'a mut W {
                self.variant(GENW::GCLK6)
            }
            #[doc = "Generic clock generator 7"]
            #[inline]
            pub fn gclk7(self) -> &'a mut W {
                self.variant(GENW::GCLK7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:5 - Generic Clock Selection ID"]
            #[inline]
            pub fn id(&self) -> IDR {
                IDR::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:11 - Generic Clock Generator"]
            #[inline]
            pub fn gen(&self) -> GENR {
                GENR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 14 - Clock Enable"]
            #[inline]
            pub fn clken(&self) -> CLKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CLKENR { bits }
            }
            #[doc = "Bit 15 - Write Lock"]
            #[inline]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Generic Clock Selection ID"]
            #[inline]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:11 - Generic Clock Generator"]
            #[inline]
            pub fn gen(&mut self) -> _GENW {
                _GENW { w: self }
            }
            #[doc = "Bit 14 - Clock Enable"]
            #[inline]
            pub fn clken(&mut self) -> _CLKENW {
                _CLKENW { w: self }
            }
            #[doc = "Bit 15 - Write Lock"]
            #[inline]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SWRSTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
        }
    }
    #[doc = "Generic Clock Generator Control"]
    pub struct GENCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Generic Clock Generator Control"]
    pub mod genctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GENCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDR::GCLK0 => 0,
                    IDR::GCLK1 => 0x01,
                    IDR::GCLK2 => 0x02,
                    IDR::GCLK3 => 0x03,
                    IDR::GCLK4 => 0x04,
                    IDR::GCLK5 => 0x05,
                    IDR::GCLK6 => 0x06,
                    IDR::GCLK7 => 0x07,
                    IDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IDR {
                match value {
                    0 => IDR::GCLK0,
                    1 => IDR::GCLK1,
                    2 => IDR::GCLK2,
                    3 => IDR::GCLK3,
                    4 => IDR::GCLK4,
                    5 => IDR::GCLK5,
                    6 => IDR::GCLK6,
                    7 => IDR::GCLK7,
                    i => IDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK0`"]
            #[inline]
            pub fn is_gclk0(&self) -> bool {
                *self == IDR::GCLK0
            }
            #[doc = "Checks if the value of the field is `GCLK1`"]
            #[inline]
            pub fn is_gclk1(&self) -> bool {
                *self == IDR::GCLK1
            }
            #[doc = "Checks if the value of the field is `GCLK2`"]
            #[inline]
            pub fn is_gclk2(&self) -> bool {
                *self == IDR::GCLK2
            }
            #[doc = "Checks if the value of the field is `GCLK3`"]
            #[inline]
            pub fn is_gclk3(&self) -> bool {
                *self == IDR::GCLK3
            }
            #[doc = "Checks if the value of the field is `GCLK4`"]
            #[inline]
            pub fn is_gclk4(&self) -> bool {
                *self == IDR::GCLK4
            }
            #[doc = "Checks if the value of the field is `GCLK5`"]
            #[inline]
            pub fn is_gclk5(&self) -> bool {
                *self == IDR::GCLK5
            }
            #[doc = "Checks if the value of the field is `GCLK6`"]
            #[inline]
            pub fn is_gclk6(&self) -> bool {
                *self == IDR::GCLK6
            }
            #[doc = "Checks if the value of the field is `GCLK7`"]
            #[inline]
            pub fn is_gclk7(&self) -> bool {
                *self == IDR::GCLK7
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "XOSC oscillator output"]
            XOSC,
            #[doc = "Generator input pad"]
            GCLKIN,
            #[doc = "Generic clock generator 1 output"]
            GCLKGEN1,
            #[doc = "OSCULP32K oscillator output"]
            OSCULP32K,
            #[doc = "OSC32K oscillator output"]
            OSC32K,
            #[doc = "XOSC32K oscillator output"]
            XOSC32K,
            #[doc = "OSC8M oscillator output"]
            OSC8M,
            #[doc = "DFLL48M output"]
            DFLL48M,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::XOSC => 0,
                    SRCR::GCLKIN => 0x01,
                    SRCR::GCLKGEN1 => 0x02,
                    SRCR::OSCULP32K => 0x03,
                    SRCR::OSC32K => 0x04,
                    SRCR::XOSC32K => 0x05,
                    SRCR::OSC8M => 0x06,
                    SRCR::DFLL48M => 0x07,
                    SRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::XOSC,
                    1 => SRCR::GCLKIN,
                    2 => SRCR::GCLKGEN1,
                    3 => SRCR::OSCULP32K,
                    4 => SRCR::OSC32K,
                    5 => SRCR::XOSC32K,
                    6 => SRCR::OSC8M,
                    7 => SRCR::DFLL48M,
                    i => SRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `XOSC`"]
            #[inline]
            pub fn is_xosc(&self) -> bool {
                *self == SRCR::XOSC
            }
            #[doc = "Checks if the value of the field is `GCLKIN`"]
            #[inline]
            pub fn is_gclkin(&self) -> bool {
                *self == SRCR::GCLKIN
            }
            #[doc = "Checks if the value of the field is `GCLKGEN1`"]
            #[inline]
            pub fn is_gclkgen1(&self) -> bool {
                *self == SRCR::GCLKGEN1
            }
            #[doc = "Checks if the value of the field is `OSCULP32K`"]
            #[inline]
            pub fn is_osculp32k(&self) -> bool {
                *self == SRCR::OSCULP32K
            }
            #[doc = "Checks if the value of the field is `OSC32K`"]
            #[inline]
            pub fn is_osc32k(&self) -> bool {
                *self == SRCR::OSC32K
            }
            #[doc = "Checks if the value of the field is `XOSC32K`"]
            #[inline]
            pub fn is_xosc32k(&self) -> bool {
                *self == SRCR::XOSC32K
            }
            #[doc = "Checks if the value of the field is `OSC8M`"]
            #[inline]
            pub fn is_osc8m(&self) -> bool {
                *self == SRCR::OSC8M
            }
            #[doc = "Checks if the value of the field is `DFLL48M`"]
            #[inline]
            pub fn is_dfll48m(&self) -> bool {
                *self == SRCR::DFLL48M
            }
        }
        #[doc = r" Value of the field"]
        pub struct GENENR {
            bits: bool,
        }
        impl GENENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDCR {
            bits: bool,
        }
        impl IDCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OOVR {
            bits: bool,
        }
        impl OOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OER {
            bits: bool,
        }
        impl OER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVSELR {
            bits: bool,
        }
        impl DIVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `ID`"]
        pub enum IDW {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
        }
        impl IDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDW::GCLK0 => 0,
                    IDW::GCLK1 => 1,
                    IDW::GCLK2 => 2,
                    IDW::GCLK3 => 3,
                    IDW::GCLK4 => 4,
                    IDW::GCLK5 => 5,
                    IDW::GCLK6 => 6,
                    IDW::GCLK7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Generic clock generator 0"]
            #[inline]
            pub fn gclk0(self) -> &'a mut W {
                self.variant(IDW::GCLK0)
            }
            #[doc = "Generic clock generator 1"]
            #[inline]
            pub fn gclk1(self) -> &'a mut W {
                self.variant(IDW::GCLK1)
            }
            #[doc = "Generic clock generator 2"]
            #[inline]
            pub fn gclk2(self) -> &'a mut W {
                self.variant(IDW::GCLK2)
            }
            #[doc = "Generic clock generator 3"]
            #[inline]
            pub fn gclk3(self) -> &'a mut W {
                self.variant(IDW::GCLK3)
            }
            #[doc = "Generic clock generator 4"]
            #[inline]
            pub fn gclk4(self) -> &'a mut W {
                self.variant(IDW::GCLK4)
            }
            #[doc = "Generic clock generator 5"]
            #[inline]
            pub fn gclk5(self) -> &'a mut W {
                self.variant(IDW::GCLK5)
            }
            #[doc = "Generic clock generator 6"]
            #[inline]
            pub fn gclk6(self) -> &'a mut W {
                self.variant(IDW::GCLK6)
            }
            #[doc = "Generic clock generator 7"]
            #[inline]
            pub fn gclk7(self) -> &'a mut W {
                self.variant(IDW::GCLK7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC`"]
        pub enum SRCW {
            #[doc = "XOSC oscillator output"]
            XOSC,
            #[doc = "Generator input pad"]
            GCLKIN,
            #[doc = "Generic clock generator 1 output"]
            GCLKGEN1,
            #[doc = "OSCULP32K oscillator output"]
            OSCULP32K,
            #[doc = "OSC32K oscillator output"]
            OSC32K,
            #[doc = "XOSC32K oscillator output"]
            XOSC32K,
            #[doc = "OSC8M oscillator output"]
            OSC8M,
            #[doc = "DFLL48M output"]
            DFLL48M,
        }
        impl SRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCW::XOSC => 0,
                    SRCW::GCLKIN => 1,
                    SRCW::GCLKGEN1 => 2,
                    SRCW::OSCULP32K => 3,
                    SRCW::OSC32K => 4,
                    SRCW::XOSC32K => 5,
                    SRCW::OSC8M => 6,
                    SRCW::DFLL48M => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "XOSC oscillator output"]
            #[inline]
            pub fn xosc(self) -> &'a mut W {
                self.variant(SRCW::XOSC)
            }
            #[doc = "Generator input pad"]
            #[inline]
            pub fn gclkin(self) -> &'a mut W {
                self.variant(SRCW::GCLKIN)
            }
            #[doc = "Generic clock generator 1 output"]
            #[inline]
            pub fn gclkgen1(self) -> &'a mut W {
                self.variant(SRCW::GCLKGEN1)
            }
            #[doc = "OSCULP32K oscillator output"]
            #[inline]
            pub fn osculp32k(self) -> &'a mut W {
                self.variant(SRCW::OSCULP32K)
            }
            #[doc = "OSC32K oscillator output"]
            #[inline]
            pub fn osc32k(self) -> &'a mut W {
                self.variant(SRCW::OSC32K)
            }
            #[doc = "XOSC32K oscillator output"]
            #[inline]
            pub fn xosc32k(self) -> &'a mut W {
                self.variant(SRCW::XOSC32K)
            }
            #[doc = "OSC8M oscillator output"]
            #[inline]
            pub fn osc8m(self) -> &'a mut W {
                self.variant(SRCW::OSC8M)
            }
            #[doc = "DFLL48M output"]
            #[inline]
            pub fn dfll48m(self) -> &'a mut W {
                self.variant(SRCW::DFLL48M)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GENENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GENENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OOVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline]
            pub fn id(&self) -> IDR {
                IDR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:12 - Source Select"]
            #[inline]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 16 - Generic Clock Generator Enable"]
            #[inline]
            pub fn genen(&self) -> GENENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GENENR { bits }
            }
            #[doc = "Bit 17 - Improve Duty Cycle"]
            #[inline]
            pub fn idc(&self) -> IDCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDCR { bits }
            }
            #[doc = "Bit 18 - Output Off Value"]
            #[inline]
            pub fn oov(&self) -> OOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OOVR { bits }
            }
            #[doc = "Bit 19 - Output Enable"]
            #[inline]
            pub fn oe(&self) -> OER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OER { bits }
            }
            #[doc = "Bit 20 - Divide Selection"]
            #[inline]
            pub fn divsel(&self) -> DIVSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIVSELR { bits }
            }
            #[doc = "Bit 21 - Run in Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:12 - Source Select"]
            #[inline]
            pub fn src(&mut self) -> _SRCW {
                _SRCW { w: self }
            }
            #[doc = "Bit 16 - Generic Clock Generator Enable"]
            #[inline]
            pub fn genen(&mut self) -> _GENENW {
                _GENENW { w: self }
            }
            #[doc = "Bit 17 - Improve Duty Cycle"]
            #[inline]
            pub fn idc(&mut self) -> _IDCW {
                _IDCW { w: self }
            }
            #[doc = "Bit 18 - Output Off Value"]
            #[inline]
            pub fn oov(&mut self) -> _OOVW {
                _OOVW { w: self }
            }
            #[doc = "Bit 19 - Output Enable"]
            #[inline]
            pub fn oe(&mut self) -> _OEW {
                _OEW { w: self }
            }
            #[doc = "Bit 20 - Divide Selection"]
            #[inline]
            pub fn divsel(&mut self) -> _DIVSELW {
                _DIVSELW { w: self }
            }
            #[doc = "Bit 21 - Run in Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
        }
    }
    #[doc = "Generic Clock Generator Division"]
    pub struct GENDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "Generic Clock Generator Division"]
    pub mod gendiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GENDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDR::GCLK0 => 0,
                    IDR::GCLK1 => 0x01,
                    IDR::GCLK2 => 0x02,
                    IDR::GCLK3 => 0x03,
                    IDR::GCLK4 => 0x04,
                    IDR::GCLK5 => 0x05,
                    IDR::GCLK6 => 0x06,
                    IDR::GCLK7 => 0x07,
                    IDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IDR {
                match value {
                    0 => IDR::GCLK0,
                    1 => IDR::GCLK1,
                    2 => IDR::GCLK2,
                    3 => IDR::GCLK3,
                    4 => IDR::GCLK4,
                    5 => IDR::GCLK5,
                    6 => IDR::GCLK6,
                    7 => IDR::GCLK7,
                    i => IDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK0`"]
            #[inline]
            pub fn is_gclk0(&self) -> bool {
                *self == IDR::GCLK0
            }
            #[doc = "Checks if the value of the field is `GCLK1`"]
            #[inline]
            pub fn is_gclk1(&self) -> bool {
                *self == IDR::GCLK1
            }
            #[doc = "Checks if the value of the field is `GCLK2`"]
            #[inline]
            pub fn is_gclk2(&self) -> bool {
                *self == IDR::GCLK2
            }
            #[doc = "Checks if the value of the field is `GCLK3`"]
            #[inline]
            pub fn is_gclk3(&self) -> bool {
                *self == IDR::GCLK3
            }
            #[doc = "Checks if the value of the field is `GCLK4`"]
            #[inline]
            pub fn is_gclk4(&self) -> bool {
                *self == IDR::GCLK4
            }
            #[doc = "Checks if the value of the field is `GCLK5`"]
            #[inline]
            pub fn is_gclk5(&self) -> bool {
                *self == IDR::GCLK5
            }
            #[doc = "Checks if the value of the field is `GCLK6`"]
            #[inline]
            pub fn is_gclk6(&self) -> bool {
                *self == IDR::GCLK6
            }
            #[doc = "Checks if the value of the field is `GCLK7`"]
            #[inline]
            pub fn is_gclk7(&self) -> bool {
                *self == IDR::GCLK7
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u16,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `ID`"]
        pub enum IDW {
            #[doc = "Generic clock generator 0"]
            GCLK0,
            #[doc = "Generic clock generator 1"]
            GCLK1,
            #[doc = "Generic clock generator 2"]
            GCLK2,
            #[doc = "Generic clock generator 3"]
            GCLK3,
            #[doc = "Generic clock generator 4"]
            GCLK4,
            #[doc = "Generic clock generator 5"]
            GCLK5,
            #[doc = "Generic clock generator 6"]
            GCLK6,
            #[doc = "Generic clock generator 7"]
            GCLK7,
        }
        impl IDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDW::GCLK0 => 0,
                    IDW::GCLK1 => 1,
                    IDW::GCLK2 => 2,
                    IDW::GCLK3 => 3,
                    IDW::GCLK4 => 4,
                    IDW::GCLK5 => 5,
                    IDW::GCLK6 => 6,
                    IDW::GCLK7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Generic clock generator 0"]
            #[inline]
            pub fn gclk0(self) -> &'a mut W {
                self.variant(IDW::GCLK0)
            }
            #[doc = "Generic clock generator 1"]
            #[inline]
            pub fn gclk1(self) -> &'a mut W {
                self.variant(IDW::GCLK1)
            }
            #[doc = "Generic clock generator 2"]
            #[inline]
            pub fn gclk2(self) -> &'a mut W {
                self.variant(IDW::GCLK2)
            }
            #[doc = "Generic clock generator 3"]
            #[inline]
            pub fn gclk3(self) -> &'a mut W {
                self.variant(IDW::GCLK3)
            }
            #[doc = "Generic clock generator 4"]
            #[inline]
            pub fn gclk4(self) -> &'a mut W {
                self.variant(IDW::GCLK4)
            }
            #[doc = "Generic clock generator 5"]
            #[inline]
            pub fn gclk5(self) -> &'a mut W {
                self.variant(IDW::GCLK5)
            }
            #[doc = "Generic clock generator 6"]
            #[inline]
            pub fn gclk6(self) -> &'a mut W {
                self.variant(IDW::GCLK6)
            }
            #[doc = "Generic clock generator 7"]
            #[inline]
            pub fn gclk7(self) -> &'a mut W {
                self.variant(IDW::GCLK7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline]
            pub fn id(&self) -> IDR {
                IDR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:23 - Division Factor"]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Generic Clock Generator Selection"]
            #[inline]
            pub fn id(&mut self) -> _IDW {
                _IDW { w: self }
            }
            #[doc = "Bits 8:23 - Division Factor"]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy Status"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Generic Clock Generator"]
pub struct GCLK {
    register_block: gclk::RegisterBlock,
}
impl Deref for GCLK {
    type Target = gclk::RegisterBlock;
    fn deref(&self) -> &gclk::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Non-Volatile Memory Controller"]
pub const NVMCTRL: Peripheral<NVMCTRL> = unsafe { Peripheral::new(0x4100_4000) };
#[doc = "Non-Volatile Memory Controller"]
pub mod nvmctrl {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        _reserved0: [u8; 2usize],
        #[doc = "0x04 - Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x08 - NVM Parameter"]
        pub param: PARAM,
        #[doc = "0x0c - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        _reserved1: [u8; 3usize],
        #[doc = "0x10 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        _reserved2: [u8; 3usize],
        #[doc = "0x14 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved3: [u8; 3usize],
        #[doc = "0x18 - Status"]
        pub status: STATUS,
        _reserved4: [u8; 2usize],
        #[doc = "0x1c - Address"]
        pub addr: ADDR,
        #[doc = "0x20 - Lock Section"]
        pub lock: LOCK,
    }
    #[doc = "Address"]
    pub struct ADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Address"]
    pub mod addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRR {
            bits: u32,
        }
        impl ADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x003f_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:21 - NVM Address"]
            #[inline]
            pub fn addr(&self) -> ADDRR {
                let bits = {
                    const MASK: u32 = 0x003f_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ADDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:21 - NVM Address"]
            #[inline]
            pub fn addr(&mut self) -> _ADDRW {
                _ADDRW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u16>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            ER,
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            WP,
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            EAR,
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            WAP,
            #[doc = "Security Flow Command"]
            SF,
            #[doc = "Write lockbits"]
            WL,
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            LR,
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            UR,
            #[doc = "Sets the power reduction mode."]
            SPRM,
            #[doc = "Clears the power reduction mode."]
            CPRM,
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            PBC,
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            SSB,
            #[doc = "Invalidate all cache lines."]
            INVALL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::ER => 0x02,
                    CMDR::WP => 0x04,
                    CMDR::EAR => 0x05,
                    CMDR::WAP => 0x06,
                    CMDR::SF => 0x0a,
                    CMDR::WL => 0x0f,
                    CMDR::LR => 0x40,
                    CMDR::UR => 0x41,
                    CMDR::SPRM => 0x42,
                    CMDR::CPRM => 0x43,
                    CMDR::PBC => 0x44,
                    CMDR::SSB => 0x45,
                    CMDR::INVALL => 0x46,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    2 => CMDR::ER,
                    4 => CMDR::WP,
                    5 => CMDR::EAR,
                    6 => CMDR::WAP,
                    10 => CMDR::SF,
                    15 => CMDR::WL,
                    64 => CMDR::LR,
                    65 => CMDR::UR,
                    66 => CMDR::SPRM,
                    67 => CMDR::CPRM,
                    68 => CMDR::PBC,
                    69 => CMDR::SSB,
                    70 => CMDR::INVALL,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ER`"]
            #[inline]
            pub fn is_er(&self) -> bool {
                *self == CMDR::ER
            }
            #[doc = "Checks if the value of the field is `WP`"]
            #[inline]
            pub fn is_wp(&self) -> bool {
                *self == CMDR::WP
            }
            #[doc = "Checks if the value of the field is `EAR`"]
            #[inline]
            pub fn is_ear(&self) -> bool {
                *self == CMDR::EAR
            }
            #[doc = "Checks if the value of the field is `WAP`"]
            #[inline]
            pub fn is_wap(&self) -> bool {
                *self == CMDR::WAP
            }
            #[doc = "Checks if the value of the field is `SF`"]
            #[inline]
            pub fn is_sf(&self) -> bool {
                *self == CMDR::SF
            }
            #[doc = "Checks if the value of the field is `WL`"]
            #[inline]
            pub fn is_wl(&self) -> bool {
                *self == CMDR::WL
            }
            #[doc = "Checks if the value of the field is `LR`"]
            #[inline]
            pub fn is_lr(&self) -> bool {
                *self == CMDR::LR
            }
            #[doc = "Checks if the value of the field is `UR`"]
            #[inline]
            pub fn is_ur(&self) -> bool {
                *self == CMDR::UR
            }
            #[doc = "Checks if the value of the field is `SPRM`"]
            #[inline]
            pub fn is_sprm(&self) -> bool {
                *self == CMDR::SPRM
            }
            #[doc = "Checks if the value of the field is `CPRM`"]
            #[inline]
            pub fn is_cprm(&self) -> bool {
                *self == CMDR::CPRM
            }
            #[doc = "Checks if the value of the field is `PBC`"]
            #[inline]
            pub fn is_pbc(&self) -> bool {
                *self == CMDR::PBC
            }
            #[doc = "Checks if the value of the field is `SSB`"]
            #[inline]
            pub fn is_ssb(&self) -> bool {
                *self == CMDR::SSB
            }
            #[doc = "Checks if the value of the field is `INVALL`"]
            #[inline]
            pub fn is_invall(&self) -> bool {
                *self == CMDR::INVALL
            }
        }
        #[doc = "Possible values of the field `CMDEX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDEXR {
            #[doc = "Execution Key"]
            KEY,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDEXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDEXR::KEY => 0xa5,
                    CMDEXR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CMDEXR {
                match value {
                    165 => CMDEXR::KEY,
                    i => CMDEXR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `KEY`"]
            #[inline]
            pub fn is_key(&self) -> bool {
                *self == CMDEXR::KEY
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            ER,
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            WP,
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            EAR,
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            WAP,
            #[doc = "Security Flow Command"]
            SF,
            #[doc = "Write lockbits"]
            WL,
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            LR,
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            UR,
            #[doc = "Sets the power reduction mode."]
            SPRM,
            #[doc = "Clears the power reduction mode."]
            CPRM,
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            PBC,
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            SSB,
            #[doc = "Invalidate all cache lines."]
            INVALL,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::ER => 2,
                    CMDW::WP => 4,
                    CMDW::EAR => 5,
                    CMDW::WAP => 6,
                    CMDW::SF => 10,
                    CMDW::WL => 15,
                    CMDW::LR => 64,
                    CMDW::UR => 65,
                    CMDW::SPRM => 66,
                    CMDW::CPRM => 67,
                    CMDW::PBC => 68,
                    CMDW::SSB => 69,
                    CMDW::INVALL => 70,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Erase Row - Erases the row addressed by the ADDR register."]
            #[inline]
            pub fn er(self) -> &'a mut W {
                self.variant(CMDW::ER)
            }
            #[doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
            #[inline]
            pub fn wp(self) -> &'a mut W {
                self.variant(CMDW::WP)
            }
            #[doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            #[inline]
            pub fn ear(self) -> &'a mut W {
                self.variant(CMDW::EAR)
            }
            #[doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
            #[inline]
            pub fn wap(self) -> &'a mut W {
                self.variant(CMDW::WAP)
            }
            #[doc = "Security Flow Command"]
            #[inline]
            pub fn sf(self) -> &'a mut W {
                self.variant(CMDW::SF)
            }
            #[doc = "Write lockbits"]
            #[inline]
            pub fn wl(self) -> &'a mut W {
                self.variant(CMDW::WL)
            }
            #[doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
            #[inline]
            pub fn lr(self) -> &'a mut W {
                self.variant(CMDW::LR)
            }
            #[doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
            #[inline]
            pub fn ur(self) -> &'a mut W {
                self.variant(CMDW::UR)
            }
            #[doc = "Sets the power reduction mode."]
            #[inline]
            pub fn sprm(self) -> &'a mut W {
                self.variant(CMDW::SPRM)
            }
            #[doc = "Clears the power reduction mode."]
            #[inline]
            pub fn cprm(self) -> &'a mut W {
                self.variant(CMDW::CPRM)
            }
            #[doc = "Page Buffer Clear - Clears the page buffer."]
            #[inline]
            pub fn pbc(self) -> &'a mut W {
                self.variant(CMDW::PBC)
            }
            #[doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
            #[inline]
            pub fn ssb(self) -> &'a mut W {
                self.variant(CMDW::SSB)
            }
            #[doc = "Invalidate all cache lines."]
            #[inline]
            pub fn invall(self) -> &'a mut W {
                self.variant(CMDW::INVALL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMDEX`"]
        pub enum CMDEXW {
            #[doc = "Execution Key"]
            KEY,
        }
        impl CMDEXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDEXW::KEY => 165,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDEXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDEXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CMDEXW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Execution Key"]
            #[inline]
            pub fn key(self) -> &'a mut W {
                self.variant(CMDEXW::KEY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:6 - Command"]
            #[inline]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:15 - Command Execution"]
            #[inline]
            pub fn cmdex(&self) -> CMDEXR {
                CMDEXR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Command"]
            #[inline]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
            #[doc = "Bits 8:15 - Command Execution"]
            #[inline]
            pub fn cmdex(&mut self) -> _CMDEXW {
                _CMDEXW { w: self }
            }
        }
    }
    #[doc = "Control B"]
    pub struct CTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RWS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWSR {
            #[doc = "Single Auto Wait State"]
            SINGLE,
            #[doc = "Half Auto Wait State"]
            HALF,
            #[doc = "Dual Auto Wait State"]
            DUAL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl RWSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RWSR::SINGLE => 0,
                    RWSR::HALF => 0x01,
                    RWSR::DUAL => 0x02,
                    RWSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RWSR {
                match value {
                    0 => RWSR::SINGLE,
                    1 => RWSR::HALF,
                    2 => RWSR::DUAL,
                    i => RWSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline]
            pub fn is_single(&self) -> bool {
                *self == RWSR::SINGLE
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline]
            pub fn is_half(&self) -> bool {
                *self == RWSR::HALF
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline]
            pub fn is_dual(&self) -> bool {
                *self == RWSR::DUAL
            }
        }
        #[doc = r" Value of the field"]
        pub struct MANWR {
            bits: bool,
        }
        impl MANWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SLEEPPRM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPPRMR {
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            WAKEONACCESS,
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            WAKEUPINSTANT,
            #[doc = "Auto power reduction disabled."]
            DISABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SLEEPPRMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLEEPPRMR::WAKEONACCESS => 0,
                    SLEEPPRMR::WAKEUPINSTANT => 0x01,
                    SLEEPPRMR::DISABLED => 0x03,
                    SLEEPPRMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SLEEPPRMR {
                match value {
                    0 => SLEEPPRMR::WAKEONACCESS,
                    1 => SLEEPPRMR::WAKEUPINSTANT,
                    3 => SLEEPPRMR::DISABLED,
                    i => SLEEPPRMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `WAKEONACCESS`"]
            #[inline]
            pub fn is_wakeonaccess(&self) -> bool {
                *self == SLEEPPRMR::WAKEONACCESS
            }
            #[doc = "Checks if the value of the field is `WAKEUPINSTANT`"]
            #[inline]
            pub fn is_wakeupinstant(&self) -> bool {
                *self == SLEEPPRMR::WAKEUPINSTANT
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SLEEPPRMR::DISABLED
            }
        }
        #[doc = "Possible values of the field `READMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READMODER {
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            NO_MISS_PENALTY,
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            LOW_POWER,
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            DETERMINISTIC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl READMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    READMODER::NO_MISS_PENALTY => 0,
                    READMODER::LOW_POWER => 0x01,
                    READMODER::DETERMINISTIC => 0x02,
                    READMODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> READMODER {
                match value {
                    0 => READMODER::NO_MISS_PENALTY,
                    1 => READMODER::LOW_POWER,
                    2 => READMODER::DETERMINISTIC,
                    i => READMODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NO_MISS_PENALTY`"]
            #[inline]
            pub fn is_no_miss_penalty(&self) -> bool {
                *self == READMODER::NO_MISS_PENALTY
            }
            #[doc = "Checks if the value of the field is `LOW_POWER`"]
            #[inline]
            pub fn is_low_power(&self) -> bool {
                *self == READMODER::LOW_POWER
            }
            #[doc = "Checks if the value of the field is `DETERMINISTIC`"]
            #[inline]
            pub fn is_deterministic(&self) -> bool {
                *self == READMODER::DETERMINISTIC
            }
        }
        #[doc = r" Value of the field"]
        pub struct CACHEDISR {
            bits: bool,
        }
        impl CACHEDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `RWS`"]
        pub enum RWSW {
            #[doc = "Single Auto Wait State"]
            SINGLE,
            #[doc = "Half Auto Wait State"]
            HALF,
            #[doc = "Dual Auto Wait State"]
            DUAL,
        }
        impl RWSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RWSW::SINGLE => 0,
                    RWSW::HALF => 1,
                    RWSW::DUAL => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RWSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RWSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RWSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Single Auto Wait State"]
            #[inline]
            pub fn single(self) -> &'a mut W {
                self.variant(RWSW::SINGLE)
            }
            #[doc = "Half Auto Wait State"]
            #[inline]
            pub fn half(self) -> &'a mut W {
                self.variant(RWSW::HALF)
            }
            #[doc = "Dual Auto Wait State"]
            #[inline]
            pub fn dual(self) -> &'a mut W {
                self.variant(RWSW::DUAL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MANWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MANWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLEEPPRM`"]
        pub enum SLEEPPRMW {
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            WAKEONACCESS,
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            WAKEUPINSTANT,
            #[doc = "Auto power reduction disabled."]
            DISABLED,
        }
        impl SLEEPPRMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLEEPPRMW::WAKEONACCESS => 0,
                    SLEEPPRMW::WAKEUPINSTANT => 1,
                    SLEEPPRMW::DISABLED => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPPRMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPPRMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLEEPPRMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
            #[inline]
            pub fn wakeonaccess(self) -> &'a mut W {
                self.variant(SLEEPPRMW::WAKEONACCESS)
            }
            #[doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
            #[inline]
            pub fn wakeupinstant(self) -> &'a mut W {
                self.variant(SLEEPPRMW::WAKEUPINSTANT)
            }
            #[doc = "Auto power reduction disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SLEEPPRMW::DISABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `READMODE`"]
        pub enum READMODEW {
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            NO_MISS_PENALTY,
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            LOW_POWER,
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            DETERMINISTIC,
        }
        impl READMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    READMODEW::NO_MISS_PENALTY => 0,
                    READMODEW::LOW_POWER => 1,
                    READMODEW::DETERMINISTIC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
            #[inline]
            pub fn no_miss_penalty(self) -> &'a mut W {
                self.variant(READMODEW::NO_MISS_PENALTY)
            }
            #[doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
            #[inline]
            pub fn low_power(self) -> &'a mut W {
                self.variant(READMODEW::LOW_POWER)
            }
            #[doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
            #[inline]
            pub fn deterministic(self) -> &'a mut W {
                self.variant(READMODEW::DETERMINISTIC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CACHEDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CACHEDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:4 - NVM Read Wait States"]
            #[inline]
            pub fn rws(&self) -> RWSR {
                RWSR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Manual Write"]
            #[inline]
            pub fn manw(&self) -> MANWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MANWR { bits }
            }
            #[doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
            #[inline]
            pub fn sleepprm(&self) -> SLEEPPRMR {
                SLEEPPRMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:17 - NVMCTRL Read Mode"]
            #[inline]
            pub fn readmode(&self) -> READMODER {
                READMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 18 - Cache Disable"]
            #[inline]
            pub fn cachedis(&self) -> CACHEDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CACHEDISR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:4 - NVM Read Wait States"]
            #[inline]
            pub fn rws(&mut self) -> _RWSW {
                _RWSW { w: self }
            }
            #[doc = "Bit 7 - Manual Write"]
            #[inline]
            pub fn manw(&mut self) -> _MANWW {
                _MANWW { w: self }
            }
            #[doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
            #[inline]
            pub fn sleepprm(&mut self) -> _SLEEPPRMW {
                _SLEEPPRMW { w: self }
            }
            #[doc = "Bits 16:17 - NVMCTRL Read Mode"]
            #[inline]
            pub fn readmode(&mut self) -> _READMODEW {
                _READMODEW { w: self }
            }
            #[doc = "Bit 18 - Cache Disable"]
            #[inline]
            pub fn cachedis(&mut self) -> _CACHEDISW {
                _CACHEDISW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NVM Ready Interrupt Enable"]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READYR {
            bits: bool,
        }
        impl READYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRORR {
            bits: bool,
        }
        impl ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - NVM Ready"]
            #[inline]
            pub fn ready(&self) -> READYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                READYR { bits }
            }
            #[doc = "Bit 1 - Error"]
            #[inline]
            pub fn error(&self) -> ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NVM Ready"]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Error"]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Lock Section"]
    pub struct LOCK {
        register: VolatileCell<u16>,
    }
    #[doc = "Lock Section"]
    pub mod lock {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        impl super::LOCK {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: u16,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Region Lock Bits"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                LOCKR { bits }
            }
        }
    }
    #[doc = "NVM Parameter"]
    pub struct PARAM {
        register: VolatileCell<u32>,
    }
    #[doc = "NVM Parameter"]
    pub mod param {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PARAM {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMPR {
            bits: u16,
        }
        impl NVMPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSZ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSZR {
            #[doc = "8 bytes"]
            _8,
            #[doc = "16 bytes"]
            _16,
            #[doc = "32 bytes"]
            _32,
            #[doc = "64 bytes"]
            _64,
            #[doc = "128 bytes"]
            _128,
            #[doc = "256 bytes"]
            _256,
            #[doc = "512 bytes"]
            _512,
            #[doc = "1024 bytes"]
            _1024,
        }
        impl PSZR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSZR::_8 => 0,
                    PSZR::_16 => 0x01,
                    PSZR::_32 => 0x02,
                    PSZR::_64 => 0x03,
                    PSZR::_128 => 0x04,
                    PSZR::_256 => 0x05,
                    PSZR::_512 => 0x06,
                    PSZR::_1024 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSZR {
                match value {
                    0 => PSZR::_8,
                    1 => PSZR::_16,
                    2 => PSZR::_32,
                    3 => PSZR::_64,
                    4 => PSZR::_128,
                    5 => PSZR::_256,
                    6 => PSZR::_512,
                    7 => PSZR::_1024,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline]
            pub fn is_8(&self) -> bool {
                *self == PSZR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline]
            pub fn is_16(&self) -> bool {
                *self == PSZR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline]
            pub fn is_32(&self) -> bool {
                *self == PSZR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline]
            pub fn is_64(&self) -> bool {
                *self == PSZR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline]
            pub fn is_128(&self) -> bool {
                *self == PSZR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline]
            pub fn is_256(&self) -> bool {
                *self == PSZR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline]
            pub fn is_512(&self) -> bool {
                *self == PSZR::_512
            }
            #[doc = "Checks if the value of the field is `_1024`"]
            #[inline]
            pub fn is_1024(&self) -> bool {
                *self == PSZR::_1024
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - NVM Pages"]
            #[inline]
            pub fn nvmp(&self) -> NVMPR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NVMPR { bits }
            }
            #[doc = "Bits 16:18 - Page Size"]
            #[inline]
            pub fn psz(&self) -> PSZR {
                PSZR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u16>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRMR {
            bits: bool,
        }
        impl PRMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOADR {
            bits: bool,
        }
        impl LOADR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROGER {
            bits: bool,
        }
        impl PROGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKER {
            bits: bool,
        }
        impl LOCKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMER {
            bits: bool,
        }
        impl NVMER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBR {
            bits: bool,
        }
        impl SBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOADW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PROGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PROGEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Power Reduction Mode"]
            #[inline]
            pub fn prm(&self) -> PRMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PRMR { bits }
            }
            #[doc = "Bit 1 - NVM Page Buffer Active Loading"]
            #[inline]
            pub fn load(&self) -> LOADR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LOADR { bits }
            }
            #[doc = "Bit 2 - Programming Error Status"]
            #[inline]
            pub fn proge(&self) -> PROGER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PROGER { bits }
            }
            #[doc = "Bit 3 - Lock Error Status"]
            #[inline]
            pub fn locke(&self) -> LOCKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LOCKER { bits }
            }
            #[doc = "Bit 4 - NVM Error"]
            #[inline]
            pub fn nvme(&self) -> NVMER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                NVMER { bits }
            }
            #[doc = "Bit 8 - Security Bit Status"]
            #[inline]
            pub fn sb(&self) -> SBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - NVM Page Buffer Active Loading"]
            #[inline]
            pub fn load(&mut self) -> _LOADW {
                _LOADW { w: self }
            }
            #[doc = "Bit 2 - Programming Error Status"]
            #[inline]
            pub fn proge(&mut self) -> _PROGEW {
                _PROGEW { w: self }
            }
            #[doc = "Bit 3 - Lock Error Status"]
            #[inline]
            pub fn locke(&mut self) -> _LOCKEW {
                _LOCKEW { w: self }
            }
            #[doc = "Bit 4 - NVM Error"]
            #[inline]
            pub fn nvme(&mut self) -> _NVMEW {
                _NVMEW { w: self }
            }
        }
    }
}
#[doc = "Non-Volatile Memory Controller"]
pub struct NVMCTRL {
    register_block: nvmctrl::RegisterBlock,
}
impl Deref for NVMCTRL {
    type Target = nvmctrl::RegisterBlock;
    fn deref(&self) -> &nvmctrl::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 0"]
pub const PAC0: Peripheral<PAC0> = unsafe { Peripheral::new(0x4000_0000) };
#[doc = "Peripheral Access Controller 0"]
pub mod pac0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Write Protection Clear"]
        pub wpclr: WPCLR,
        #[doc = "0x04 - Write Protection Set"]
        pub wpset: WPSET,
    }
    #[doc = "Write Protection Clear"]
    pub struct WPCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Protection Clear"]
    pub mod wpclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WPCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WPR {
            bits: u32,
        }
        impl WPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x7fff_ffff;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:31 - Write Protection Clear"]
            #[inline]
            pub fn wp(&self) -> WPR {
                let bits = {
                    const MASK: u32 = 0x7fff_ffff;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:31 - Write Protection Clear"]
            #[inline]
            pub fn wp(&mut self) -> _WPW {
                _WPW { w: self }
            }
        }
    }
    #[doc = "Write Protection Set"]
    pub struct WPSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Protection Set"]
    pub mod wpset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WPSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WPR {
            bits: u32,
        }
        impl WPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x7fff_ffff;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:31 - Write Protection Set"]
            #[inline]
            pub fn wp(&self) -> WPR {
                let bits = {
                    const MASK: u32 = 0x7fff_ffff;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:31 - Write Protection Set"]
            #[inline]
            pub fn wp(&mut self) -> _WPW {
                _WPW { w: self }
            }
        }
    }
}
#[doc = "Peripheral Access Controller 0"]
pub struct PAC0 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC0 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 1"]
pub const PAC1: Peripheral<PAC1> = unsafe { Peripheral::new(0x4100_0000) };
#[doc = r" Register block"]
pub struct PAC1 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC1 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Peripheral Access Controller 2"]
pub const PAC2: Peripheral<PAC2> = unsafe { Peripheral::new(0x4200_0000) };
#[doc = r" Register block"]
pub struct PAC2 {
    register_block: pac0::RegisterBlock,
}
impl Deref for PAC2 {
    type Target = pac0::RegisterBlock;
    fn deref(&self) -> &pac0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Power Manager"]
pub const PM: Peripheral<PM> = unsafe { Peripheral::new(0x4000_0400) };
#[doc = "Power Manager"]
pub mod pm {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Sleep Mode"]
        pub sleep: SLEEP,
        _reserved0: [u8; 6usize],
        #[doc = "0x08 - CPU Clock Select"]
        pub cpusel: CPUSEL,
        #[doc = "0x09 - APBA Clock Select"]
        pub apbasel: APBASEL,
        #[doc = "0x0a - APBB Clock Select"]
        pub apbbsel: APBBSEL,
        #[doc = "0x0b - APBC Clock Select"]
        pub apbcsel: APBCSEL,
        _reserved1: [u8; 8usize],
        #[doc = "0x14 - AHB Mask"]
        pub ahbmask: AHBMASK,
        #[doc = "0x18 - APBA Mask"]
        pub apbamask: APBAMASK,
        #[doc = "0x1c - APBB Mask"]
        pub apbbmask: APBBMASK,
        #[doc = "0x20 - APBC Mask"]
        pub apbcmask: APBCMASK,
        _reserved2: [u8; 16usize],
        #[doc = "0x34 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x35 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x36 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved3: [u8; 1usize],
        #[doc = "0x38 - Reset Cause"]
        pub rcause: RCAUSE,
    }
    #[doc = "AHB Mask"]
    pub struct AHBMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "AHB Mask"]
    pub mod ahbmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AHBMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB0R {
            bits: bool,
        }
        impl HPB0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB1R {
            bits: bool,
        }
        impl HPB1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HPB2R {
            bits: bool,
        }
        impl HPB2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSUR {
            bits: bool,
        }
        impl DSUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMCTRLR {
            bits: bool,
        }
        impl NVMCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPB2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPB2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - HPB0 AHB Clock Mask"]
            #[inline]
            pub fn hpb0(&self) -> HPB0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB0R { bits }
            }
            #[doc = "Bit 1 - HPB1 AHB Clock Mask"]
            #[inline]
            pub fn hpb1(&self) -> HPB1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB1R { bits }
            }
            #[doc = "Bit 2 - HPB2 AHB Clock Mask"]
            #[inline]
            pub fn hpb2(&self) -> HPB2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HPB2R { bits }
            }
            #[doc = "Bit 3 - DSU AHB Clock Mask"]
            #[inline]
            pub fn dsu(&self) -> DSUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DSUR { bits }
            }
            #[doc = "Bit 4 - NVMCTRL AHB Clock Mask"]
            #[inline]
            pub fn nvmctrl(&self) -> NVMCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NVMCTRLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x1f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - HPB0 AHB Clock Mask"]
            #[inline]
            pub fn hpb0(&mut self) -> _HPB0W {
                _HPB0W { w: self }
            }
            #[doc = "Bit 1 - HPB1 AHB Clock Mask"]
            #[inline]
            pub fn hpb1(&mut self) -> _HPB1W {
                _HPB1W { w: self }
            }
            #[doc = "Bit 2 - HPB2 AHB Clock Mask"]
            #[inline]
            pub fn hpb2(&mut self) -> _HPB2W {
                _HPB2W { w: self }
            }
            #[doc = "Bit 3 - DSU AHB Clock Mask"]
            #[inline]
            pub fn dsu(&mut self) -> _DSUW {
                _DSUW { w: self }
            }
            #[doc = "Bit 4 - NVMCTRL AHB Clock Mask"]
            #[inline]
            pub fn nvmctrl(&mut self) -> _NVMCTRLW {
                _NVMCTRLW { w: self }
            }
        }
    }
    #[doc = "APBA Mask"]
    pub struct APBAMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBA Mask"]
    pub mod apbamask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBAMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC0R {
            bits: bool,
        }
        impl PAC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMR {
            bits: bool,
        }
        impl PMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYSCTRLR {
            bits: bool,
        }
        impl SYSCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCLKR {
            bits: bool,
        }
        impl GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTR {
            bits: bool,
        }
        impl WDTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTCR {
            bits: bool,
        }
        impl RTCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EICR {
            bits: bool,
        }
        impl EICR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCLKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EICW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EICW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC0 APB Clock Enable"]
            #[inline]
            pub fn pac0(&self) -> PAC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC0R { bits }
            }
            #[doc = "Bit 1 - PM APB Clock Enable"]
            #[inline]
            pub fn pm(&self) -> PMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PMR { bits }
            }
            #[doc = "Bit 2 - SYSCTRL APB Clock Enable"]
            #[inline]
            pub fn sysctrl(&self) -> SYSCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SYSCTRLR { bits }
            }
            #[doc = "Bit 3 - GCLK APB Clock Enable"]
            #[inline]
            pub fn gclk(&self) -> GCLKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCLKR { bits }
            }
            #[doc = "Bit 4 - WDT APB Clock Enable"]
            #[inline]
            pub fn wdt(&self) -> WDTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDTR { bits }
            }
            #[doc = "Bit 5 - RTC APB Clock Enable"]
            #[inline]
            pub fn rtc(&self) -> RTCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTCR { bits }
            }
            #[doc = "Bit 6 - EIC APB Clock Enable"]
            #[inline]
            pub fn eic(&self) -> EICR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EICR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x7f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC0 APB Clock Enable"]
            #[inline]
            pub fn pac0(&mut self) -> _PAC0W {
                _PAC0W { w: self }
            }
            #[doc = "Bit 1 - PM APB Clock Enable"]
            #[inline]
            pub fn pm(&mut self) -> _PMW {
                _PMW { w: self }
            }
            #[doc = "Bit 2 - SYSCTRL APB Clock Enable"]
            #[inline]
            pub fn sysctrl(&mut self) -> _SYSCTRLW {
                _SYSCTRLW { w: self }
            }
            #[doc = "Bit 3 - GCLK APB Clock Enable"]
            #[inline]
            pub fn gclk(&mut self) -> _GCLKW {
                _GCLKW { w: self }
            }
            #[doc = "Bit 4 - WDT APB Clock Enable"]
            #[inline]
            pub fn wdt(&mut self) -> _WDTW {
                _WDTW { w: self }
            }
            #[doc = "Bit 5 - RTC APB Clock Enable"]
            #[inline]
            pub fn rtc(&mut self) -> _RTCW {
                _RTCW { w: self }
            }
            #[doc = "Bit 6 - EIC APB Clock Enable"]
            #[inline]
            pub fn eic(&mut self) -> _EICW {
                _EICW { w: self }
            }
        }
    }
    #[doc = "APBA Clock Select"]
    pub struct APBASEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBA Clock Select"]
    pub mod apbasel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBASEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBADIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBADIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBADIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBADIVR::DIV1 => 0,
                    APBADIVR::DIV2 => 0x01,
                    APBADIVR::DIV4 => 0x02,
                    APBADIVR::DIV8 => 0x03,
                    APBADIVR::DIV16 => 0x04,
                    APBADIVR::DIV32 => 0x05,
                    APBADIVR::DIV64 => 0x06,
                    APBADIVR::DIV128 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> APBADIVR {
                match value {
                    0 => APBADIVR::DIV1,
                    1 => APBADIVR::DIV2,
                    2 => APBADIVR::DIV4,
                    3 => APBADIVR::DIV8,
                    4 => APBADIVR::DIV16,
                    5 => APBADIVR::DIV32,
                    6 => APBADIVR::DIV64,
                    7 => APBADIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == APBADIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == APBADIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == APBADIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == APBADIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == APBADIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline]
            pub fn is_div32(&self) -> bool {
                *self == APBADIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == APBADIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == APBADIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBADIV`"]
        pub enum APBADIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBADIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBADIVW::DIV1 => 0,
                    APBADIVW::DIV2 => 1,
                    APBADIVW::DIV4 => 2,
                    APBADIVW::DIV8 => 3,
                    APBADIVW::DIV16 => 4,
                    APBADIVW::DIV32 => 5,
                    APBADIVW::DIV64 => 6,
                    APBADIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBADIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBADIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: APBADIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBADIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBADIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBADIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBADIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBADIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBADIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBADIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBADIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBA Prescaler Selection"]
            #[inline]
            pub fn apbadiv(&self) -> APBADIVR {
                APBADIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBA Prescaler Selection"]
            #[inline]
            pub fn apbadiv(&mut self) -> _APBADIVW {
                _APBADIVW { w: self }
            }
        }
    }
    #[doc = "APBB Mask"]
    pub struct APBBMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBB Mask"]
    pub mod apbbmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBBMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC1R {
            bits: bool,
        }
        impl PAC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSUR {
            bits: bool,
        }
        impl DSUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NVMCTRLR {
            bits: bool,
        }
        impl NVMCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORTR {
            bits: bool,
        }
        impl PORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NVMCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NVMCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC1 APB Clock Enable"]
            #[inline]
            pub fn pac1(&self) -> PAC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC1R { bits }
            }
            #[doc = "Bit 1 - DSU APB Clock Enable"]
            #[inline]
            pub fn dsu(&self) -> DSUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DSUR { bits }
            }
            #[doc = "Bit 2 - NVMCTRL APB Clock Enable"]
            #[inline]
            pub fn nvmctrl(&self) -> NVMCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NVMCTRLR { bits }
            }
            #[doc = "Bit 3 - PORT APB Clock Enable"]
            #[inline]
            pub fn port(&self) -> PORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PORTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x1f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC1 APB Clock Enable"]
            #[inline]
            pub fn pac1(&mut self) -> _PAC1W {
                _PAC1W { w: self }
            }
            #[doc = "Bit 1 - DSU APB Clock Enable"]
            #[inline]
            pub fn dsu(&mut self) -> _DSUW {
                _DSUW { w: self }
            }
            #[doc = "Bit 2 - NVMCTRL APB Clock Enable"]
            #[inline]
            pub fn nvmctrl(&mut self) -> _NVMCTRLW {
                _NVMCTRLW { w: self }
            }
            #[doc = "Bit 3 - PORT APB Clock Enable"]
            #[inline]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
        }
    }
    #[doc = "APBB Clock Select"]
    pub struct APBBSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBB Clock Select"]
    pub mod apbbsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBBSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBBDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBBDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBBDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBBDIVR::DIV1 => 0,
                    APBBDIVR::DIV2 => 0x01,
                    APBBDIVR::DIV4 => 0x02,
                    APBBDIVR::DIV8 => 0x03,
                    APBBDIVR::DIV16 => 0x04,
                    APBBDIVR::DIV32 => 0x05,
                    APBBDIVR::DIV64 => 0x06,
                    APBBDIVR::DIV128 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> APBBDIVR {
                match value {
                    0 => APBBDIVR::DIV1,
                    1 => APBBDIVR::DIV2,
                    2 => APBBDIVR::DIV4,
                    3 => APBBDIVR::DIV8,
                    4 => APBBDIVR::DIV16,
                    5 => APBBDIVR::DIV32,
                    6 => APBBDIVR::DIV64,
                    7 => APBBDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == APBBDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == APBBDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == APBBDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == APBBDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == APBBDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline]
            pub fn is_div32(&self) -> bool {
                *self == APBBDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == APBBDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == APBBDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBBDIV`"]
        pub enum APBBDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBBDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBBDIVW::DIV1 => 0,
                    APBBDIVW::DIV2 => 1,
                    APBBDIVW::DIV4 => 2,
                    APBBDIVW::DIV8 => 3,
                    APBBDIVW::DIV16 => 4,
                    APBBDIVW::DIV32 => 5,
                    APBBDIVW::DIV64 => 6,
                    APBBDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBBDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBBDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: APBBDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBBDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBB Prescaler Selection"]
            #[inline]
            pub fn apbbdiv(&self) -> APBBDIVR {
                APBBDIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBB Prescaler Selection"]
            #[inline]
            pub fn apbbdiv(&mut self) -> _APBBDIVW {
                _APBBDIVW { w: self }
            }
        }
    }
    #[doc = "APBC Mask"]
    pub struct APBCMASK {
        register: VolatileCell<u32>,
    }
    #[doc = "APBC Mask"]
    pub mod apbcmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APBCMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAC2R {
            bits: bool,
        }
        impl PAC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVSYSR {
            bits: bool,
        }
        impl EVSYSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM0R {
            bits: bool,
        }
        impl SERCOM0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM1R {
            bits: bool,
        }
        impl SERCOM1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM2R {
            bits: bool,
        }
        impl SERCOM2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SERCOM3R {
            bits: bool,
        }
        impl SERCOM3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC0R {
            bits: bool,
        }
        impl TC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC1R {
            bits: bool,
        }
        impl TC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC2R {
            bits: bool,
        }
        impl TC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC3R {
            bits: bool,
        }
        impl TC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC4R {
            bits: bool,
        }
        impl TC4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TC5R {
            bits: bool,
        }
        impl TC5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADCR {
            bits: bool,
        }
        impl ADCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACR {
            bits: bool,
        }
        impl ACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACR {
            bits: bool,
        }
        impl DACR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PTCR {
            bits: bool,
        }
        impl PTCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVSYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVSYSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SERCOM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SERCOM3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TC5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TC5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PTCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PTCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PAC2 APB Clock Enable"]
            #[inline]
            pub fn pac2(&self) -> PAC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAC2R { bits }
            }
            #[doc = "Bit 1 - EVSYS APB Clock Enable"]
            #[inline]
            pub fn evsys(&self) -> EVSYSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVSYSR { bits }
            }
            #[doc = "Bit 2 - SERCOM0 APB Clock Enable"]
            #[inline]
            pub fn sercom0(&self) -> SERCOM0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM0R { bits }
            }
            #[doc = "Bit 3 - SERCOM1 APB Clock Enable"]
            #[inline]
            pub fn sercom1(&self) -> SERCOM1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM1R { bits }
            }
            #[doc = "Bit 4 - SERCOM2 APB Clock Enable"]
            #[inline]
            pub fn sercom2(&self) -> SERCOM2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM2R { bits }
            }
            #[doc = "Bit 5 - SERCOM3 APB Clock Enable"]
            #[inline]
            pub fn sercom3(&self) -> SERCOM3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SERCOM3R { bits }
            }
            #[doc = "Bit 8 - TC0 APB Clock Enable"]
            #[inline]
            pub fn tc0(&self) -> TC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC0R { bits }
            }
            #[doc = "Bit 9 - TC1 APB Clock Enable"]
            #[inline]
            pub fn tc1(&self) -> TC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC1R { bits }
            }
            #[doc = "Bit 10 - TC2 APB Clock Enable"]
            #[inline]
            pub fn tc2(&self) -> TC2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC2R { bits }
            }
            #[doc = "Bit 11 - TC3 APB Clock Enable"]
            #[inline]
            pub fn tc3(&self) -> TC3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC3R { bits }
            }
            #[doc = "Bit 12 - TC4 APB Clock Enable"]
            #[inline]
            pub fn tc4(&self) -> TC4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC4R { bits }
            }
            #[doc = "Bit 13 - TC5 APB Clock Enable"]
            #[inline]
            pub fn tc5(&self) -> TC5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TC5R { bits }
            }
            #[doc = "Bit 16 - ADC APB Clock Enable"]
            #[inline]
            pub fn adc(&self) -> ADCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADCR { bits }
            }
            #[doc = "Bit 17 - AC APB Clock Enable"]
            #[inline]
            pub fn ac(&self) -> ACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACR { bits }
            }
            #[doc = "Bit 18 - DAC APB Clock Enable"]
            #[inline]
            pub fn dac(&self) -> DACR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DACR { bits }
            }
            #[doc = "Bit 19 - PTC APB Clock Enable"]
            #[inline]
            pub fn ptc(&self) -> PTCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PTCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0001_0000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PAC2 APB Clock Enable"]
            #[inline]
            pub fn pac2(&mut self) -> _PAC2W {
                _PAC2W { w: self }
            }
            #[doc = "Bit 1 - EVSYS APB Clock Enable"]
            #[inline]
            pub fn evsys(&mut self) -> _EVSYSW {
                _EVSYSW { w: self }
            }
            #[doc = "Bit 2 - SERCOM0 APB Clock Enable"]
            #[inline]
            pub fn sercom0(&mut self) -> _SERCOM0W {
                _SERCOM0W { w: self }
            }
            #[doc = "Bit 3 - SERCOM1 APB Clock Enable"]
            #[inline]
            pub fn sercom1(&mut self) -> _SERCOM1W {
                _SERCOM1W { w: self }
            }
            #[doc = "Bit 4 - SERCOM2 APB Clock Enable"]
            #[inline]
            pub fn sercom2(&mut self) -> _SERCOM2W {
                _SERCOM2W { w: self }
            }
            #[doc = "Bit 5 - SERCOM3 APB Clock Enable"]
            #[inline]
            pub fn sercom3(&mut self) -> _SERCOM3W {
                _SERCOM3W { w: self }
            }
            #[doc = "Bit 8 - TC0 APB Clock Enable"]
            #[inline]
            pub fn tc0(&mut self) -> _TC0W {
                _TC0W { w: self }
            }
            #[doc = "Bit 9 - TC1 APB Clock Enable"]
            #[inline]
            pub fn tc1(&mut self) -> _TC1W {
                _TC1W { w: self }
            }
            #[doc = "Bit 10 - TC2 APB Clock Enable"]
            #[inline]
            pub fn tc2(&mut self) -> _TC2W {
                _TC2W { w: self }
            }
            #[doc = "Bit 11 - TC3 APB Clock Enable"]
            #[inline]
            pub fn tc3(&mut self) -> _TC3W {
                _TC3W { w: self }
            }
            #[doc = "Bit 12 - TC4 APB Clock Enable"]
            #[inline]
            pub fn tc4(&mut self) -> _TC4W {
                _TC4W { w: self }
            }
            #[doc = "Bit 13 - TC5 APB Clock Enable"]
            #[inline]
            pub fn tc5(&mut self) -> _TC5W {
                _TC5W { w: self }
            }
            #[doc = "Bit 16 - ADC APB Clock Enable"]
            #[inline]
            pub fn adc(&mut self) -> _ADCW {
                _ADCW { w: self }
            }
            #[doc = "Bit 17 - AC APB Clock Enable"]
            #[inline]
            pub fn ac(&mut self) -> _ACW {
                _ACW { w: self }
            }
            #[doc = "Bit 18 - DAC APB Clock Enable"]
            #[inline]
            pub fn dac(&mut self) -> _DACW {
                _DACW { w: self }
            }
            #[doc = "Bit 19 - PTC APB Clock Enable"]
            #[inline]
            pub fn ptc(&mut self) -> _PTCW {
                _PTCW { w: self }
            }
        }
    }
    #[doc = "APBC Clock Select"]
    pub struct APBCSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "APBC Clock Select"]
    pub mod apbcsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::APBCSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `APBCDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum APBCDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBCDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    APBCDIVR::DIV1 => 0,
                    APBCDIVR::DIV2 => 0x01,
                    APBCDIVR::DIV4 => 0x02,
                    APBCDIVR::DIV8 => 0x03,
                    APBCDIVR::DIV16 => 0x04,
                    APBCDIVR::DIV32 => 0x05,
                    APBCDIVR::DIV64 => 0x06,
                    APBCDIVR::DIV128 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> APBCDIVR {
                match value {
                    0 => APBCDIVR::DIV1,
                    1 => APBCDIVR::DIV2,
                    2 => APBCDIVR::DIV4,
                    3 => APBCDIVR::DIV8,
                    4 => APBCDIVR::DIV16,
                    5 => APBCDIVR::DIV32,
                    6 => APBCDIVR::DIV64,
                    7 => APBCDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == APBCDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == APBCDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == APBCDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == APBCDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == APBCDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline]
            pub fn is_div32(&self) -> bool {
                *self == APBCDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == APBCDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == APBCDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `APBCDIV`"]
        pub enum APBCDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl APBCDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    APBCDIVW::DIV1 => 0,
                    APBCDIVW::DIV2 => 1,
                    APBCDIVW::DIV4 => 2,
                    APBCDIVW::DIV8 => 3,
                    APBCDIVW::DIV16 => 4,
                    APBCDIVW::DIV32 => 5,
                    APBCDIVW::DIV64 => 6,
                    APBCDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _APBCDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APBCDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: APBCDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline]
            pub fn div32(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(APBCDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - APBC Prescaler Selection"]
            #[inline]
            pub fn apbcdiv(&self) -> APBCDIVR {
                APBCDIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - APBC Prescaler Selection"]
            #[inline]
            pub fn apbcdiv(&mut self) -> _APBCDIVW {
                _APBCDIVW { w: self }
            }
        }
    }
    #[doc = "CPU Clock Select"]
    pub struct CPUSEL {
        register: VolatileCell<u8>,
    }
    #[doc = "CPU Clock Select"]
    pub mod cpusel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CPUSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CPUDIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPUDIVR {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl CPUDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CPUDIVR::DIV1 => 0,
                    CPUDIVR::DIV2 => 0x01,
                    CPUDIVR::DIV4 => 0x02,
                    CPUDIVR::DIV8 => 0x03,
                    CPUDIVR::DIV16 => 0x04,
                    CPUDIVR::DIV32 => 0x05,
                    CPUDIVR::DIV64 => 0x06,
                    CPUDIVR::DIV128 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CPUDIVR {
                match value {
                    0 => CPUDIVR::DIV1,
                    1 => CPUDIVR::DIV2,
                    2 => CPUDIVR::DIV4,
                    3 => CPUDIVR::DIV8,
                    4 => CPUDIVR::DIV16,
                    5 => CPUDIVR::DIV32,
                    6 => CPUDIVR::DIV64,
                    7 => CPUDIVR::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == CPUDIVR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == CPUDIVR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == CPUDIVR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == CPUDIVR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == CPUDIVR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline]
            pub fn is_div32(&self) -> bool {
                *self == CPUDIVR::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == CPUDIVR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == CPUDIVR::DIV128
            }
        }
        #[doc = "Values that can be written to the field `CPUDIV`"]
        pub enum CPUDIVW {
            #[doc = "Divide by 1"]
            DIV1,
            #[doc = "Divide by 2"]
            DIV2,
            #[doc = "Divide by 4"]
            DIV4,
            #[doc = "Divide by 8"]
            DIV8,
            #[doc = "Divide by 16"]
            DIV16,
            #[doc = "Divide by 32"]
            DIV32,
            #[doc = "Divide by 64"]
            DIV64,
            #[doc = "Divide by 128"]
            DIV128,
        }
        impl CPUDIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CPUDIVW::DIV1 => 0,
                    CPUDIVW::DIV2 => 1,
                    CPUDIVW::DIV4 => 2,
                    CPUDIVW::DIV8 => 3,
                    CPUDIVW::DIV16 => 4,
                    CPUDIVW::DIV32 => 5,
                    CPUDIVW::DIV64 => 6,
                    CPUDIVW::DIV128 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPUDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPUDIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPUDIVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divide by 1"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV1)
            }
            #[doc = "Divide by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV2)
            }
            #[doc = "Divide by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV4)
            }
            #[doc = "Divide by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV8)
            }
            #[doc = "Divide by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV16)
            }
            #[doc = "Divide by 32"]
            #[inline]
            pub fn div32(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV32)
            }
            #[doc = "Divide by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV64)
            }
            #[doc = "Divide by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(CPUDIVW::DIV128)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:2 - CPU Prescaler Selection"]
            #[inline]
            pub fn cpudiv(&self) -> CPUDIVR {
                CPUDIVR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - CPU Prescaler Selection"]
            #[inline]
            pub fn cpudiv(&mut self) -> _CPUDIVW {
                _CPUDIVW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready Interrupt Enable"]
            #[inline]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKRDYR {
            bits: bool,
        }
        impl CKRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Clock Ready"]
            #[inline]
            pub fn ckrdy(&self) -> CKRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CKRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clock Ready"]
            #[inline]
            pub fn ckrdy(&mut self) -> _CKRDYW {
                _CKRDYW { w: self }
            }
        }
    }
    #[doc = "Reset Cause"]
    pub struct RCAUSE {
        register: VolatileCell<u8>,
    }
    #[doc = "Reset Cause"]
    pub mod rcause {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::RCAUSE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORR {
            bits: bool,
        }
        impl PORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD12R {
            bits: bool,
        }
        impl BOD12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33R {
            bits: bool,
        }
        impl BOD33R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTR {
            bits: bool,
        }
        impl EXTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTR {
            bits: bool,
        }
        impl WDTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYSTR {
            bits: bool,
        }
        impl SYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Power On Reset"]
            #[inline]
            pub fn por(&self) -> PORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PORR { bits }
            }
            #[doc = "Bit 1 - Brown Out 12 Detector Reset"]
            #[inline]
            pub fn bod12(&self) -> BOD12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BOD12R { bits }
            }
            #[doc = "Bit 2 - Brown Out 33 Detector Reset"]
            #[inline]
            pub fn bod33(&self) -> BOD33R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                BOD33R { bits }
            }
            #[doc = "Bit 4 - External Reset"]
            #[inline]
            pub fn ext(&self) -> EXTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EXTR { bits }
            }
            #[doc = "Bit 5 - Watchdog Reset"]
            #[inline]
            pub fn wdt(&self) -> WDTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WDTR { bits }
            }
            #[doc = "Bit 6 - System Reset Request"]
            #[inline]
            pub fn syst(&self) -> SYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYSTR { bits }
            }
        }
    }
    #[doc = "Sleep Mode"]
    pub struct SLEEP {
        register: VolatileCell<u8>,
    }
    #[doc = "Sleep Mode"]
    pub mod sleep {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::SLEEP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IDLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLER {
            #[doc = "The CPU clock domain is stopped"]
            CPU,
            #[doc = "The CPU and AHB clock domains are stopped"]
            AHB,
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            APB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IDLER::CPU => 0,
                    IDLER::AHB => 0x01,
                    IDLER::APB => 0x02,
                    IDLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IDLER {
                match value {
                    0 => IDLER::CPU,
                    1 => IDLER::AHB,
                    2 => IDLER::APB,
                    i => IDLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CPU`"]
            #[inline]
            pub fn is_cpu(&self) -> bool {
                *self == IDLER::CPU
            }
            #[doc = "Checks if the value of the field is `AHB`"]
            #[inline]
            pub fn is_ahb(&self) -> bool {
                *self == IDLER::AHB
            }
            #[doc = "Checks if the value of the field is `APB`"]
            #[inline]
            pub fn is_apb(&self) -> bool {
                *self == IDLER::APB
            }
        }
        #[doc = "Values that can be written to the field `IDLE`"]
        pub enum IDLEW {
            #[doc = "The CPU clock domain is stopped"]
            CPU,
            #[doc = "The CPU and AHB clock domains are stopped"]
            AHB,
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            APB,
        }
        impl IDLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IDLEW::CPU => 0,
                    IDLEW::AHB => 1,
                    IDLEW::APB => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IDLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "The CPU clock domain is stopped"]
            #[inline]
            pub fn cpu(self) -> &'a mut W {
                self.variant(IDLEW::CPU)
            }
            #[doc = "The CPU and AHB clock domains are stopped"]
            #[inline]
            pub fn ahb(self) -> &'a mut W {
                self.variant(IDLEW::AHB)
            }
            #[doc = "The CPU, AHB and APB clock domains are stopped"]
            #[inline]
            pub fn apb(self) -> &'a mut W {
                self.variant(IDLEW::APB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:1 - Idle Mode Configuration"]
            #[inline]
            pub fn idle(&self) -> IDLER {
                IDLER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Idle Mode Configuration"]
            #[inline]
            pub fn idle(&mut self) -> _IDLEW {
                _IDLEW { w: self }
            }
        }
    }
}
#[doc = "Power Manager"]
pub struct PM {
    register_block: pm::RegisterBlock,
}
impl Deref for PM {
    type Target = pm::RegisterBlock;
    fn deref(&self) -> &pm::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Port Module"]
pub const PORT: Peripheral<PORT> = unsafe { Peripheral::new(0x4100_4400) };
#[doc = "Port Module"]
pub mod port {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data Direction"]
        pub dir: DIR,
        #[doc = "0x04 - Data Direction Clear"]
        pub dirclr: DIRCLR,
        #[doc = "0x08 - Data Direction Set"]
        pub dirset: DIRSET,
        #[doc = "0x0c - Data Direction Toggle"]
        pub dirtgl: DIRTGL,
        #[doc = "0x10 - Data Output Value"]
        pub out: OUT,
        #[doc = "0x14 - Data Output Value Clear"]
        pub outclr: OUTCLR,
        #[doc = "0x18 - Data Output Value Set"]
        pub outset: OUTSET,
        #[doc = "0x1c - Data Output Value Toggle"]
        pub outtgl: OUTTGL,
        #[doc = "0x20 - Data Input Value"]
        pub in_: IN,
        #[doc = "0x24 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x28 - Write Configuration"]
        pub wrconfig: WRCONFIG,
        _reserved0: [u8; 4usize],
        #[doc = "0x30 - Peripheral Multiplexing n - Group 0"]
        pub pmux0_: [PMUX0_; 16],
        #[doc = "0x40 - Pin Configuration n - Group 0"]
        pub pincfg: [PINCFG; 32],
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLINGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Input Sampling Mode"]
            #[inline]
            pub fn sampling(&mut self) -> _SAMPLINGW {
                _SAMPLINGW { w: self }
            }
        }
    }
    #[doc = "Data Direction"]
    pub struct DIR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction"]
    pub mod dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: u32,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction"]
            #[inline]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction"]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
        }
    }
    #[doc = "Data Direction Clear"]
    pub struct DIRCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Clear"]
    pub mod dirclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRCLRR {
            bits: u32,
        }
        impl DIRCLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRCLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Clear"]
            #[inline]
            pub fn dirclr(&self) -> DIRCLRR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRCLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Clear"]
            #[inline]
            pub fn dirclr(&mut self) -> _DIRCLRW {
                _DIRCLRW { w: self }
            }
        }
    }
    #[doc = "Data Direction Set"]
    pub struct DIRSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Set"]
    pub mod dirset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRSETR {
            bits: u32,
        }
        impl DIRSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Set"]
            #[inline]
            pub fn dirset(&self) -> DIRSETR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Set"]
            #[inline]
            pub fn dirset(&mut self) -> _DIRSETW {
                _DIRSETW { w: self }
            }
        }
    }
    #[doc = "Data Direction Toggle"]
    pub struct DIRTGL {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Direction Toggle"]
    pub mod dirtgl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRTGL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRTGLR {
            bits: u32,
        }
        impl DIRTGLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRTGLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRTGLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Direction Toggle"]
            #[inline]
            pub fn dirtgl(&self) -> DIRTGLR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRTGLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Direction Toggle"]
            #[inline]
            pub fn dirtgl(&mut self) -> _DIRTGLW {
                _DIRTGLW { w: self }
            }
        }
    }
    #[doc = "Data Input Value"]
    pub struct IN {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Input Value"]
    pub mod in_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IN {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct INR {
            bits: u32,
        }
        impl INR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Input Value"]
            #[inline]
            pub fn in_(&self) -> INR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                INR { bits }
            }
        }
    }
    #[doc = "Data Output Value"]
    pub struct OUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value"]
    pub mod out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTR {
            bits: u32,
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value"]
            #[inline]
            pub fn out(&self) -> OUTR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value"]
            #[inline]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Clear"]
    pub struct OUTCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Clear"]
    pub mod outclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTCLRR {
            bits: u32,
        }
        impl OUTCLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTCLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Clear"]
            #[inline]
            pub fn outclr(&self) -> OUTCLRR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTCLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Clear"]
            #[inline]
            pub fn outclr(&mut self) -> _OUTCLRW {
                _OUTCLRW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Set"]
    pub struct OUTSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Set"]
    pub mod outset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTSETR {
            bits: u32,
        }
        impl OUTSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Set"]
            #[inline]
            pub fn outset(&self) -> OUTSETR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Set"]
            #[inline]
            pub fn outset(&mut self) -> _OUTSETW {
                _OUTSETW { w: self }
            }
        }
    }
    #[doc = "Data Output Value Toggle"]
    pub struct OUTTGL {
        register: VolatileCell<u32>,
    }
    #[doc = "Data Output Value Toggle"]
    pub mod outtgl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTTGL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTTGLR {
            bits: u32,
        }
        impl OUTTGLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTTGLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTTGLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Port Data Output Value Toggle"]
            #[inline]
            pub fn outtgl(&self) -> OUTTGLR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OUTTGLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Port Data Output Value Toggle"]
            #[inline]
            pub fn outtgl(&mut self) -> _OUTTGLW {
                _OUTTGLW { w: self }
            }
        }
    }
    #[doc = "Pin Configuration n - Group 0"]
    pub struct PINCFG {
        register: VolatileCell<u8>,
    }
    #[doc = "Pin Configuration n - Group 0"]
    pub mod pincfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::PINCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMUXENR {
            bits: bool,
        }
        impl PMUXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INENR {
            bits: bool,
        }
        impl INENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PULLENR {
            bits: bool,
        }
        impl PULLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PULLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PULLENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRVSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRVSTRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral Multiplexer Enable"]
            #[inline]
            pub fn pmuxen(&self) -> PMUXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PMUXENR { bits }
            }
            #[doc = "Bit 1 - Input Enable"]
            #[inline]
            pub fn inen(&self) -> INENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                INENR { bits }
            }
            #[doc = "Bit 2 - Pull Enable"]
            #[inline]
            pub fn pullen(&self) -> PULLENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PULLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral Multiplexer Enable"]
            #[inline]
            pub fn pmuxen(&mut self) -> _PMUXENW {
                _PMUXENW { w: self }
            }
            #[doc = "Bit 1 - Input Enable"]
            #[inline]
            pub fn inen(&mut self) -> _INENW {
                _INENW { w: self }
            }
            #[doc = "Bit 2 - Pull Enable"]
            #[inline]
            pub fn pullen(&mut self) -> _PULLENW {
                _PULLENW { w: self }
            }
            #[doc = "Bit 6 - Output Driver Strength Selection"]
            #[inline]
            pub fn drvstr(&mut self) -> _DRVSTRW {
                _DRVSTRW { w: self }
            }
        }
    }
    #[doc = "Peripheral Multiplexing n - Group 0"]
    pub struct PMUX0_ {
        register: VolatileCell<u8>,
    }
    #[doc = "Peripheral Multiplexing n - Group 0"]
    pub mod pmux0_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::PMUX0_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PMUXE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMUXER {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMUXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMUXER::A => 0,
                    PMUXER::B => 0x01,
                    PMUXER::C => 0x02,
                    PMUXER::D => 0x03,
                    PMUXER::E => 0x04,
                    PMUXER::F => 0x05,
                    PMUXER::G => 0x06,
                    PMUXER::H => 0x07,
                    PMUXER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PMUXER {
                match value {
                    0 => PMUXER::A,
                    1 => PMUXER::B,
                    2 => PMUXER::C,
                    3 => PMUXER::D,
                    4 => PMUXER::E,
                    5 => PMUXER::F,
                    6 => PMUXER::G,
                    7 => PMUXER::H,
                    i => PMUXER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline]
            pub fn is_a(&self) -> bool {
                *self == PMUXER::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline]
            pub fn is_b(&self) -> bool {
                *self == PMUXER::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline]
            pub fn is_c(&self) -> bool {
                *self == PMUXER::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline]
            pub fn is_d(&self) -> bool {
                *self == PMUXER::D
            }
            #[doc = "Checks if the value of the field is `E`"]
            #[inline]
            pub fn is_e(&self) -> bool {
                *self == PMUXER::E
            }
            #[doc = "Checks if the value of the field is `F`"]
            #[inline]
            pub fn is_f(&self) -> bool {
                *self == PMUXER::F
            }
            #[doc = "Checks if the value of the field is `G`"]
            #[inline]
            pub fn is_g(&self) -> bool {
                *self == PMUXER::G
            }
            #[doc = "Checks if the value of the field is `H`"]
            #[inline]
            pub fn is_h(&self) -> bool {
                *self == PMUXER::H
            }
        }
        #[doc = "Possible values of the field `PMUXO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMUXOR {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMUXOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMUXOR::A => 0,
                    PMUXOR::B => 0x01,
                    PMUXOR::C => 0x02,
                    PMUXOR::D => 0x03,
                    PMUXOR::E => 0x04,
                    PMUXOR::F => 0x05,
                    PMUXOR::G => 0x06,
                    PMUXOR::H => 0x07,
                    PMUXOR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PMUXOR {
                match value {
                    0 => PMUXOR::A,
                    1 => PMUXOR::B,
                    2 => PMUXOR::C,
                    3 => PMUXOR::D,
                    4 => PMUXOR::E,
                    5 => PMUXOR::F,
                    6 => PMUXOR::G,
                    7 => PMUXOR::H,
                    i => PMUXOR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline]
            pub fn is_a(&self) -> bool {
                *self == PMUXOR::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline]
            pub fn is_b(&self) -> bool {
                *self == PMUXOR::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline]
            pub fn is_c(&self) -> bool {
                *self == PMUXOR::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline]
            pub fn is_d(&self) -> bool {
                *self == PMUXOR::D
            }
            #[doc = "Checks if the value of the field is `E`"]
            #[inline]
            pub fn is_e(&self) -> bool {
                *self == PMUXOR::E
            }
            #[doc = "Checks if the value of the field is `F`"]
            #[inline]
            pub fn is_f(&self) -> bool {
                *self == PMUXOR::F
            }
            #[doc = "Checks if the value of the field is `G`"]
            #[inline]
            pub fn is_g(&self) -> bool {
                *self == PMUXOR::G
            }
            #[doc = "Checks if the value of the field is `H`"]
            #[inline]
            pub fn is_h(&self) -> bool {
                *self == PMUXOR::H
            }
        }
        #[doc = "Values that can be written to the field `PMUXE`"]
        pub enum PMUXEW {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
        }
        impl PMUXEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMUXEW::A => 0,
                    PMUXEW::B => 1,
                    PMUXEW::C => 2,
                    PMUXEW::D => 3,
                    PMUXEW::E => 4,
                    PMUXEW::F => 5,
                    PMUXEW::G => 6,
                    PMUXEW::H => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PMUXEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Peripheral function A selected"]
            #[inline]
            pub fn a(self) -> &'a mut W {
                self.variant(PMUXEW::A)
            }
            #[doc = "Peripheral function B selected"]
            #[inline]
            pub fn b(self) -> &'a mut W {
                self.variant(PMUXEW::B)
            }
            #[doc = "Peripheral function C selected"]
            #[inline]
            pub fn c(self) -> &'a mut W {
                self.variant(PMUXEW::C)
            }
            #[doc = "Peripheral function D selected"]
            #[inline]
            pub fn d(self) -> &'a mut W {
                self.variant(PMUXEW::D)
            }
            #[doc = "Peripheral function E selected"]
            #[inline]
            pub fn e(self) -> &'a mut W {
                self.variant(PMUXEW::E)
            }
            #[doc = "Peripheral function F selected"]
            #[inline]
            pub fn f(self) -> &'a mut W {
                self.variant(PMUXEW::F)
            }
            #[doc = "Peripheral function G selected"]
            #[inline]
            pub fn g(self) -> &'a mut W {
                self.variant(PMUXEW::G)
            }
            #[doc = "Peripheral function H selected"]
            #[inline]
            pub fn h(self) -> &'a mut W {
                self.variant(PMUXEW::H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PMUXO`"]
        pub enum PMUXOW {
            #[doc = "Peripheral function A selected"]
            A,
            #[doc = "Peripheral function B selected"]
            B,
            #[doc = "Peripheral function C selected"]
            C,
            #[doc = "Peripheral function D selected"]
            D,
            #[doc = "Peripheral function E selected"]
            E,
            #[doc = "Peripheral function F selected"]
            F,
            #[doc = "Peripheral function G selected"]
            G,
            #[doc = "Peripheral function H selected"]
            H,
        }
        impl PMUXOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMUXOW::A => 0,
                    PMUXOW::B => 1,
                    PMUXOW::C => 2,
                    PMUXOW::D => 3,
                    PMUXOW::E => 4,
                    PMUXOW::F => 5,
                    PMUXOW::G => 6,
                    PMUXOW::H => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PMUXOW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Peripheral function A selected"]
            #[inline]
            pub fn a(self) -> &'a mut W {
                self.variant(PMUXOW::A)
            }
            #[doc = "Peripheral function B selected"]
            #[inline]
            pub fn b(self) -> &'a mut W {
                self.variant(PMUXOW::B)
            }
            #[doc = "Peripheral function C selected"]
            #[inline]
            pub fn c(self) -> &'a mut W {
                self.variant(PMUXOW::C)
            }
            #[doc = "Peripheral function D selected"]
            #[inline]
            pub fn d(self) -> &'a mut W {
                self.variant(PMUXOW::D)
            }
            #[doc = "Peripheral function E selected"]
            #[inline]
            pub fn e(self) -> &'a mut W {
                self.variant(PMUXOW::E)
            }
            #[doc = "Peripheral function F selected"]
            #[inline]
            pub fn f(self) -> &'a mut W {
                self.variant(PMUXOW::F)
            }
            #[doc = "Peripheral function G selected"]
            #[inline]
            pub fn g(self) -> &'a mut W {
                self.variant(PMUXOW::G)
            }
            #[doc = "Peripheral function H selected"]
            #[inline]
            pub fn h(self) -> &'a mut W {
                self.variant(PMUXOW::H)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Peripheral Multiplexing Even"]
            #[inline]
            pub fn pmuxe(&self) -> PMUXER {
                PMUXER::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
            #[inline]
            pub fn pmuxo(&self) -> PMUXOR {
                PMUXOR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Peripheral Multiplexing Even"]
            #[inline]
            pub fn pmuxe(&mut self) -> _PMUXEW {
                _PMUXEW { w: self }
            }
            #[doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
            #[inline]
            pub fn pmuxo(&mut self) -> _PMUXOW {
                _PMUXOW { w: self }
            }
        }
    }
    #[doc = "Write Configuration"]
    pub struct WRCONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Write Configuration"]
    pub mod wrconfig {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WRCONFIG {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINMASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINMASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PULLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PULLENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRVSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRVSTRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMUXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRPMUXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRPMUXW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRPINCFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRPINCFGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HWSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HWSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Pin Mask for Multiple Pin Configuration"]
            #[inline]
            pub fn pinmask(&mut self) -> _PINMASKW {
                _PINMASKW { w: self }
            }
            #[doc = "Bit 16 - Peripheral Multiplexer Enable"]
            #[inline]
            pub fn pmuxen(&mut self) -> _PMUXENW {
                _PMUXENW { w: self }
            }
            #[doc = "Bit 17 - Input Enable"]
            #[inline]
            pub fn inen(&mut self) -> _INENW {
                _INENW { w: self }
            }
            #[doc = "Bit 18 - Pull Enable"]
            #[inline]
            pub fn pullen(&mut self) -> _PULLENW {
                _PULLENW { w: self }
            }
            #[doc = "Bit 22 - Output Driver Strength Selection"]
            #[inline]
            pub fn drvstr(&mut self) -> _DRVSTRW {
                _DRVSTRW { w: self }
            }
            #[doc = "Bits 24:27 - Peripheral Multiplexing"]
            #[inline]
            pub fn pmux(&mut self) -> _PMUXW {
                _PMUXW { w: self }
            }
            #[doc = "Bit 28 - Write PMUX"]
            #[inline]
            pub fn wrpmux(&mut self) -> _WRPMUXW {
                _WRPMUXW { w: self }
            }
            #[doc = "Bit 30 - Write PINCFG"]
            #[inline]
            pub fn wrpincfg(&mut self) -> _WRPINCFGW {
                _WRPINCFGW { w: self }
            }
            #[doc = "Bit 31 - Half-Word Select"]
            #[inline]
            pub fn hwsel(&mut self) -> _HWSELW {
                _HWSELW { w: self }
            }
        }
    }
}
#[doc = "Port Module"]
pub struct PORT {
    register_block: port::RegisterBlock,
}
impl Deref for PORT {
    type Target = port::RegisterBlock;
    fn deref(&self) -> &port::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Serial Communication Interface 0"]
pub const SERCOM0: Peripheral<SERCOM0> = unsafe { Peripheral::new(0x4200_0800) };
#[doc = "Serial Communication Interface 0"]
pub mod sercom0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USART Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x04 - USART Control B"]
        pub ctrlb: CTRLB,
        #[doc = "0x08 - USART Debug Control"]
        pub dbgctrl: DBGCTRL,
        _reserved0: [u8; 1usize],
        #[doc = "0x0a - USART Baud"]
        pub baud: BAUD,
        #[doc = "0x0c - USART Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x0d - USART Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x0e - USART Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        _reserved1: [u8; 1usize],
        #[doc = "0x10 - USART Status"]
        pub status: STATUS,
        _reserved2: [u8; 6usize],
        #[doc = "0x18 - USART Data"]
        pub data: DATA,
    }
    #[doc = "USART Baud"]
    pub struct BAUD {
        register: VolatileCell<u16>,
    }
    #[doc = "USART Baud"]
    pub mod baud {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::BAUD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BAUDR {
            bits: u16,
        }
        impl BAUDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BAUDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BAUDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Baud Value"]
            #[inline]
            pub fn baud(&self) -> BAUDR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                BAUDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Baud Value"]
            #[inline]
            pub fn baud(&mut self) -> _BAUDW {
                _BAUDW { w: self }
            }
        }
    }
    #[doc = "USART Control A"]
    pub struct CTRLA {
        register: VolatileCell<u32>,
    }
    #[doc = "USART Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWRSTR {
            bits: bool,
        }
        impl SWRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "USART mode with external clock"]
            USART_EXT_CLK,
            #[doc = "USART mode with internal clock"]
            USART_INT_CLK,
            #[doc = "SPI mode with external clock"]
            SPI_SLAVE,
            #[doc = "SPI mode with internal clock"]
            SPI_MASTER,
            #[doc = "I2C mode with external clock"]
            I2C_SLAVE,
            #[doc = "I2C mode with internal clock"]
            I2C_MASTER,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::USART_EXT_CLK => 0,
                    MODER::USART_INT_CLK => 0x01,
                    MODER::SPI_SLAVE => 0x02,
                    MODER::SPI_MASTER => 0x03,
                    MODER::I2C_SLAVE => 0x04,
                    MODER::I2C_MASTER => 0x05,
                    MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::USART_EXT_CLK,
                    1 => MODER::USART_INT_CLK,
                    2 => MODER::SPI_SLAVE,
                    3 => MODER::SPI_MASTER,
                    4 => MODER::I2C_SLAVE,
                    5 => MODER::I2C_MASTER,
                    i => MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `USART_EXT_CLK`"]
            #[inline]
            pub fn is_usart_ext_clk(&self) -> bool {
                *self == MODER::USART_EXT_CLK
            }
            #[doc = "Checks if the value of the field is `USART_INT_CLK`"]
            #[inline]
            pub fn is_usart_int_clk(&self) -> bool {
                *self == MODER::USART_INT_CLK
            }
            #[doc = "Checks if the value of the field is `SPI_SLAVE`"]
            #[inline]
            pub fn is_spi_slave(&self) -> bool {
                *self == MODER::SPI_SLAVE
            }
            #[doc = "Checks if the value of the field is `SPI_MASTER`"]
            #[inline]
            pub fn is_spi_master(&self) -> bool {
                *self == MODER::SPI_MASTER
            }
            #[doc = "Checks if the value of the field is `I2C_SLAVE`"]
            #[inline]
            pub fn is_i2c_slave(&self) -> bool {
                *self == MODER::I2C_SLAVE
            }
            #[doc = "Checks if the value of the field is `I2C_MASTER`"]
            #[inline]
            pub fn is_i2c_master(&self) -> bool {
                *self == MODER::I2C_MASTER
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBONR {
            bits: bool,
        }
        impl IBONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `TXPO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXPOR {
            #[doc = "TXD at PAD0, XCK at PAD1"]
            PAD0,
            #[doc = "TXD at PAD2, XCK at PAD3"]
            PAD2,
        }
        impl TXPOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXPOR::PAD0 => false,
                    TXPOR::PAD2 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXPOR {
                match value {
                    false => TXPOR::PAD0,
                    true => TXPOR::PAD2,
                }
            }
            #[doc = "Checks if the value of the field is `PAD0`"]
            #[inline]
            pub fn is_pad0(&self) -> bool {
                *self == TXPOR::PAD0
            }
            #[doc = "Checks if the value of the field is `PAD2`"]
            #[inline]
            pub fn is_pad2(&self) -> bool {
                *self == TXPOR::PAD2
            }
        }
        #[doc = "Possible values of the field `RXPO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXPOR {
            #[doc = "SERCOM_PAD0"]
            PAD0,
            #[doc = "SERCOM_PAD1"]
            PAD1,
            #[doc = "SERCOM_PAD2"]
            PAD2,
            #[doc = "SERCOM_PAD3"]
            PAD3,
        }
        impl RXPOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RXPOR::PAD0 => 0,
                    RXPOR::PAD1 => 0x01,
                    RXPOR::PAD2 => 0x02,
                    RXPOR::PAD3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RXPOR {
                match value {
                    0 => RXPOR::PAD0,
                    1 => RXPOR::PAD1,
                    2 => RXPOR::PAD2,
                    3 => RXPOR::PAD3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PAD0`"]
            #[inline]
            pub fn is_pad0(&self) -> bool {
                *self == RXPOR::PAD0
            }
            #[doc = "Checks if the value of the field is `PAD1`"]
            #[inline]
            pub fn is_pad1(&self) -> bool {
                *self == RXPOR::PAD1
            }
            #[doc = "Checks if the value of the field is `PAD2`"]
            #[inline]
            pub fn is_pad2(&self) -> bool {
                *self == RXPOR::PAD2
            }
            #[doc = "Checks if the value of the field is `PAD3`"]
            #[inline]
            pub fn is_pad3(&self) -> bool {
                *self == RXPOR::PAD3
            }
        }
        #[doc = "Possible values of the field `FORM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FORMR {
            #[doc = "USART frame"]
            _0,
            #[doc = "USART frame with parity"]
            _1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FORMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FORMR::_0 => 0,
                    FORMR::_1 => 0x01,
                    FORMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FORMR {
                match value {
                    0 => FORMR::_0,
                    1 => FORMR::_1,
                    i => FORMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0`"]
            #[inline]
            pub fn is_0(&self) -> bool {
                *self == FORMR::_0
            }
            #[doc = "Checks if the value of the field is `_1`"]
            #[inline]
            pub fn is_1(&self) -> bool {
                *self == FORMR::_1
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMODER {
            bits: bool,
        }
        impl CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPOLR {
            bits: bool,
        }
        impl CPOLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DORDR {
            bits: bool,
        }
        impl DORDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "USART mode with external clock"]
            USART_EXT_CLK,
            #[doc = "USART mode with internal clock"]
            USART_INT_CLK,
            #[doc = "SPI mode with external clock"]
            SPI_SLAVE,
            #[doc = "SPI mode with internal clock"]
            SPI_MASTER,
            #[doc = "I2C mode with external clock"]
            I2C_SLAVE,
            #[doc = "I2C mode with internal clock"]
            I2C_MASTER,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::USART_EXT_CLK => 0,
                    MODEW::USART_INT_CLK => 1,
                    MODEW::SPI_SLAVE => 2,
                    MODEW::SPI_MASTER => 3,
                    MODEW::I2C_SLAVE => 4,
                    MODEW::I2C_MASTER => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "USART mode with external clock"]
            #[inline]
            pub fn usart_ext_clk(self) -> &'a mut W {
                self.variant(MODEW::USART_EXT_CLK)
            }
            #[doc = "USART mode with internal clock"]
            #[inline]
            pub fn usart_int_clk(self) -> &'a mut W {
                self.variant(MODEW::USART_INT_CLK)
            }
            #[doc = "SPI mode with external clock"]
            #[inline]
            pub fn spi_slave(self) -> &'a mut W {
                self.variant(MODEW::SPI_SLAVE)
            }
            #[doc = "SPI mode with internal clock"]
            #[inline]
            pub fn spi_master(self) -> &'a mut W {
                self.variant(MODEW::SPI_MASTER)
            }
            #[doc = "I2C mode with external clock"]
            #[inline]
            pub fn i2c_slave(self) -> &'a mut W {
                self.variant(MODEW::I2C_SLAVE)
            }
            #[doc = "I2C mode with internal clock"]
            #[inline]
            pub fn i2c_master(self) -> &'a mut W {
                self.variant(MODEW::I2C_MASTER)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXPO`"]
        pub enum TXPOW {
            #[doc = "TXD at PAD0, XCK at PAD1"]
            PAD0,
            #[doc = "TXD at PAD2, XCK at PAD3"]
            PAD2,
        }
        impl TXPOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXPOW::PAD0 => false,
                    TXPOW::PAD2 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXPOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXPOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXPOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TXD at PAD0, XCK at PAD1"]
            #[inline]
            pub fn pad0(self) -> &'a mut W {
                self.variant(TXPOW::PAD0)
            }
            #[doc = "TXD at PAD2, XCK at PAD3"]
            #[inline]
            pub fn pad2(self) -> &'a mut W {
                self.variant(TXPOW::PAD2)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXPO`"]
        pub enum RXPOW {
            #[doc = "SERCOM_PAD0"]
            PAD0,
            #[doc = "SERCOM_PAD1"]
            PAD1,
            #[doc = "SERCOM_PAD2"]
            PAD2,
            #[doc = "SERCOM_PAD3"]
            PAD3,
        }
        impl RXPOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RXPOW::PAD0 => 0,
                    RXPOW::PAD1 => 1,
                    RXPOW::PAD2 => 2,
                    RXPOW::PAD3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXPOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXPOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXPOW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "SERCOM_PAD0"]
            #[inline]
            pub fn pad0(self) -> &'a mut W {
                self.variant(RXPOW::PAD0)
            }
            #[doc = "SERCOM_PAD1"]
            #[inline]
            pub fn pad1(self) -> &'a mut W {
                self.variant(RXPOW::PAD1)
            }
            #[doc = "SERCOM_PAD2"]
            #[inline]
            pub fn pad2(self) -> &'a mut W {
                self.variant(RXPOW::PAD2)
            }
            #[doc = "SERCOM_PAD3"]
            #[inline]
            pub fn pad3(self) -> &'a mut W {
                self.variant(RXPOW::PAD3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FORM`"]
        pub enum FORMW {
            #[doc = "USART frame"]
            _0,
            #[doc = "USART frame with parity"]
            _1,
        }
        impl FORMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FORMW::_0 => 0,
                    FORMW::_1 => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FORMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FORMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FORMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "USART frame"]
            #[inline]
            pub fn _0(self) -> &'a mut W {
                self.variant(FORMW::_0)
            }
            #[doc = "USART frame with parity"]
            #[inline]
            pub fn _1(self) -> &'a mut W {
                self.variant(FORMW::_1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DORDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DORDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWRSTR { bits }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bits 2:4 - Operating Mode"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Run In Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 8 - Immediate Buffer Overflow Notification"]
            #[inline]
            pub fn ibon(&self) -> IBONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBONR { bits }
            }
            #[doc = "Bit 16 - Transmit Data Pinout"]
            #[inline]
            pub fn txpo(&self) -> TXPOR {
                TXPOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 20:21 - Receive Data Pinout"]
            #[inline]
            pub fn rxpo(&self) -> RXPOR {
                RXPOR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:27 - Frame Format"]
            #[inline]
            pub fn form(&self) -> FORMR {
                FORMR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 28 - Communication Mode"]
            #[inline]
            pub fn cmode(&self) -> CMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMODER { bits }
            }
            #[doc = "Bit 29 - Clock Polarity"]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPOLR { bits }
            }
            #[doc = "Bit 30 - Data Order"]
            #[inline]
            pub fn dord(&self) -> DORDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DORDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bits 2:4 - Operating Mode"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 7 - Run In Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 8 - Immediate Buffer Overflow Notification"]
            #[inline]
            pub fn ibon(&mut self) -> _IBONW {
                _IBONW { w: self }
            }
            #[doc = "Bit 16 - Transmit Data Pinout"]
            #[inline]
            pub fn txpo(&mut self) -> _TXPOW {
                _TXPOW { w: self }
            }
            #[doc = "Bits 20:21 - Receive Data Pinout"]
            #[inline]
            pub fn rxpo(&mut self) -> _RXPOW {
                _RXPOW { w: self }
            }
            #[doc = "Bits 24:27 - Frame Format"]
            #[inline]
            pub fn form(&mut self) -> _FORMW {
                _FORMW { w: self }
            }
            #[doc = "Bit 28 - Communication Mode"]
            #[inline]
            pub fn cmode(&mut self) -> _CMODEW {
                _CMODEW { w: self }
            }
            #[doc = "Bit 29 - Clock Polarity"]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 30 - Data Order"]
            #[inline]
            pub fn dord(&mut self) -> _DORDW {
                _DORDW { w: self }
            }
        }
    }
    #[doc = "USART Control B"]
    pub struct CTRLB {
        register: VolatileCell<u32>,
    }
    #[doc = "USART Control B"]
    pub mod ctrlb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHSIZER {
            bits: u8,
        }
        impl CHSIZER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBMODER {
            bits: bool,
        }
        impl SBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SFDER {
            bits: bool,
        }
        impl SFDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMODER {
            bits: bool,
        }
        impl PMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENR {
            bits: bool,
        }
        impl TXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXENR {
            bits: bool,
        }
        impl RXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHSIZEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHSIZEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SFDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SFDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Character Size"]
            #[inline]
            pub fn chsize(&self) -> CHSIZER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHSIZER { bits }
            }
            #[doc = "Bit 6 - Stop Bit Mode"]
            #[inline]
            pub fn sbmode(&self) -> SBMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBMODER { bits }
            }
            #[doc = "Bit 9 - Start of Frame Detection Enable"]
            #[inline]
            pub fn sfde(&self) -> SFDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SFDER { bits }
            }
            #[doc = "Bit 13 - Parity Mode"]
            #[inline]
            pub fn pmode(&self) -> PMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PMODER { bits }
            }
            #[doc = "Bit 16 - Transmitter Enable"]
            #[inline]
            pub fn txen(&self) -> TXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENR { bits }
            }
            #[doc = "Bit 17 - Receiver Enable"]
            #[inline]
            pub fn rxen(&self) -> RXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Character Size"]
            #[inline]
            pub fn chsize(&mut self) -> _CHSIZEW {
                _CHSIZEW { w: self }
            }
            #[doc = "Bit 6 - Stop Bit Mode"]
            #[inline]
            pub fn sbmode(&mut self) -> _SBMODEW {
                _SBMODEW { w: self }
            }
            #[doc = "Bit 9 - Start of Frame Detection Enable"]
            #[inline]
            pub fn sfde(&mut self) -> _SFDEW {
                _SFDEW { w: self }
            }
            #[doc = "Bit 13 - Parity Mode"]
            #[inline]
            pub fn pmode(&mut self) -> _PMODEW {
                _PMODEW { w: self }
            }
            #[doc = "Bit 16 - Transmitter Enable"]
            #[inline]
            pub fn txen(&mut self) -> _TXENW {
                _TXENW { w: self }
            }
            #[doc = "Bit 17 - Receiver Enable"]
            #[inline]
            pub fn rxen(&mut self) -> _RXENW {
                _RXENW { w: self }
            }
        }
    }
    #[doc = "USART Data"]
    pub struct DATA {
        register: VolatileCell<u16>,
    }
    #[doc = "USART Data"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:8 - Data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "USART Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "USART Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGSTOPR {
            bits: bool,
        }
        impl DBGSTOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGSTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGSTOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Stop Mode"]
            #[inline]
            pub fn dbgstop(&self) -> DBGSTOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGSTOPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Stop Mode"]
            #[inline]
            pub fn dbgstop(&mut self) -> _DBGSTOPW {
                _DBGSTOPW { w: self }
            }
        }
    }
    #[doc = "USART Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "USART Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRER {
            bits: bool,
        }
        impl DRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXCR {
            bits: bool,
        }
        impl TXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCR {
            bits: bool,
        }
        impl RXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSR {
            bits: bool,
        }
        impl RXSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DREW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Data Register Empty Interrupt Enable"]
            #[inline]
            pub fn dre(&self) -> DRER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DRER { bits }
            }
            #[doc = "Bit 1 - Transmit Complete Interrupt Enable"]
            #[inline]
            pub fn txc(&self) -> TXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TXCR { bits }
            }
            #[doc = "Bit 2 - Receive Complete Interrupt Enable"]
            #[inline]
            pub fn rxc(&self) -> RXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RXCR { bits }
            }
            #[doc = "Bit 3 - Receive Start Interrupt Disable"]
            #[inline]
            pub fn rxs(&self) -> RXSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RXSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Data Register Empty Interrupt Enable"]
            #[inline]
            pub fn dre(&mut self) -> _DREW {
                _DREW { w: self }
            }
            #[doc = "Bit 1 - Transmit Complete Interrupt Enable"]
            #[inline]
            pub fn txc(&mut self) -> _TXCW {
                _TXCW { w: self }
            }
            #[doc = "Bit 2 - Receive Complete Interrupt Enable"]
            #[inline]
            pub fn rxc(&mut self) -> _RXCW {
                _RXCW { w: self }
            }
            #[doc = "Bit 3 - Receive Start Interrupt Disable"]
            #[inline]
            pub fn rxs(&mut self) -> _RXSW {
                _RXSW { w: self }
            }
        }
    }
    #[doc = "USART Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "USART Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRER {
            bits: bool,
        }
        impl DRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXCR {
            bits: bool,
        }
        impl TXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCR {
            bits: bool,
        }
        impl RXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSR {
            bits: bool,
        }
        impl RXSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DREW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Data Register Empty Interrupt Enable"]
            #[inline]
            pub fn dre(&self) -> DRER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DRER { bits }
            }
            #[doc = "Bit 1 - Transmit Complete Interrupt Enable"]
            #[inline]
            pub fn txc(&self) -> TXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TXCR { bits }
            }
            #[doc = "Bit 2 - Receive Complete Interrupt Enable"]
            #[inline]
            pub fn rxc(&self) -> RXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RXCR { bits }
            }
            #[doc = "Bit 3 - Receive Start Interrupt Enable"]
            #[inline]
            pub fn rxs(&self) -> RXSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RXSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Data Register Empty Interrupt Enable"]
            #[inline]
            pub fn dre(&mut self) -> _DREW {
                _DREW { w: self }
            }
            #[doc = "Bit 1 - Transmit Complete Interrupt Enable"]
            #[inline]
            pub fn txc(&mut self) -> _TXCW {
                _TXCW { w: self }
            }
            #[doc = "Bit 2 - Receive Complete Interrupt Enable"]
            #[inline]
            pub fn rxc(&mut self) -> _RXCW {
                _RXCW { w: self }
            }
            #[doc = "Bit 3 - Receive Start Interrupt Enable"]
            #[inline]
            pub fn rxs(&mut self) -> _RXSW {
                _RXSW { w: self }
            }
        }
    }
    #[doc = "USART Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "USART Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRER {
            bits: bool,
        }
        impl DRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXCR {
            bits: bool,
        }
        impl TXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCR {
            bits: bool,
        }
        impl RXCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Data Register Empty"]
            #[inline]
            pub fn dre(&self) -> DRER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DRER { bits }
            }
            #[doc = "Bit 1 - Transmit Complete"]
            #[inline]
            pub fn txc(&self) -> TXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                TXCR { bits }
            }
            #[doc = "Bit 2 - Receive Complete"]
            #[inline]
            pub fn rxc(&self) -> RXCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                RXCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Transmit Complete"]
            #[inline]
            pub fn txc(&mut self) -> _TXCW {
                _TXCW { w: self }
            }
            #[doc = "Bit 3 - Receive Start Interrupt"]
            #[inline]
            pub fn rxs(&mut self) -> _RXSW {
                _RXSW { w: self }
            }
        }
    }
    #[doc = "USART Status"]
    pub struct STATUS {
        register: VolatileCell<u16>,
    }
    #[doc = "USART Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERRR {
            bits: bool,
        }
        impl PERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FERRR {
            bits: bool,
        }
        impl FERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUFOVFR {
            bits: bool,
        }
        impl BUFOVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUFOVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUFOVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 0 - Parity Error"]
            #[inline]
            pub fn perr(&self) -> PERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                PERRR { bits }
            }
            #[doc = "Bit 1 - Frame Error"]
            #[inline]
            pub fn ferr(&self) -> FERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                FERRR { bits }
            }
            #[doc = "Bit 2 - Buffer Overflow"]
            #[inline]
            pub fn bufovf(&self) -> BUFOVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                BUFOVFR { bits }
            }
            #[doc = "Bit 15 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                SYNCBUSYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Parity Error"]
            #[inline]
            pub fn perr(&mut self) -> _PERRW {
                _PERRW { w: self }
            }
            #[doc = "Bit 1 - Frame Error"]
            #[inline]
            pub fn ferr(&mut self) -> _FERRW {
                _FERRW { w: self }
            }
            #[doc = "Bit 2 - Buffer Overflow"]
            #[inline]
            pub fn bufovf(&mut self) -> _BUFOVFW {
                _BUFOVFW { w: self }
            }
        }
    }
}
#[doc = "Serial Communication Interface 0"]
pub struct SERCOM0 {
    register_block: sercom0::RegisterBlock,
}
impl Deref for SERCOM0 {
    type Target = sercom0::RegisterBlock;
    fn deref(&self) -> &sercom0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Serial Communication Interface 1"]
pub const SERCOM1: Peripheral<SERCOM1> = unsafe { Peripheral::new(0x4200_0c00) };
#[doc = r" Register block"]
pub struct SERCOM1 {
    register_block: sercom0::RegisterBlock,
}
impl Deref for SERCOM1 {
    type Target = sercom0::RegisterBlock;
    fn deref(&self) -> &sercom0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Serial Communication Interface 2"]
pub const SERCOM2: Peripheral<SERCOM2> = unsafe { Peripheral::new(0x4200_1000) };
#[doc = r" Register block"]
pub struct SERCOM2 {
    register_block: sercom0::RegisterBlock,
}
impl Deref for SERCOM2 {
    type Target = sercom0::RegisterBlock;
    fn deref(&self) -> &sercom0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Serial Communication Interface 3"]
pub const SERCOM3: Peripheral<SERCOM3> = unsafe { Peripheral::new(0x4200_1400) };
#[doc = r" Register block"]
pub struct SERCOM3 {
    register_block: sercom0::RegisterBlock,
}
impl Deref for SERCOM3 {
    type Target = sercom0::RegisterBlock;
    fn deref(&self) -> &sercom0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "System Control"]
pub const SYSCTRL: Peripheral<SYSCTRL> = unsafe { Peripheral::new(0x4000_0800) };
#[doc = "System Control"]
pub mod sysctrl {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x04 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x08 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x0c - Power and Clocks Status"]
        pub pclksr: PCLKSR,
        #[doc = "0x10 - XOSC Control"]
        pub xosc: XOSC,
        _reserved0: [u8; 2usize],
        #[doc = "0x14 - XOSC32K Control"]
        pub xosc32k: XOSC32K,
        _reserved1: [u8; 2usize],
        #[doc = "0x18 - OSC32K Control"]
        pub osc32k: OSC32K,
        #[doc = "0x1c - OSCULP32K Control"]
        pub osculp32k: OSCULP32K,
        _reserved2: [u8; 3usize],
        #[doc = "0x20 - OSC8M Control A"]
        pub osc8m: OSC8M,
        #[doc = "0x24 - DFLL Config"]
        pub dfllctrl: DFLLCTRL,
        _reserved3: [u8; 2usize],
        #[doc = "0x28 - DFLL Calibration Value"]
        pub dfllval: DFLLVAL,
        #[doc = "0x2c - DFLL Multiplier"]
        pub dfllmul: DFLLMUL,
        #[doc = "0x30 - DFLL Synchronization"]
        pub dfllsync: DFLLSYNC,
        _reserved4: [u8; 3usize],
        #[doc = "0x34 - 3.3V Brown-Out Detector (BOD33) Control"]
        pub bod33: BOD33,
        _reserved5: [u8; 4usize],
        #[doc = "0x3c - VREG Control"]
        pub vreg: VREG,
        _reserved6: [u8; 2usize],
        #[doc = "0x40 - VREF Control A"]
        pub vref: VREF,
    }
    #[doc = "3.3V Brown-Out Detector (BOD33) Control"]
    pub struct BOD33 {
        register: VolatileCell<u32>,
    }
    #[doc = "3.3V Brown-Out Detector (BOD33) Control"]
    pub mod bod33 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BOD33 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HYSTR {
            bits: bool,
        }
        impl HYSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTIONR {
            bits: u8,
        }
        impl ACTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODER {
            bits: bool,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CENR {
            bits: bool,
        }
        impl CENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSELR {
            bits: u8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEVELR {
            bits: u8,
        }
        impl LEVELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACTIONW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEVELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEVELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Hysteresis Enable"]
            #[inline]
            pub fn hyst(&self) -> HYSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HYSTR { bits }
            }
            #[doc = "Bits 3:4 - Action when Threshold Crossed"]
            #[inline]
            pub fn action(&self) -> ACTIONR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACTIONR { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 8 - Operation Modes"]
            #[inline]
            pub fn mode(&self) -> MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MODER { bits }
            }
            #[doc = "Bit 9 - Clock Enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CENR { bits }
            }
            #[doc = "Bits 12:15 - Prescaler Select"]
            #[inline]
            pub fn psel(&self) -> PSELR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PSELR { bits }
            }
            #[doc = "Bits 16:21 - Threshold Level"]
            #[inline]
            pub fn level(&self) -> LEVELR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LEVELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Hysteresis Enable"]
            #[inline]
            pub fn hyst(&mut self) -> _HYSTW {
                _HYSTW { w: self }
            }
            #[doc = "Bits 3:4 - Action when Threshold Crossed"]
            #[inline]
            pub fn action(&mut self) -> _ACTIONW {
                _ACTIONW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 8 - Operation Modes"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 9 - Clock Enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
            #[doc = "Bits 12:15 - Prescaler Select"]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
            #[doc = "Bits 16:21 - Threshold Level"]
            #[inline]
            pub fn level(&mut self) -> _LEVELW {
                _LEVELW { w: self }
            }
        }
    }
    #[doc = "DFLL Config"]
    pub struct DFLLCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "DFLL Config"]
    pub mod dfllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::DFLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODER {
            bits: bool,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STABLER {
            bits: bool,
        }
        impl STABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LLAWR {
            bits: bool,
        }
        impl LLAWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCDISR {
            bits: bool,
        }
        impl CCDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct QLDISR {
            bits: bool,
        }
        impl QLDISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LLAWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LLAWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _QLDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _QLDISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Mode Selection"]
            #[inline]
            pub fn mode(&self) -> MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                MODER { bits }
            }
            #[doc = "Bit 3 - Stable Frequency"]
            #[inline]
            pub fn stable(&self) -> STABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                STABLER { bits }
            }
            #[doc = "Bit 4 - Lose Lock After Wake"]
            #[inline]
            pub fn llaw(&self) -> LLAWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                LLAWR { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bit 8 - Chill Cycle Disable"]
            #[inline]
            pub fn ccdis(&self) -> CCDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                CCDISR { bits }
            }
            #[doc = "Bit 9 - Quick Lock Disable"]
            #[inline]
            pub fn qldis(&self) -> QLDISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                QLDISR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Mode Selection"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 3 - Stable Frequency"]
            #[inline]
            pub fn stable(&mut self) -> _STABLEW {
                _STABLEW { w: self }
            }
            #[doc = "Bit 4 - Lose Lock After Wake"]
            #[inline]
            pub fn llaw(&mut self) -> _LLAWW {
                _LLAWW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bit 8 - Chill Cycle Disable"]
            #[inline]
            pub fn ccdis(&mut self) -> _CCDISW {
                _CCDISW { w: self }
            }
            #[doc = "Bit 9 - Quick Lock Disable"]
            #[inline]
            pub fn qldis(&mut self) -> _QLDISW {
                _QLDISW { w: self }
            }
        }
    }
    #[doc = "DFLL Multiplier"]
    pub struct DFLLMUL {
        register: VolatileCell<u32>,
    }
    #[doc = "DFLL Multiplier"]
    pub mod dfllmul {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DFLLMUL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MULR {
            bits: u16,
        }
        impl MULR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FSTEPR {
            bits: u16,
        }
        impl FSTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CSTEPR {
            bits: u8,
        }
        impl CSTEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MULW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MULW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSTEPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CSTEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CSTEPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Multiplication Value"]
            #[inline]
            pub fn mul(&self) -> MULR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MULR { bits }
            }
            #[doc = "Bits 16:25 - Maximum Fine Step Size"]
            #[inline]
            pub fn fstep(&self) -> FSTEPR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FSTEPR { bits }
            }
            #[doc = "Bits 26:31 - Maximum Coarse Step Size"]
            #[inline]
            pub fn cstep(&self) -> CSTEPR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CSTEPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Multiplication Value"]
            #[inline]
            pub fn mul(&mut self) -> _MULW {
                _MULW { w: self }
            }
            #[doc = "Bits 16:25 - Maximum Fine Step Size"]
            #[inline]
            pub fn fstep(&mut self) -> _FSTEPW {
                _FSTEPW { w: self }
            }
            #[doc = "Bits 26:31 - Maximum Coarse Step Size"]
            #[inline]
            pub fn cstep(&mut self) -> _CSTEPW {
                _CSTEPW { w: self }
            }
        }
    }
    #[doc = "DFLL Synchronization"]
    pub struct DFLLSYNC {
        register: VolatileCell<u8>,
    }
    #[doc = "DFLL Synchronization"]
    pub mod dfllsync {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DFLLSYNC {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _READREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Read Request Synchronization"]
            #[inline]
            pub fn readreq(&mut self) -> _READREQW {
                _READREQW { w: self }
            }
        }
    }
    #[doc = "DFLL Calibration Value"]
    pub struct DFLLVAL {
        register: VolatileCell<u32>,
    }
    #[doc = "DFLL Calibration Value"]
    pub mod dfllval {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DFLLVAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FINER {
            bits: u16,
        }
        impl FINER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct COARSER {
            bits: u8,
        }
        impl COARSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIFFR {
            bits: u16,
        }
        impl DIFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FINEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FINEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COARSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COARSEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Fine Calibration Value"]
            #[inline]
            pub fn fine(&self) -> FINER {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FINER { bits }
            }
            #[doc = "Bits 10:15 - Coarse Calibration Value"]
            #[inline]
            pub fn coarse(&self) -> COARSER {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                COARSER { bits }
            }
            #[doc = "Bits 16:31 - Multiplication Ratio Difference"]
            #[inline]
            pub fn diff(&self) -> DIFFR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIFFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Fine Calibration Value"]
            #[inline]
            pub fn fine(&mut self) -> _FINEW {
                _FINEW { w: self }
            }
            #[doc = "Bits 10:15 - Coarse Calibration Value"]
            #[inline]
            pub fn coarse(&mut self) -> _COARSEW {
                _COARSEW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XOSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XOSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC32KRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC32KRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSC8MRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSC8MRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLOOBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLOOBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLLCKCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLLCKCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLLRCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLLRCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD33DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD33DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _B33SRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _B33SRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&mut self) -> _XOSCRDYW {
                _XOSCRDYW { w: self }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&mut self) -> _XOSC32KRDYW {
                _XOSC32KRDYW { w: self }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&mut self) -> _OSC32KRDYW {
                _OSC32KRDYW { w: self }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&mut self) -> _OSC8MRDYW {
                _OSC8MRDYW { w: self }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&mut self) -> _DFLLRDYW {
                _DFLLRDYW { w: self }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&mut self) -> _DFLLOOBW {
                _DFLLOOBW { w: self }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&mut self) -> _DFLLLCKFW {
                _DFLLLCKFW { w: self }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&mut self) -> _DFLLLCKCW {
                _DFLLLCKCW { w: self }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&mut self) -> _DFLLRCSW {
                _DFLLRCSW { w: self }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&mut self) -> _BOD33RDYW {
                _BOD33RDYW { w: self }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&mut self) -> _BOD33DETW {
                _BOD33DETW { w: self }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&mut self) -> _B33SRDYW {
                _B33SRDYW { w: self }
            }
        }
    }
    #[doc = "OSC32K Control"]
    pub struct OSC32K {
        register: VolatileCell<u32>,
    }
    #[doc = "OSC32K Control"]
    pub mod osc32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OSC32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN32KR {
            bits: bool,
        }
        impl EN32KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN1KR {
            bits: bool,
        }
        impl EN1KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u8,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN32KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN32KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN1KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN1KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - 32kHz Output Enable"]
            #[inline]
            pub fn en32k(&self) -> EN32KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EN32KR { bits }
            }
            #[doc = "Bit 3 - 1kHz Output Enable"]
            #[inline]
            pub fn en1k(&self) -> EN1KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EN1KR { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Start-Up Time"]
            #[inline]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTUPR { bits }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRTLOCKR { bits }
            }
            #[doc = "Bits 16:22 - Calibration Value"]
            #[inline]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CALIBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x003f_0080 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - 32kHz Output Enable"]
            #[inline]
            pub fn en32k(&mut self) -> _EN32KW {
                _EN32KW { w: self }
            }
            #[doc = "Bit 3 - 1kHz Output Enable"]
            #[inline]
            pub fn en1k(&mut self) -> _EN1KW {
                _EN1KW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Start-Up Time"]
            #[inline]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
            #[doc = "Bits 16:22 - Calibration Value"]
            #[inline]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
        }
    }
    #[doc = "OSC8M Control A"]
    pub struct OSC8M {
        register: VolatileCell<u32>,
    }
    #[doc = "OSC8M Control A"]
    pub mod osc8m {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OSC8M {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRESCR {
            bits: u8,
        }
        impl PRESCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u16,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRANGER {
            bits: u8,
        }
        impl FRANGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRANGEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:9 - Prescaler Select"]
            #[inline]
            pub fn presc(&self) -> PRESCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRESCR { bits }
            }
            #[doc = "Bits 16:27 - Calibration Value"]
            #[inline]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CALIBR { bits }
            }
            #[doc = "Bits 30:31 - Frequency Range"]
            #[inline]
            pub fn frange(&self) -> FRANGER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FRANGER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x8707_0382 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:9 - Prescaler Select"]
            #[inline]
            pub fn presc(&mut self) -> _PRESCW {
                _PRESCW { w: self }
            }
            #[doc = "Bits 16:27 - Calibration Value"]
            #[inline]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
            #[doc = "Bits 30:31 - Frequency Range"]
            #[inline]
            pub fn frange(&mut self) -> _FRANGEW {
                _FRANGEW { w: self }
            }
        }
    }
    #[doc = "OSCULP32K Control"]
    pub struct OSCULP32K {
        register: VolatileCell<u8>,
    }
    #[doc = "OSCULP32K Control"]
    pub mod osculp32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::OSCULP32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u8,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:4 - Calibration Value"]
            #[inline]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                CALIBR { bits }
            }
            #[doc = "Bit 7 - Write Lock"]
            #[inline]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Calibration Value"]
            #[inline]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
            #[doc = "Bit 7 - Write Lock"]
            #[inline]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
    #[doc = "Power and Clocks Status"]
    pub struct PCLKSR {
        register: VolatileCell<u32>,
    }
    #[doc = "Power and Clocks Status"]
    pub mod pclksr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PCLKSR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSCRDYR {
            bits: bool,
        }
        impl XOSCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XOSC32KRDYR {
            bits: bool,
        }
        impl XOSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC32KRDYR {
            bits: bool,
        }
        impl OSC32KRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSC8MRDYR {
            bits: bool,
        }
        impl OSC8MRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRDYR {
            bits: bool,
        }
        impl DFLLRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLOOBR {
            bits: bool,
        }
        impl DFLLOOBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKFR {
            bits: bool,
        }
        impl DFLLLCKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLLCKCR {
            bits: bool,
        }
        impl DFLLLCKCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLLRCSR {
            bits: bool,
        }
        impl DFLLRCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33RDYR {
            bits: bool,
        }
        impl BOD33RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOD33DETR {
            bits: bool,
        }
        impl BOD33DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct B33SRDYR {
            bits: bool,
        }
        impl B33SRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - XOSC Ready"]
            #[inline]
            pub fn xoscrdy(&self) -> XOSCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSCRDYR { bits }
            }
            #[doc = "Bit 1 - XOSC32K Ready"]
            #[inline]
            pub fn xosc32krdy(&self) -> XOSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                XOSC32KRDYR { bits }
            }
            #[doc = "Bit 2 - OSC32K Ready"]
            #[inline]
            pub fn osc32krdy(&self) -> OSC32KRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC32KRDYR { bits }
            }
            #[doc = "Bit 3 - OSC8M Ready"]
            #[inline]
            pub fn osc8mrdy(&self) -> OSC8MRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSC8MRDYR { bits }
            }
            #[doc = "Bit 4 - DFLL Ready"]
            #[inline]
            pub fn dfllrdy(&self) -> DFLLRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRDYR { bits }
            }
            #[doc = "Bit 5 - DFLL Out Of Bounds"]
            #[inline]
            pub fn dflloob(&self) -> DFLLOOBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLOOBR { bits }
            }
            #[doc = "Bit 6 - DFLL Lock Fine"]
            #[inline]
            pub fn dflllckf(&self) -> DFLLLCKFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKFR { bits }
            }
            #[doc = "Bit 7 - DFLL Lock Coarse"]
            #[inline]
            pub fn dflllckc(&self) -> DFLLLCKCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLLCKCR { bits }
            }
            #[doc = "Bit 8 - DFLL Reference Clock Stopped"]
            #[inline]
            pub fn dfllrcs(&self) -> DFLLRCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLLRCSR { bits }
            }
            #[doc = "Bit 9 - BOD33 Ready"]
            #[inline]
            pub fn bod33rdy(&self) -> BOD33RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33RDYR { bits }
            }
            #[doc = "Bit 10 - BOD33 Detection"]
            #[inline]
            pub fn bod33det(&self) -> BOD33DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BOD33DETR { bits }
            }
            #[doc = "Bit 11 - BOD33 Synchronization Ready"]
            #[inline]
            pub fn b33srdy(&self) -> B33SRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                B33SRDYR { bits }
            }
        }
    }
    #[doc = "VREF Control A"]
    pub struct VREF {
        register: VolatileCell<u32>,
    }
    #[doc = "VREF Control A"]
    pub mod vref {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::VREF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSENR {
            bits: bool,
        }
        impl TSENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BGOUTENR {
            bits: bool,
        }
        impl BGOUTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALIBR {
            bits: u16,
        }
        impl CALIBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BGOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BGOUTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALIBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALIBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x07ff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Temperature Sensor Output Enable"]
            #[inline]
            pub fn tsen(&self) -> TSENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSENR { bits }
            }
            #[doc = "Bit 2 - Bandgap Output Enable"]
            #[inline]
            pub fn bgouten(&self) -> BGOUTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BGOUTENR { bits }
            }
            #[doc = "Bits 16:26 - Voltage Reference Calibration Value"]
            #[inline]
            pub fn calib(&self) -> CALIBR {
                let bits = {
                    const MASK: u16 = 0x07ff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CALIBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Temperature Sensor Output Enable"]
            #[inline]
            pub fn tsen(&mut self) -> _TSENW {
                _TSENW { w: self }
            }
            #[doc = "Bit 2 - Bandgap Output Enable"]
            #[inline]
            pub fn bgouten(&mut self) -> _BGOUTENW {
                _BGOUTENW { w: self }
            }
            #[doc = "Bits 16:26 - Voltage Reference Calibration Value"]
            #[inline]
            pub fn calib(&mut self) -> _CALIBW {
                _CALIBW { w: self }
            }
        }
    }
    #[doc = "VREG Control"]
    pub struct VREG {
        register: VolatileCell<u16>,
    }
    #[doc = "VREG Control"]
    pub mod vreg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::VREG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FORCELDOR {
            bits: bool,
        }
        impl FORCELDOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FORCELDOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FORCELDOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 13 - Force LDO Voltage Regulator"]
            #[inline]
            pub fn forceldo(&self) -> FORCELDOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                FORCELDOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0402 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 13 - Force LDO Voltage Regulator"]
            #[inline]
            pub fn forceldo(&mut self) -> _FORCELDOW {
                _FORCELDOW { w: self }
            }
        }
    }
    #[doc = "XOSC Control"]
    pub struct XOSC {
        register: VolatileCell<u16>,
    }
    #[doc = "XOSC Control"]
    pub mod xosc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::XOSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XTALENR {
            bits: bool,
        }
        impl XTALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GAINR {
            bits: u8,
        }
        impl GAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AMPGCR {
            bits: bool,
        }
        impl AMPGCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GAINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AMPGCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AMPGCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline]
            pub fn xtalen(&self) -> XTALENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                XTALENR { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Gain Value"]
            #[inline]
            pub fn gain(&self) -> GAINR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                GAINR { bits }
            }
            #[doc = "Bit 11 - Automatic Amplitude Gain Control"]
            #[inline]
            pub fn ampgc(&self) -> AMPGCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                AMPGCR { bits }
            }
            #[doc = "Bits 12:15 - Start-Up Time"]
            #[inline]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                STARTUPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline]
            pub fn xtalen(&mut self) -> _XTALENW {
                _XTALENW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Gain Value"]
            #[inline]
            pub fn gain(&mut self) -> _GAINW {
                _GAINW { w: self }
            }
            #[doc = "Bit 11 - Automatic Amplitude Gain Control"]
            #[inline]
            pub fn ampgc(&mut self) -> _AMPGCW {
                _AMPGCW { w: self }
            }
            #[doc = "Bits 12:15 - Start-Up Time"]
            #[inline]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
        }
    }
    #[doc = "XOSC32K Control"]
    pub struct XOSC32K {
        register: VolatileCell<u16>,
    }
    #[doc = "XOSC32K Control"]
    pub mod xosc32k {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::XOSC32K {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct XTALENR {
            bits: bool,
        }
        impl XTALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN32KR {
            bits: bool,
        }
        impl EN32KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EN1KR {
            bits: bool,
        }
        impl EN1KR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AAMPENR {
            bits: bool,
        }
        impl AAMPENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONDEMANDR {
            bits: bool,
        }
        impl ONDEMANDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTUPR {
            bits: u8,
        }
        impl STARTUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRTLOCKR {
            bits: bool,
        }
        impl WRTLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN32KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN32KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN1KW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN1KW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AAMPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AAMPENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONDEMANDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONDEMANDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTUPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRTLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRTLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline]
            pub fn xtalen(&self) -> XTALENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                XTALENR { bits }
            }
            #[doc = "Bit 3 - 32kHz Output Enable"]
            #[inline]
            pub fn en32k(&self) -> EN32KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                EN32KR { bits }
            }
            #[doc = "Bit 4 - 1kHz Output Enable"]
            #[inline]
            pub fn en1k(&self) -> EN1KR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                EN1KR { bits }
            }
            #[doc = "Bit 5 - Automatic Amplitude Control Enable"]
            #[inline]
            pub fn aampen(&self) -> AAMPENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                AAMPENR { bits }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&self) -> ONDEMANDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ONDEMANDR { bits }
            }
            #[doc = "Bits 8:10 - Start-Up Time"]
            #[inline]
            pub fn startup(&self) -> STARTUPR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                STARTUPR { bits }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline]
            pub fn wrtlock(&self) -> WRTLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                WRTLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Crystal Oscillator Enable"]
            #[inline]
            pub fn xtalen(&mut self) -> _XTALENW {
                _XTALENW { w: self }
            }
            #[doc = "Bit 3 - 32kHz Output Enable"]
            #[inline]
            pub fn en32k(&mut self) -> _EN32KW {
                _EN32KW { w: self }
            }
            #[doc = "Bit 4 - 1kHz Output Enable"]
            #[inline]
            pub fn en1k(&mut self) -> _EN1KW {
                _EN1KW { w: self }
            }
            #[doc = "Bit 5 - Automatic Amplitude Control Enable"]
            #[inline]
            pub fn aampen(&mut self) -> _AAMPENW {
                _AAMPENW { w: self }
            }
            #[doc = "Bit 6 - Run during Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bit 7 - Enable on Demand"]
            #[inline]
            pub fn ondemand(&mut self) -> _ONDEMANDW {
                _ONDEMANDW { w: self }
            }
            #[doc = "Bits 8:10 - Start-Up Time"]
            #[inline]
            pub fn startup(&mut self) -> _STARTUPW {
                _STARTUPW { w: self }
            }
            #[doc = "Bit 12 - Write Lock"]
            #[inline]
            pub fn wrtlock(&mut self) -> _WRTLOCKW {
                _WRTLOCKW { w: self }
            }
        }
    }
}
#[doc = "System Control"]
pub struct SYSCTRL {
    register_block: sysctrl::RegisterBlock,
}
impl Deref for SYSCTRL {
    type Target = sysctrl::RegisterBlock;
    fn deref(&self) -> &sysctrl::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 0"]
pub const TC0: Peripheral<TC0> = unsafe { Peripheral::new(0x4200_2000) };
#[doc = "Basic Timer Counter 0"]
pub mod tc0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control A"]
        pub ctrla: CTRLA,
        #[doc = "0x02 - Read Request"]
        pub readreq: READREQ,
        #[doc = "0x04 - Control B Clear"]
        pub ctrlbclr: CTRLBCLR,
        #[doc = "0x05 - Control B Set"]
        pub ctrlbset: CTRLBSET,
        #[doc = "0x06 - Control C"]
        pub ctrlc: CTRLC,
        _reserved0: [u8; 1usize],
        #[doc = "0x08 - Debug Control"]
        pub dbgctrl: DBGCTRL,
        _reserved1: [u8; 1usize],
        #[doc = "0x0a - Event Control"]
        pub evctrl: EVCTRL,
        #[doc = "0x0c - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x0d - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x0e - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x0f - Status"]
        pub status: STATUS,
        #[doc = "0x10 - COUNT16 Counter Value"]
        pub count: COUNT,
        _reserved2: [u8; 6usize],
        #[doc = "0x18 - COUNT16 Compare/Capture"]
        pub cc: [CC; 2],
    }
    #[doc = "COUNT16 Compare/Capture"]
    pub struct CC {
        register: VolatileCell<u16>,
    }
    #[doc = "COUNT16 Compare/Capture"]
    pub mod cc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR {
            bits: u16,
        }
        impl CCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Compare/Capture Value"]
            #[inline]
            pub fn cc(&self) -> CCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                CCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Compare/Capture Value"]
            #[inline]
            pub fn cc(&mut self) -> _CCW {
                _CCW { w: self }
            }
        }
    }
    #[doc = "COUNT16 Counter Value"]
    pub struct COUNT {
        register: VolatileCell<u16>,
    }
    #[doc = "COUNT16 Counter Value"]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u16,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:15 - Counter Value"]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u16
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Counter Value"]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Control A"]
    pub struct CTRLA {
        register: VolatileCell<u16>,
    }
    #[doc = "Control A"]
    pub mod ctrla {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::CTRLA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Counter in 16-bit mode"]
            COUNT16,
            #[doc = "Counter in 8-bit mode"]
            COUNT8,
            #[doc = "Counter in 32-bit mode"]
            COUNT32,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::COUNT16 => 0,
                    MODER::COUNT8 => 0x01,
                    MODER::COUNT32 => 0x02,
                    MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::COUNT16,
                    1 => MODER::COUNT8,
                    2 => MODER::COUNT32,
                    i => MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `COUNT16`"]
            #[inline]
            pub fn is_count16(&self) -> bool {
                *self == MODER::COUNT16
            }
            #[doc = "Checks if the value of the field is `COUNT8`"]
            #[inline]
            pub fn is_count8(&self) -> bool {
                *self == MODER::COUNT8
            }
            #[doc = "Checks if the value of the field is `COUNT32`"]
            #[inline]
            pub fn is_count32(&self) -> bool {
                *self == MODER::COUNT32
            }
        }
        #[doc = "Possible values of the field `WAVEGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVEGENR {
            #[doc = "undocumented"]
            NFRQ,
            #[doc = "undocumented"]
            MFRQ,
            #[doc = "undocumented"]
            NPWM,
            #[doc = "undocumented"]
            MPWM,
        }
        impl WAVEGENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WAVEGENR::NFRQ => 0,
                    WAVEGENR::MFRQ => 0x01,
                    WAVEGENR::NPWM => 0x02,
                    WAVEGENR::MPWM => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WAVEGENR {
                match value {
                    0 => WAVEGENR::NFRQ,
                    1 => WAVEGENR::MFRQ,
                    2 => WAVEGENR::NPWM,
                    3 => WAVEGENR::MPWM,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NFRQ`"]
            #[inline]
            pub fn is_nfrq(&self) -> bool {
                *self == WAVEGENR::NFRQ
            }
            #[doc = "Checks if the value of the field is `MFRQ`"]
            #[inline]
            pub fn is_mfrq(&self) -> bool {
                *self == WAVEGENR::MFRQ
            }
            #[doc = "Checks if the value of the field is `NPWM`"]
            #[inline]
            pub fn is_npwm(&self) -> bool {
                *self == WAVEGENR::NPWM
            }
            #[doc = "Checks if the value of the field is `MPWM`"]
            #[inline]
            pub fn is_mpwm(&self) -> bool {
                *self == WAVEGENR::MPWM
            }
        }
        #[doc = "Possible values of the field `PRESCALER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCALERR {
            #[doc = "GCLK_TC"]
            DIV1,
            #[doc = "GCLK_TC/2"]
            DIV2,
            #[doc = "GCLK_TC/4"]
            DIV4,
            #[doc = "GCLK_TC/8"]
            DIV8,
            #[doc = "GCLK_TC/16"]
            DIV16,
            #[doc = "GCLK_TC/64"]
            DIV64,
            #[doc = "GCLK_TC/256"]
            DIV256,
            #[doc = "GCLK_TC/1024"]
            DIV1024,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCALERR::DIV1 => 0,
                    PRESCALERR::DIV2 => 0x01,
                    PRESCALERR::DIV4 => 0x02,
                    PRESCALERR::DIV8 => 0x03,
                    PRESCALERR::DIV16 => 0x04,
                    PRESCALERR::DIV64 => 0x05,
                    PRESCALERR::DIV256 => 0x06,
                    PRESCALERR::DIV1024 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PRESCALERR {
                match value {
                    0 => PRESCALERR::DIV1,
                    1 => PRESCALERR::DIV2,
                    2 => PRESCALERR::DIV4,
                    3 => PRESCALERR::DIV8,
                    4 => PRESCALERR::DIV16,
                    5 => PRESCALERR::DIV64,
                    6 => PRESCALERR::DIV256,
                    7 => PRESCALERR::DIV1024,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == PRESCALERR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == PRESCALERR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == PRESCALERR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == PRESCALERR::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == PRESCALERR::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == PRESCALERR::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline]
            pub fn is_div256(&self) -> bool {
                *self == PRESCALERR::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV1024`"]
            #[inline]
            pub fn is_div1024(&self) -> bool {
                *self == PRESCALERR::DIV1024
            }
        }
        #[doc = r" Value of the field"]
        pub struct RUNSTDBYR {
            bits: bool,
        }
        impl RUNSTDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `PRESCSYNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRESCSYNCR {
            #[doc = "Reload or reset Counter on next GCLK"]
            GCLK,
            #[doc = "Reload or reset Counter on next prescaler clock"]
            PRESC,
            #[doc = "Reload or reset Counter on next GCLK. Reset prescaler counter"]
            RESYNC,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PRESCSYNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRESCSYNCR::GCLK => 0,
                    PRESCSYNCR::PRESC => 0x01,
                    PRESCSYNCR::RESYNC => 0x02,
                    PRESCSYNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PRESCSYNCR {
                match value {
                    0 => PRESCSYNCR::GCLK,
                    1 => PRESCSYNCR::PRESC,
                    2 => PRESCSYNCR::RESYNC,
                    i => PRESCSYNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `GCLK`"]
            #[inline]
            pub fn is_gclk(&self) -> bool {
                *self == PRESCSYNCR::GCLK
            }
            #[doc = "Checks if the value of the field is `PRESC`"]
            #[inline]
            pub fn is_presc(&self) -> bool {
                *self == PRESCSYNCR::PRESC
            }
            #[doc = "Checks if the value of the field is `RESYNC`"]
            #[inline]
            pub fn is_resync(&self) -> bool {
                *self == PRESCSYNCR::RESYNC
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Counter in 16-bit mode"]
            COUNT16,
            #[doc = "Counter in 8-bit mode"]
            COUNT8,
            #[doc = "Counter in 32-bit mode"]
            COUNT32,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::COUNT16 => 0,
                    MODEW::COUNT8 => 1,
                    MODEW::COUNT32 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Counter in 16-bit mode"]
            #[inline]
            pub fn count16(self) -> &'a mut W {
                self.variant(MODEW::COUNT16)
            }
            #[doc = "Counter in 8-bit mode"]
            #[inline]
            pub fn count8(self) -> &'a mut W {
                self.variant(MODEW::COUNT8)
            }
            #[doc = "Counter in 32-bit mode"]
            #[inline]
            pub fn count32(self) -> &'a mut W {
                self.variant(MODEW::COUNT32)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAVEGEN`"]
        pub enum WAVEGENW {
            #[doc = "`0`"]
            NFRQ,
            #[doc = "`1`"]
            MFRQ,
            #[doc = "`10`"]
            NPWM,
            #[doc = "`11`"]
            MPWM,
        }
        impl WAVEGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WAVEGENW::NFRQ => 0,
                    WAVEGENW::MFRQ => 1,
                    WAVEGENW::NPWM => 2,
                    WAVEGENW::MPWM => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVEGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVEGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAVEGENW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn nfrq(self) -> &'a mut W {
                self.variant(WAVEGENW::NFRQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn mfrq(self) -> &'a mut W {
                self.variant(WAVEGENW::MFRQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn npwm(self) -> &'a mut W {
                self.variant(WAVEGENW::NPWM)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn mpwm(self) -> &'a mut W {
                self.variant(WAVEGENW::MPWM)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCALER`"]
        pub enum PRESCALERW {
            #[doc = "GCLK_TC"]
            DIV1,
            #[doc = "GCLK_TC/2"]
            DIV2,
            #[doc = "GCLK_TC/4"]
            DIV4,
            #[doc = "GCLK_TC/8"]
            DIV8,
            #[doc = "GCLK_TC/16"]
            DIV16,
            #[doc = "GCLK_TC/64"]
            DIV64,
            #[doc = "GCLK_TC/256"]
            DIV256,
            #[doc = "GCLK_TC/1024"]
            DIV1024,
        }
        impl PRESCALERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCALERW::DIV1 => 0,
                    PRESCALERW::DIV2 => 1,
                    PRESCALERW::DIV4 => 2,
                    PRESCALERW::DIV8 => 3,
                    PRESCALERW::DIV16 => 4,
                    PRESCALERW::DIV64 => 5,
                    PRESCALERW::DIV256 => 6,
                    PRESCALERW::DIV1024 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PRESCALERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "GCLK_TC"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV1)
            }
            #[doc = "GCLK_TC/2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV2)
            }
            #[doc = "GCLK_TC/4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV4)
            }
            #[doc = "GCLK_TC/8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV8)
            }
            #[doc = "GCLK_TC/16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV16)
            }
            #[doc = "GCLK_TC/64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV64)
            }
            #[doc = "GCLK_TC/256"]
            #[inline]
            pub fn div256(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV256)
            }
            #[doc = "GCLK_TC/1024"]
            #[inline]
            pub fn div1024(self) -> &'a mut W {
                self.variant(PRESCALERW::DIV1024)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNSTDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNSTDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PRESCSYNC`"]
        pub enum PRESCSYNCW {
            #[doc = "Reload or reset Counter on next GCLK"]
            GCLK,
            #[doc = "Reload or reset Counter on next prescaler clock"]
            PRESC,
            #[doc = "Reload or reset Counter on next GCLK. Reset prescaler counter"]
            RESYNC,
        }
        impl PRESCSYNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRESCSYNCW::GCLK => 0,
                    PRESCSYNCW::PRESC => 1,
                    PRESCSYNCW::RESYNC => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCSYNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PRESCSYNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Reload or reset Counter on next GCLK"]
            #[inline]
            pub fn gclk(self) -> &'a mut W {
                self.variant(PRESCSYNCW::GCLK)
            }
            #[doc = "Reload or reset Counter on next prescaler clock"]
            #[inline]
            pub fn presc(self) -> &'a mut W {
                self.variant(PRESCSYNCW::PRESC)
            }
            #[doc = "Reload or reset Counter on next GCLK. Reset prescaler counter"]
            #[inline]
            pub fn resync(self) -> &'a mut W {
                self.variant(PRESCSYNCW::RESYNC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bits 2:3 - TC Mode"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 5:6 - Waveform Generation Operation"]
            #[inline]
            pub fn wavegen(&self) -> WAVEGENR {
                WAVEGENR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bits 8:10 - Prescaler"]
            #[inline]
            pub fn prescaler(&self) -> PRESCALERR {
                PRESCALERR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 11 - Run in Standby"]
            #[inline]
            pub fn runstdby(&self) -> RUNSTDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RUNSTDBYR { bits }
            }
            #[doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
            #[inline]
            pub fn prescsync(&self) -> PRESCSYNCR {
                PRESCSYNCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bits 2:3 - TC Mode"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bits 5:6 - Waveform Generation Operation"]
            #[inline]
            pub fn wavegen(&mut self) -> _WAVEGENW {
                _WAVEGENW { w: self }
            }
            #[doc = "Bits 8:10 - Prescaler"]
            #[inline]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
            #[doc = "Bit 11 - Run in Standby"]
            #[inline]
            pub fn runstdby(&mut self) -> _RUNSTDBYW {
                _RUNSTDBYW { w: self }
            }
            #[doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
            #[inline]
            pub fn prescsync(&mut self) -> _PRESCSYNCW {
                _PRESCSYNCW { w: self }
            }
        }
    }
    #[doc = "Control B Clear"]
    pub struct CTRLBCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B Clear"]
    pub mod ctrlbclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLBCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONESHOTR {
            bits: bool,
        }
        impl ONESHOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "No action"]
            NONE,
            #[doc = "Force start, restart or retrigger"]
            RETRIGGER,
            #[doc = "Force stop"]
            STOP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::NONE => 0,
                    CMDR::RETRIGGER => 0x01,
                    CMDR::STOP => 0x02,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    0 => CMDR::NONE,
                    1 => CMDR::RETRIGGER,
                    2 => CMDR::STOP,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == CMDR::NONE
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline]
            pub fn is_retrigger(&self) -> bool {
                *self == CMDR::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == CMDR::STOP
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONESHOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONESHOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "No action"]
            NONE,
            #[doc = "Force start, restart or retrigger"]
            RETRIGGER,
            #[doc = "Force stop"]
            STOP,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::NONE => 0,
                    CMDW::RETRIGGER => 1,
                    CMDW::STOP => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(CMDW::NONE)
            }
            #[doc = "Force start, restart or retrigger"]
            #[inline]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(CMDW::RETRIGGER)
            }
            #[doc = "Force stop"]
            #[inline]
            pub fn stop(self) -> &'a mut W {
                self.variant(CMDW::STOP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline]
            pub fn oneshot(&self) -> ONESHOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ONESHOTR { bits }
            }
            #[doc = "Bits 6:7 - Command"]
            #[inline]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 2 - One-Shot"]
            #[inline]
            pub fn oneshot(&mut self) -> _ONESHOTW {
                _ONESHOTW { w: self }
            }
            #[doc = "Bits 6:7 - Command"]
            #[inline]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
        }
    }
    #[doc = "Control B Set"]
    pub struct CTRLBSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Control B Set"]
    pub mod ctrlbset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLBSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ONESHOTR {
            bits: bool,
        }
        impl ONESHOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `CMD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMDR {
            #[doc = "No action"]
            NONE,
            #[doc = "Force start, restart or retrigger"]
            RETRIGGER,
            #[doc = "Force stop"]
            STOP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CMDR::NONE => 0,
                    CMDR::RETRIGGER => 0x01,
                    CMDR::STOP => 0x02,
                    CMDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CMDR {
                match value {
                    0 => CMDR::NONE,
                    1 => CMDR::RETRIGGER,
                    2 => CMDR::STOP,
                    i => CMDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == CMDR::NONE
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline]
            pub fn is_retrigger(&self) -> bool {
                *self == CMDR::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == CMDR::STOP
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONESHOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONESHOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CMD`"]
        pub enum CMDW {
            #[doc = "No action"]
            NONE,
            #[doc = "Force start, restart or retrigger"]
            RETRIGGER,
            #[doc = "Force stop"]
            STOP,
        }
        impl CMDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMDW::NONE => 0,
                    CMDW::RETRIGGER => 1,
                    CMDW::STOP => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CMDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No action"]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(CMDW::NONE)
            }
            #[doc = "Force start, restart or retrigger"]
            #[inline]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(CMDW::RETRIGGER)
            }
            #[doc = "Force stop"]
            #[inline]
            pub fn stop(self) -> &'a mut W {
                self.variant(CMDW::STOP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 2 - One-shot"]
            #[inline]
            pub fn oneshot(&self) -> ONESHOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ONESHOTR { bits }
            }
            #[doc = "Bits 6:7 - Command"]
            #[inline]
            pub fn cmd(&self) -> CMDR {
                CMDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Counter Direction"]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 2 - One-shot"]
            #[inline]
            pub fn oneshot(&mut self) -> _ONESHOTW {
                _ONESHOTW { w: self }
            }
            #[doc = "Bits 6:7 - Command"]
            #[inline]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
        }
    }
    #[doc = "Control C"]
    pub struct CTRLC {
        register: VolatileCell<u8>,
    }
    #[doc = "Control C"]
    pub mod ctrlc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRLC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN0R {
            bits: bool,
        }
        impl INVEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INVEN1R {
            bits: bool,
        }
        impl INVEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN0R {
            bits: bool,
        }
        impl CPTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPTEN1R {
            bits: bool,
        }
        impl CPTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPTEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Output Waveform 0 Invert Enable"]
            #[inline]
            pub fn inven0(&self) -> INVEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                INVEN0R { bits }
            }
            #[doc = "Bit 1 - Output Waveform 1 Invert Enable"]
            #[inline]
            pub fn inven1(&self) -> INVEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                INVEN1R { bits }
            }
            #[doc = "Bit 4 - Capture Channel 0 Enable"]
            #[inline]
            pub fn cpten0(&self) -> CPTEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CPTEN0R { bits }
            }
            #[doc = "Bit 5 - Capture Channel 1 Enable"]
            #[inline]
            pub fn cpten1(&self) -> CPTEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                CPTEN1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Output Waveform 0 Invert Enable"]
            #[inline]
            pub fn inven0(&mut self) -> _INVEN0W {
                _INVEN0W { w: self }
            }
            #[doc = "Bit 1 - Output Waveform 1 Invert Enable"]
            #[inline]
            pub fn inven1(&mut self) -> _INVEN1W {
                _INVEN1W { w: self }
            }
            #[doc = "Bit 4 - Capture Channel 0 Enable"]
            #[inline]
            pub fn cpten0(&mut self) -> _CPTEN0W {
                _CPTEN0W { w: self }
            }
            #[doc = "Bit 5 - Capture Channel 1 Enable"]
            #[inline]
            pub fn cpten1(&mut self) -> _CPTEN1W {
                _CPTEN1W { w: self }
            }
        }
    }
    #[doc = "Debug Control"]
    pub struct DBGCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Debug Control"]
    pub mod dbgctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::DBGCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBGRUNR {
            bits: bool,
        }
        impl DBGRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBGRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBGRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Run Mode"]
            #[inline]
            pub fn dbgrun(&self) -> DBGRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                DBGRUNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Run Mode"]
            #[inline]
            pub fn dbgrun(&mut self) -> _DBGRUNW {
                _DBGRUNW { w: self }
            }
        }
    }
    #[doc = "Event Control"]
    pub struct EVCTRL {
        register: VolatileCell<u16>,
    }
    #[doc = "Event Control"]
    pub mod evctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::EVCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EVACT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVACTR {
            #[doc = "Event action disabled"]
            OFF,
            #[doc = "Start, restart or retrigger TC on event"]
            RETRIGGER,
            #[doc = "Count on event"]
            COUNT,
            #[doc = "Start TC on event"]
            START,
            #[doc = "Period captured into CC0 Pulse Width in CC1"]
            PPW,
            #[doc = "Period captured into CC1 Pulse Width on CC0"]
            PWP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EVACTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EVACTR::OFF => 0,
                    EVACTR::RETRIGGER => 0x01,
                    EVACTR::COUNT => 0x02,
                    EVACTR::START => 0x03,
                    EVACTR::PPW => 0x05,
                    EVACTR::PWP => 0x06,
                    EVACTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EVACTR {
                match value {
                    0 => EVACTR::OFF,
                    1 => EVACTR::RETRIGGER,
                    2 => EVACTR::COUNT,
                    3 => EVACTR::START,
                    5 => EVACTR::PPW,
                    6 => EVACTR::PWP,
                    i => EVACTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == EVACTR::OFF
            }
            #[doc = "Checks if the value of the field is `RETRIGGER`"]
            #[inline]
            pub fn is_retrigger(&self) -> bool {
                *self == EVACTR::RETRIGGER
            }
            #[doc = "Checks if the value of the field is `COUNT`"]
            #[inline]
            pub fn is_count(&self) -> bool {
                *self == EVACTR::COUNT
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline]
            pub fn is_start(&self) -> bool {
                *self == EVACTR::START
            }
            #[doc = "Checks if the value of the field is `PPW`"]
            #[inline]
            pub fn is_ppw(&self) -> bool {
                *self == EVACTR::PPW
            }
            #[doc = "Checks if the value of the field is `PWP`"]
            #[inline]
            pub fn is_pwp(&self) -> bool {
                *self == EVACTR::PWP
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCINVR {
            bits: bool,
        }
        impl TCINVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCEIR {
            bits: bool,
        }
        impl TCEIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFEOR {
            bits: bool,
        }
        impl OVFEOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO0R {
            bits: bool,
        }
        impl MCEO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MCEO1R {
            bits: bool,
        }
        impl MCEO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `EVACT`"]
        pub enum EVACTW {
            #[doc = "Event action disabled"]
            OFF,
            #[doc = "Start, restart or retrigger TC on event"]
            RETRIGGER,
            #[doc = "Count on event"]
            COUNT,
            #[doc = "Start TC on event"]
            START,
            #[doc = "Period captured into CC0 Pulse Width in CC1"]
            PPW,
            #[doc = "Period captured into CC1 Pulse Width on CC0"]
            PWP,
        }
        impl EVACTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EVACTW::OFF => 0,
                    EVACTW::RETRIGGER => 1,
                    EVACTW::COUNT => 2,
                    EVACTW::START => 3,
                    EVACTW::PPW => 5,
                    EVACTW::PWP => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVACTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVACTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EVACTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Event action disabled"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(EVACTW::OFF)
            }
            #[doc = "Start, restart or retrigger TC on event"]
            #[inline]
            pub fn retrigger(self) -> &'a mut W {
                self.variant(EVACTW::RETRIGGER)
            }
            #[doc = "Count on event"]
            #[inline]
            pub fn count(self) -> &'a mut W {
                self.variant(EVACTW::COUNT)
            }
            #[doc = "Start TC on event"]
            #[inline]
            pub fn start(self) -> &'a mut W {
                self.variant(EVACTW::START)
            }
            #[doc = "Period captured into CC0 Pulse Width in CC1"]
            #[inline]
            pub fn ppw(self) -> &'a mut W {
                self.variant(EVACTW::PPW)
            }
            #[doc = "Period captured into CC1 Pulse Width on CC0"]
            #[inline]
            pub fn pwp(self) -> &'a mut W {
                self.variant(EVACTW::PWP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCINVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCEIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCEIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFEOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFEOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCEO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCEO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:2 - Event Action"]
            #[inline]
            pub fn evact(&self) -> EVACTR {
                EVACTR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                })
            }
            #[doc = "Bit 4 - TC Inverted Event Input"]
            #[inline]
            pub fn tcinv(&self) -> TCINVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TCINVR { bits }
            }
            #[doc = "Bit 5 - TC Event Input"]
            #[inline]
            pub fn tcei(&self) -> TCEIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                TCEIR { bits }
            }
            #[doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
            #[inline]
            pub fn ovfeo(&self) -> OVFEOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                OVFEOR { bits }
            }
            #[doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
            #[inline]
            pub fn mceo0(&self) -> MCEO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                MCEO0R { bits }
            }
            #[doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
            #[inline]
            pub fn mceo1(&self) -> MCEO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                MCEO1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Event Action"]
            #[inline]
            pub fn evact(&mut self) -> _EVACTW {
                _EVACTW { w: self }
            }
            #[doc = "Bit 4 - TC Inverted Event Input"]
            #[inline]
            pub fn tcinv(&mut self) -> _TCINVW {
                _TCINVW { w: self }
            }
            #[doc = "Bit 5 - TC Event Input"]
            #[inline]
            pub fn tcei(&mut self) -> _TCEIW {
                _TCEIW { w: self }
            }
            #[doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
            #[inline]
            pub fn ovfeo(&mut self) -> _OVFEOW {
                _OVFEOW { w: self }
            }
            #[doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
            #[inline]
            pub fn mceo0(&mut self) -> _MCEO0W {
                _MCEO0W { w: self }
            }
            #[doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
            #[inline]
            pub fn mceo1(&mut self) -> _MCEO1W {
                _MCEO1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow Interrupt Enable"]
            #[inline]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Error Interrupt Enable"]
            #[inline]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
            #[inline]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
            #[inline]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVFR {
            bits: bool,
        }
        impl OVFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRR {
            bits: bool,
        }
        impl ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCRDYR {
            bits: bool,
        }
        impl SYNCRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC0R {
            bits: bool,
        }
        impl MC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MC1R {
            bits: bool,
        }
        impl MC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MC1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Overflow"]
            #[inline]
            pub fn ovf(&self) -> OVFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                OVFR { bits }
            }
            #[doc = "Bit 1 - Error"]
            #[inline]
            pub fn err(&self) -> ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ERRR { bits }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&self) -> SYNCRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCRDYR { bits }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0"]
            #[inline]
            pub fn mc0(&self) -> MC0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC0R { bits }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1"]
            #[inline]
            pub fn mc1(&self) -> MC1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                MC1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Overflow"]
            #[inline]
            pub fn ovf(&mut self) -> _OVFW {
                _OVFW { w: self }
            }
            #[doc = "Bit 1 - Error"]
            #[inline]
            pub fn err(&mut self) -> _ERRW {
                _ERRW { w: self }
            }
            #[doc = "Bit 3 - Synchronization Ready"]
            #[inline]
            pub fn syncrdy(&mut self) -> _SYNCRDYW {
                _SYNCRDYW { w: self }
            }
            #[doc = "Bit 4 - Match or Capture Channel 0"]
            #[inline]
            pub fn mc0(&mut self) -> _MC0W {
                _MC0W { w: self }
            }
            #[doc = "Bit 5 - Match or Capture Channel 1"]
            #[inline]
            pub fn mc1(&mut self) -> _MC1W {
                _MC1W { w: self }
            }
        }
    }
    #[doc = "Read Request"]
    pub struct READREQ {
        register: VolatileCell<u16>,
    }
    #[doc = "Read Request"]
    pub mod readreq {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u16,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u16,
        }
        impl super::READREQ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRR {
            bits: u8,
        }
        impl ADDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RCONTR {
            bits: bool,
        }
        impl RCONTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RREQR {
            bits: bool,
        }
        impl RREQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RCONTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RCONTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RREQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((value & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            #[doc = "Bits 0:4 - Address"]
            #[inline]
            pub fn addr(&self) -> ADDRR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ADDRR { bits }
            }
            #[doc = "Bit 14 - Read Continuously"]
            #[inline]
            pub fn rcont(&self) -> RCONTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RCONTR { bits }
            }
            #[doc = "Bit 15 - Read Request"]
            #[inline]
            pub fn rreq(&self) -> RREQR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) != 0
                };
                RREQR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Address"]
            #[inline]
            pub fn addr(&mut self) -> _ADDRW {
                _ADDRW { w: self }
            }
            #[doc = "Bit 14 - Read Continuously"]
            #[inline]
            pub fn rcont(&mut self) -> _RCONTW {
                _RCONTW { w: self }
            }
            #[doc = "Bit 15 - Read Request"]
            #[inline]
            pub fn rreq(&mut self) -> _RREQW {
                _RREQW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: bool,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLAVER {
            bits: bool,
        }
        impl SLAVER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 3 - Stop"]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                STOPR { bits }
            }
            #[doc = "Bit 4 - Slave"]
            #[inline]
            pub fn slave(&self) -> SLAVER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SLAVER { bits }
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Basic Timer Counter 0"]
pub struct TC0 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC0 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 1"]
pub const TC1: Peripheral<TC1> = unsafe { Peripheral::new(0x4200_2400) };
#[doc = r" Register block"]
pub struct TC1 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC1 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 2"]
pub const TC2: Peripheral<TC2> = unsafe { Peripheral::new(0x4200_2800) };
#[doc = r" Register block"]
pub struct TC2 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC2 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 3"]
pub const TC3: Peripheral<TC3> = unsafe { Peripheral::new(0x4200_2c00) };
#[doc = r" Register block"]
pub struct TC3 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC3 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 4"]
pub const TC4: Peripheral<TC4> = unsafe { Peripheral::new(0x4200_3000) };
#[doc = r" Register block"]
pub struct TC4 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC4 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic Timer Counter 5"]
pub const TC5: Peripheral<TC5> = unsafe { Peripheral::new(0x4200_3400) };
#[doc = r" Register block"]
pub struct TC5 {
    register_block: tc0::RegisterBlock,
}
impl Deref for TC5 {
    type Target = tc0::RegisterBlock;
    fn deref(&self) -> &tc0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Watchdog Timer"]
pub const WDT: Peripheral<WDT> = unsafe { Peripheral::new(0x4000_1000) };
#[doc = "Watchdog Timer"]
pub mod wdt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control"]
        pub ctrl: CTRL,
        #[doc = "0x01 - Configuration"]
        pub config: CONFIG,
        #[doc = "0x02 - Early Warning Interrupt Control"]
        pub ewctrl: EWCTRL,
        _reserved0: [u8; 1usize],
        #[doc = "0x04 - Interrupt Enable Clear"]
        pub intenclr: INTENCLR,
        #[doc = "0x05 - Interrupt Enable Set"]
        pub intenset: INTENSET,
        #[doc = "0x06 - Interrupt Flag Status and Clear"]
        pub intflag: INTFLAG,
        #[doc = "0x07 - Status"]
        pub status: STATUS,
        #[doc = "0x08 - Clear"]
        pub clear: CLEAR,
    }
    #[doc = "Clear"]
    pub struct CLEAR {
        register: VolatileCell<u8>,
    }
    #[doc = "Clear"]
    pub mod clear {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CLEAR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `CLEAR`"]
        pub enum CLEARW {
            #[doc = "Clear Key"]
            KEY,
        }
        impl CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLEARW::KEY => 165,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLEARW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Clear Key"]
            #[inline]
            pub fn key(self) -> &'a mut W {
                self.variant(CLEARW::KEY)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Watchdog Clear"]
            #[inline]
            pub fn clear(&mut self) -> _CLEARW {
                _CLEARW { w: self }
            }
        }
    }
    #[doc = "Configuration"]
    pub struct CONFIG {
        register: VolatileCell<u8>,
    }
    #[doc = "Configuration"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PERR {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PERR::_8 => 0,
                    PERR::_16 => 0x01,
                    PERR::_32 => 0x02,
                    PERR::_64 => 0x03,
                    PERR::_128 => 0x04,
                    PERR::_256 => 0x05,
                    PERR::_512 => 0x06,
                    PERR::_1K => 0x07,
                    PERR::_2K => 0x08,
                    PERR::_4K => 0x09,
                    PERR::_8K => 0x0a,
                    PERR::_16K => 0x0b,
                    PERR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PERR {
                match value {
                    0 => PERR::_8,
                    1 => PERR::_16,
                    2 => PERR::_32,
                    3 => PERR::_64,
                    4 => PERR::_128,
                    5 => PERR::_256,
                    6 => PERR::_512,
                    7 => PERR::_1K,
                    8 => PERR::_2K,
                    9 => PERR::_4K,
                    10 => PERR::_8K,
                    11 => PERR::_16K,
                    i => PERR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline]
            pub fn is_8(&self) -> bool {
                *self == PERR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline]
            pub fn is_16(&self) -> bool {
                *self == PERR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline]
            pub fn is_32(&self) -> bool {
                *self == PERR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline]
            pub fn is_64(&self) -> bool {
                *self == PERR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline]
            pub fn is_128(&self) -> bool {
                *self == PERR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline]
            pub fn is_256(&self) -> bool {
                *self == PERR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline]
            pub fn is_512(&self) -> bool {
                *self == PERR::_512
            }
            #[doc = "Checks if the value of the field is `_1K`"]
            #[inline]
            pub fn is_1k(&self) -> bool {
                *self == PERR::_1K
            }
            #[doc = "Checks if the value of the field is `_2K`"]
            #[inline]
            pub fn is_2k(&self) -> bool {
                *self == PERR::_2K
            }
            #[doc = "Checks if the value of the field is `_4K`"]
            #[inline]
            pub fn is_4k(&self) -> bool {
                *self == PERR::_4K
            }
            #[doc = "Checks if the value of the field is `_8K`"]
            #[inline]
            pub fn is_8k(&self) -> bool {
                *self == PERR::_8K
            }
            #[doc = "Checks if the value of the field is `_16K`"]
            #[inline]
            pub fn is_16k(&self) -> bool {
                *self == PERR::_16K
            }
        }
        #[doc = "Possible values of the field `WINDOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WINDOWR {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WINDOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WINDOWR::_8 => 0,
                    WINDOWR::_16 => 0x01,
                    WINDOWR::_32 => 0x02,
                    WINDOWR::_64 => 0x03,
                    WINDOWR::_128 => 0x04,
                    WINDOWR::_256 => 0x05,
                    WINDOWR::_512 => 0x06,
                    WINDOWR::_1K => 0x07,
                    WINDOWR::_2K => 0x08,
                    WINDOWR::_4K => 0x09,
                    WINDOWR::_8K => 0x0a,
                    WINDOWR::_16K => 0x0b,
                    WINDOWR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WINDOWR {
                match value {
                    0 => WINDOWR::_8,
                    1 => WINDOWR::_16,
                    2 => WINDOWR::_32,
                    3 => WINDOWR::_64,
                    4 => WINDOWR::_128,
                    5 => WINDOWR::_256,
                    6 => WINDOWR::_512,
                    7 => WINDOWR::_1K,
                    8 => WINDOWR::_2K,
                    9 => WINDOWR::_4K,
                    10 => WINDOWR::_8K,
                    11 => WINDOWR::_16K,
                    i => WINDOWR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline]
            pub fn is_8(&self) -> bool {
                *self == WINDOWR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline]
            pub fn is_16(&self) -> bool {
                *self == WINDOWR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline]
            pub fn is_32(&self) -> bool {
                *self == WINDOWR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline]
            pub fn is_64(&self) -> bool {
                *self == WINDOWR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline]
            pub fn is_128(&self) -> bool {
                *self == WINDOWR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline]
            pub fn is_256(&self) -> bool {
                *self == WINDOWR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline]
            pub fn is_512(&self) -> bool {
                *self == WINDOWR::_512
            }
            #[doc = "Checks if the value of the field is `_1K`"]
            #[inline]
            pub fn is_1k(&self) -> bool {
                *self == WINDOWR::_1K
            }
            #[doc = "Checks if the value of the field is `_2K`"]
            #[inline]
            pub fn is_2k(&self) -> bool {
                *self == WINDOWR::_2K
            }
            #[doc = "Checks if the value of the field is `_4K`"]
            #[inline]
            pub fn is_4k(&self) -> bool {
                *self == WINDOWR::_4K
            }
            #[doc = "Checks if the value of the field is `_8K`"]
            #[inline]
            pub fn is_8k(&self) -> bool {
                *self == WINDOWR::_8K
            }
            #[doc = "Checks if the value of the field is `_16K`"]
            #[inline]
            pub fn is_16k(&self) -> bool {
                *self == WINDOWR::_16K
            }
        }
        #[doc = "Values that can be written to the field `PER`"]
        pub enum PERW {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
        }
        impl PERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PERW::_8 => 0,
                    PERW::_16 => 1,
                    PERW::_32 => 2,
                    PERW::_64 => 3,
                    PERW::_128 => 4,
                    PERW::_256 => 5,
                    PERW::_512 => 6,
                    PERW::_1K => 7,
                    PERW::_2K => 8,
                    PERW::_4K => 9,
                    PERW::_8K => 10,
                    PERW::_16K => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PERW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline]
            pub fn _8(self) -> &'a mut W {
                self.variant(PERW::_8)
            }
            #[doc = "16 clock cycles"]
            #[inline]
            pub fn _16(self) -> &'a mut W {
                self.variant(PERW::_16)
            }
            #[doc = "32 clock cycles"]
            #[inline]
            pub fn _32(self) -> &'a mut W {
                self.variant(PERW::_32)
            }
            #[doc = "64 clock cycles"]
            #[inline]
            pub fn _64(self) -> &'a mut W {
                self.variant(PERW::_64)
            }
            #[doc = "128 clock cycles"]
            #[inline]
            pub fn _128(self) -> &'a mut W {
                self.variant(PERW::_128)
            }
            #[doc = "256 clock cycles"]
            #[inline]
            pub fn _256(self) -> &'a mut W {
                self.variant(PERW::_256)
            }
            #[doc = "512 clock cycles"]
            #[inline]
            pub fn _512(self) -> &'a mut W {
                self.variant(PERW::_512)
            }
            #[doc = "1024 clock cycles"]
            #[inline]
            pub fn _1k(self) -> &'a mut W {
                self.variant(PERW::_1K)
            }
            #[doc = "2048 clock cycles"]
            #[inline]
            pub fn _2k(self) -> &'a mut W {
                self.variant(PERW::_2K)
            }
            #[doc = "4096 clock cycles"]
            #[inline]
            pub fn _4k(self) -> &'a mut W {
                self.variant(PERW::_4K)
            }
            #[doc = "8192 clock cycles"]
            #[inline]
            pub fn _8k(self) -> &'a mut W {
                self.variant(PERW::_8K)
            }
            #[doc = "16384 clock cycles"]
            #[inline]
            pub fn _16k(self) -> &'a mut W {
                self.variant(PERW::_16K)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WINDOW`"]
        pub enum WINDOWW {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
        }
        impl WINDOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WINDOWW::_8 => 0,
                    WINDOWW::_16 => 1,
                    WINDOWW::_32 => 2,
                    WINDOWW::_64 => 3,
                    WINDOWW::_128 => 4,
                    WINDOWW::_256 => 5,
                    WINDOWW::_512 => 6,
                    WINDOWW::_1K => 7,
                    WINDOWW::_2K => 8,
                    WINDOWW::_4K => 9,
                    WINDOWW::_8K => 10,
                    WINDOWW::_16K => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINDOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINDOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WINDOWW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline]
            pub fn _8(self) -> &'a mut W {
                self.variant(WINDOWW::_8)
            }
            #[doc = "16 clock cycles"]
            #[inline]
            pub fn _16(self) -> &'a mut W {
                self.variant(WINDOWW::_16)
            }
            #[doc = "32 clock cycles"]
            #[inline]
            pub fn _32(self) -> &'a mut W {
                self.variant(WINDOWW::_32)
            }
            #[doc = "64 clock cycles"]
            #[inline]
            pub fn _64(self) -> &'a mut W {
                self.variant(WINDOWW::_64)
            }
            #[doc = "128 clock cycles"]
            #[inline]
            pub fn _128(self) -> &'a mut W {
                self.variant(WINDOWW::_128)
            }
            #[doc = "256 clock cycles"]
            #[inline]
            pub fn _256(self) -> &'a mut W {
                self.variant(WINDOWW::_256)
            }
            #[doc = "512 clock cycles"]
            #[inline]
            pub fn _512(self) -> &'a mut W {
                self.variant(WINDOWW::_512)
            }
            #[doc = "1024 clock cycles"]
            #[inline]
            pub fn _1k(self) -> &'a mut W {
                self.variant(WINDOWW::_1K)
            }
            #[doc = "2048 clock cycles"]
            #[inline]
            pub fn _2k(self) -> &'a mut W {
                self.variant(WINDOWW::_2K)
            }
            #[doc = "4096 clock cycles"]
            #[inline]
            pub fn _4k(self) -> &'a mut W {
                self.variant(WINDOWW::_4K)
            }
            #[doc = "8192 clock cycles"]
            #[inline]
            pub fn _8k(self) -> &'a mut W {
                self.variant(WINDOWW::_8K)
            }
            #[doc = "16384 clock cycles"]
            #[inline]
            pub fn _16k(self) -> &'a mut W {
                self.variant(WINDOWW::_16K)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Time-Out Period"]
            #[inline]
            pub fn per(&self) -> PERR {
                PERR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
            #[doc = "Bits 4:7 - Window Mode Time-Out Period"]
            #[inline]
            pub fn window(&self) -> WINDOWR {
                WINDOWR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xbb }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Time-Out Period"]
            #[inline]
            pub fn per(&mut self) -> _PERW {
                _PERW { w: self }
            }
            #[doc = "Bits 4:7 - Window Mode Time-Out Period"]
            #[inline]
            pub fn window(&mut self) -> _WINDOWW {
                _WINDOWW { w: self }
            }
        }
    }
    #[doc = "Control"]
    pub struct CTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WENR {
            bits: bool,
        }
        impl WENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALWAYSONR {
            bits: bool,
        }
        impl ALWAYSONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALWAYSONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALWAYSONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
            #[inline]
            pub fn wen(&self) -> WENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                WENR { bits }
            }
            #[doc = "Bit 7 - Always-On"]
            #[inline]
            pub fn alwayson(&self) -> ALWAYSONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                ALWAYSONR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
            #[inline]
            pub fn wen(&mut self) -> _WENW {
                _WENW { w: self }
            }
            #[doc = "Bit 7 - Always-On"]
            #[inline]
            pub fn alwayson(&mut self) -> _ALWAYSONW {
                _ALWAYSONW { w: self }
            }
        }
    }
    #[doc = "Early Warning Interrupt Control"]
    pub struct EWCTRL {
        register: VolatileCell<u8>,
    }
    #[doc = "Early Warning Interrupt Control"]
    pub mod ewctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::EWCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EWOFFSET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWOFFSETR {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EWOFFSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EWOFFSETR::_8 => 0,
                    EWOFFSETR::_16 => 0x01,
                    EWOFFSETR::_32 => 0x02,
                    EWOFFSETR::_64 => 0x03,
                    EWOFFSETR::_128 => 0x04,
                    EWOFFSETR::_256 => 0x05,
                    EWOFFSETR::_512 => 0x06,
                    EWOFFSETR::_1K => 0x07,
                    EWOFFSETR::_2K => 0x08,
                    EWOFFSETR::_4K => 0x09,
                    EWOFFSETR::_8K => 0x0a,
                    EWOFFSETR::_16K => 0x0b,
                    EWOFFSETR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EWOFFSETR {
                match value {
                    0 => EWOFFSETR::_8,
                    1 => EWOFFSETR::_16,
                    2 => EWOFFSETR::_32,
                    3 => EWOFFSETR::_64,
                    4 => EWOFFSETR::_128,
                    5 => EWOFFSETR::_256,
                    6 => EWOFFSETR::_512,
                    7 => EWOFFSETR::_1K,
                    8 => EWOFFSETR::_2K,
                    9 => EWOFFSETR::_4K,
                    10 => EWOFFSETR::_8K,
                    11 => EWOFFSETR::_16K,
                    i => EWOFFSETR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_8`"]
            #[inline]
            pub fn is_8(&self) -> bool {
                *self == EWOFFSETR::_8
            }
            #[doc = "Checks if the value of the field is `_16`"]
            #[inline]
            pub fn is_16(&self) -> bool {
                *self == EWOFFSETR::_16
            }
            #[doc = "Checks if the value of the field is `_32`"]
            #[inline]
            pub fn is_32(&self) -> bool {
                *self == EWOFFSETR::_32
            }
            #[doc = "Checks if the value of the field is `_64`"]
            #[inline]
            pub fn is_64(&self) -> bool {
                *self == EWOFFSETR::_64
            }
            #[doc = "Checks if the value of the field is `_128`"]
            #[inline]
            pub fn is_128(&self) -> bool {
                *self == EWOFFSETR::_128
            }
            #[doc = "Checks if the value of the field is `_256`"]
            #[inline]
            pub fn is_256(&self) -> bool {
                *self == EWOFFSETR::_256
            }
            #[doc = "Checks if the value of the field is `_512`"]
            #[inline]
            pub fn is_512(&self) -> bool {
                *self == EWOFFSETR::_512
            }
            #[doc = "Checks if the value of the field is `_1K`"]
            #[inline]
            pub fn is_1k(&self) -> bool {
                *self == EWOFFSETR::_1K
            }
            #[doc = "Checks if the value of the field is `_2K`"]
            #[inline]
            pub fn is_2k(&self) -> bool {
                *self == EWOFFSETR::_2K
            }
            #[doc = "Checks if the value of the field is `_4K`"]
            #[inline]
            pub fn is_4k(&self) -> bool {
                *self == EWOFFSETR::_4K
            }
            #[doc = "Checks if the value of the field is `_8K`"]
            #[inline]
            pub fn is_8k(&self) -> bool {
                *self == EWOFFSETR::_8K
            }
            #[doc = "Checks if the value of the field is `_16K`"]
            #[inline]
            pub fn is_16k(&self) -> bool {
                *self == EWOFFSETR::_16K
            }
        }
        #[doc = "Values that can be written to the field `EWOFFSET`"]
        pub enum EWOFFSETW {
            #[doc = "8 clock cycles"]
            _8,
            #[doc = "16 clock cycles"]
            _16,
            #[doc = "32 clock cycles"]
            _32,
            #[doc = "64 clock cycles"]
            _64,
            #[doc = "128 clock cycles"]
            _128,
            #[doc = "256 clock cycles"]
            _256,
            #[doc = "512 clock cycles"]
            _512,
            #[doc = "1024 clock cycles"]
            _1K,
            #[doc = "2048 clock cycles"]
            _2K,
            #[doc = "4096 clock cycles"]
            _4K,
            #[doc = "8192 clock cycles"]
            _8K,
            #[doc = "16384 clock cycles"]
            _16K,
        }
        impl EWOFFSETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EWOFFSETW::_8 => 0,
                    EWOFFSETW::_16 => 1,
                    EWOFFSETW::_32 => 2,
                    EWOFFSETW::_64 => 3,
                    EWOFFSETW::_128 => 4,
                    EWOFFSETW::_256 => 5,
                    EWOFFSETW::_512 => 6,
                    EWOFFSETW::_1K => 7,
                    EWOFFSETW::_2K => 8,
                    EWOFFSETW::_4K => 9,
                    EWOFFSETW::_8K => 10,
                    EWOFFSETW::_16K => 11,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWOFFSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWOFFSETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EWOFFSETW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8 clock cycles"]
            #[inline]
            pub fn _8(self) -> &'a mut W {
                self.variant(EWOFFSETW::_8)
            }
            #[doc = "16 clock cycles"]
            #[inline]
            pub fn _16(self) -> &'a mut W {
                self.variant(EWOFFSETW::_16)
            }
            #[doc = "32 clock cycles"]
            #[inline]
            pub fn _32(self) -> &'a mut W {
                self.variant(EWOFFSETW::_32)
            }
            #[doc = "64 clock cycles"]
            #[inline]
            pub fn _64(self) -> &'a mut W {
                self.variant(EWOFFSETW::_64)
            }
            #[doc = "128 clock cycles"]
            #[inline]
            pub fn _128(self) -> &'a mut W {
                self.variant(EWOFFSETW::_128)
            }
            #[doc = "256 clock cycles"]
            #[inline]
            pub fn _256(self) -> &'a mut W {
                self.variant(EWOFFSETW::_256)
            }
            #[doc = "512 clock cycles"]
            #[inline]
            pub fn _512(self) -> &'a mut W {
                self.variant(EWOFFSETW::_512)
            }
            #[doc = "1024 clock cycles"]
            #[inline]
            pub fn _1k(self) -> &'a mut W {
                self.variant(EWOFFSETW::_1K)
            }
            #[doc = "2048 clock cycles"]
            #[inline]
            pub fn _2k(self) -> &'a mut W {
                self.variant(EWOFFSETW::_2K)
            }
            #[doc = "4096 clock cycles"]
            #[inline]
            pub fn _4k(self) -> &'a mut W {
                self.variant(EWOFFSETW::_4K)
            }
            #[doc = "8192 clock cycles"]
            #[inline]
            pub fn _8k(self) -> &'a mut W {
                self.variant(EWOFFSETW::_8K)
            }
            #[doc = "16384 clock cycles"]
            #[inline]
            pub fn _16k(self) -> &'a mut W {
                self.variant(EWOFFSETW::_16K)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
            #[inline]
            pub fn ewoffset(&self) -> EWOFFSETR {
                EWOFFSETR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0b }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
            #[inline]
            pub fn ewoffset(&mut self) -> _EWOFFSETW {
                _EWOFFSETW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear"]
    pub struct INTENCLR {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Clear"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set"]
    pub struct INTENSET {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Enable Set"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning Interrupt Enable"]
            #[inline]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub struct INTFLAG {
        register: VolatileCell<u8>,
    }
    #[doc = "Interrupt Flag Status and Clear"]
    pub mod intflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::INTFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWR {
            bits: bool,
        }
        impl EWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Early Warning"]
            #[inline]
            pub fn ew(&self) -> EWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                EWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Warning"]
            #[inline]
            pub fn ew(&mut self) -> _EWW {
                _EWW { w: self }
            }
        }
    }
    #[doc = "Status"]
    pub struct STATUS {
        register: VolatileCell<u8>,
    }
    #[doc = "Status"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SYNCBUSYR {
            bits: bool,
        }
        impl SYNCBUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 7 - Synchronization Busy"]
            #[inline]
            pub fn syncbusy(&self) -> SYNCBUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                SYNCBUSYR { bits }
            }
        }
    }
}
#[doc = "Watchdog Timer"]
pub struct WDT {
    register_block: wdt::RegisterBlock,
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    fn deref(&self) -> &wdt::RegisterBlock {
        &self.register_block
    }
}
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals<'a> {
    #[doc = "CPUID"]
    pub CPUID: &'a CPUID,
    #[doc = "DCB"]
    pub DCB: &'a DCB,
    #[doc = "DWT"]
    pub DWT: &'a DWT,
    #[doc = "FPB"]
    pub FPB: &'a FPB,
    #[doc = "FPU"]
    pub FPU: &'a FPU,
    #[doc = "ITM"]
    pub ITM: &'a ITM,
    #[doc = "MPU"]
    pub MPU: &'a MPU,
    #[doc = "NVIC"]
    pub NVIC: &'a NVIC,
    #[doc = "SCB"]
    pub SCB: &'a SCB,
    #[doc = "SYST"]
    pub SYST: &'a SYST,
    #[doc = "TPIU"]
    pub TPIU: &'a TPIU,
    #[doc = "AC"]
    pub AC: &'a AC,
    #[doc = "ADC"]
    pub ADC: &'a ADC,
    #[doc = "DAC"]
    pub DAC: &'a DAC,
    #[doc = "DSU"]
    pub DSU: &'a DSU,
    #[doc = "EIC"]
    pub EIC: &'a EIC,
    #[doc = "EVSYS"]
    pub EVSYS: &'a EVSYS,
    #[doc = "GCLK"]
    pub GCLK: &'a GCLK,
    #[doc = "NVMCTRL"]
    pub NVMCTRL: &'a NVMCTRL,
    #[doc = "PAC0"]
    pub PAC0: &'a PAC0,
    #[doc = "PAC1"]
    pub PAC1: &'a PAC1,
    #[doc = "PAC2"]
    pub PAC2: &'a PAC2,
    #[doc = "PM"]
    pub PM: &'a PM,
    #[doc = "PORT"]
    pub PORT: &'a PORT,
    #[doc = "SERCOM0"]
    pub SERCOM0: &'a SERCOM0,
    #[doc = "SERCOM1"]
    pub SERCOM1: &'a SERCOM1,
    #[doc = "SERCOM2"]
    pub SERCOM2: &'a SERCOM2,
    #[doc = "SERCOM3"]
    pub SERCOM3: &'a SERCOM3,
    #[doc = "SYSCTRL"]
    pub SYSCTRL: &'a SYSCTRL,
    #[doc = "TC0"]
    pub TC0: &'a TC0,
    #[doc = "TC1"]
    pub TC1: &'a TC1,
    #[doc = "TC2"]
    pub TC2: &'a TC2,
    #[doc = "TC3"]
    pub TC3: &'a TC3,
    #[doc = "TC4"]
    pub TC4: &'a TC4,
    #[doc = "TC5"]
    pub TC5: &'a TC5,
    #[doc = "WDT"]
    pub WDT: &'a WDT,
}
impl<'a> Peripherals<'a> {
    #[doc = r" Grants access to all the peripherals"]
    pub unsafe fn all() -> Self {
        Peripherals {
            CPUID: &*CPUID.get(),
            DCB: &*DCB.get(),
            DWT: &*DWT.get(),
            FPB: &*FPB.get(),
            FPU: &*FPU.get(),
            ITM: &*ITM.get(),
            MPU: &*MPU.get(),
            NVIC: &*NVIC.get(),
            SCB: &*SCB.get(),
            SYST: &*SYST.get(),
            TPIU: &*TPIU.get(),
            AC: &*AC.get(),
            ADC: &*ADC.get(),
            DAC: &*DAC.get(),
            DSU: &*DSU.get(),
            EIC: &*EIC.get(),
            EVSYS: &*EVSYS.get(),
            GCLK: &*GCLK.get(),
            NVMCTRL: &*NVMCTRL.get(),
            PAC0: &*PAC0.get(),
            PAC1: &*PAC1.get(),
            PAC2: &*PAC2.get(),
            PM: &*PM.get(),
            PORT: &*PORT.get(),
            SERCOM0: &*SERCOM0.get(),
            SERCOM1: &*SERCOM1.get(),
            SERCOM2: &*SERCOM2.get(),
            SERCOM3: &*SERCOM3.get(),
            SYSCTRL: &*SYSCTRL.get(),
            TC0: &*TC0.get(),
            TC1: &*TC1.get(),
            TC2: &*TC2.get(),
            TC3: &*TC3.get(),
            TC4: &*TC4.get(),
            TC5: &*TC5.get(),
            WDT: &*WDT.get(),
        }
    }
}
